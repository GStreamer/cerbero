From bc0c205188dbe52527ca7f72be88efdd61a9cd75 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@amyspark.me>
Date: Tue, 18 Apr 2023 22:16:49 -0300
Subject: [PATCH] Add Meson build

For more information, please see https://github.com/dragonCodecs/libvpx/tree/old-meson

diff --git a/LICENSE.meson.md b/LICENSE.meson.md
new file mode 100644
index 000000000..5fdcefb66
--- /dev/null
+++ b/LICENSE.meson.md
@@ -0,0 +1,51 @@
+Copyright (c) 2023 L. E. Segovia <amy@amyspark.me>
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+  * Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+
+  * Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in
+    the documentation and/or other materials provided with the
+    distribution.
+
+  * Neither the name of Google, nor the WebM Project, nor the names
+    of its contributors may be used to endorse or promote products
+    derived from this software without specific prior written
+    permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+The file meson/parse_sources.py is specifically licensed as follows:
+
+Copyright (c) 2018 Mathieu Duponchelle <mathieu@centricular.com>
+Copyright (c) 2023 L. E. Segovia <amy@amyspark.me>
+
+This file is based on the FFmpeg Meson build version
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, see <http://www.gnu.org/licenses/>.
diff --git a/README.meson.md b/README.meson.md
new file mode 100644
index 000000000..06e6194ab
--- /dev/null
+++ b/README.meson.md
@@ -0,0 +1,98 @@
+# Building libvpx with Meson
+
+This libvpx port requires Meson 0.64 or higher because it supports Nasm out of
+the box.
+
+Get Meson, either from your distro's package manager, or using pip:
+
+```
+python3 -m pip install meson --user
+```
+
+Get ninja, either from your distro's package manager, or using pip:
+
+```
+python3 -m pip install ninja-build --user
+```
+
+You will also need:
+
+- Perl (for Windows users, Strawberry Perl suffices)
+- Nasm >= 2.09 OR Yasm
+
+**WARNING**: Mac OS X users with very old SDKs, please don't use the bundled Yasm.
+It will be rejected out of the box.
+
+Optional dependencies:
+
+- cURL
+- Doxygen 1.5.5.3 or higher
+
+Then in the root folder (where this file resides):
+
+```
+meson setup build && meson compile -C build
+```
+
+I've tested that it builds and links with the following operating systems:
+
+- macOS Big Sur 11.7.4 x86_64 (Xcode 13.2.1)
+- Windows 10 21H2 x86_64
+  - MSVC 17.6.0 Preview 2
+  - Clang 16.0.1 (MSYS CLANG64)
+
+# Running the tests:
+
+The tests are **not** available by default because they require multi-gigabyte 
+artifact that are downloaded at build time from Google's CDN. I believe they 
+are intended to be run from inside Google's own CI infrastructure.
+
+If cURL is not available, they will be silently skipped.
+
+WARNING: some tests require `-Ddefault_library=static` to be available.
+
+To run them, issue:
+
+```
+meson setup build -Ddefault_library=static -Dtests=true
+meson test -C build
+```
+
+# Updating the libvpx base snapshot of the Meson port
+
+The procedure is based on GStreamer's work on FFmpeg, which is available here:
+
+https://gitlab.freedesktop.org/gstreamer/meson-ports/ffmpeg/-/blob/meson-4.4/README.meson
+
+It should only be needed when updating from one feature version to another,
+not for minor bug fix releases (assuming there aren't too many changes in
+`configure` between minor bug fix releases).
+
+The procedure is generally to (all scripts are in the `meson` folder):
+
+- apply the `patch-configure.diff` patch to make all toggle options available
+- in a Bash shell, run `./configure --help` and save the output to `tmp_meson_options.txt` **in the root folder**
+- run the scripts `capture_build_options.py` and `parse_sources.py`
+- make sure to bring back in the manual changes (that's the tedious part).
+
+Both .py scripts work in place, you will need to check the diff and
+revert some of the changes.
+
+## The Python scripts
+
+- `parse_sources.py` updates the meson.build files trying to keep the parsed
+  source files within the `#### --- [END] GENERATED --- ####` specifiers
+
+- `capture_build_options.py` updates the meson_options.txt file trying to keep
+  the automatically parsed options within the
+  `#### --- [END] GENERATED OPTIONS --- ####` specifiers
+
+Then bump versions and check what changed in `configure` since the last time,
+which is the other complicated bit, as it requires understanding of the
+somewhat complex ffmpeg-based build system and of the way it was reimplemented
+for the Meson port. I've made sure to keep it 1:1 as much as possible, while 
+using some Meson-isms to accelerate things. You'll find most of the logic is 
+based off `libs.mk`, `examples.mk`, `configure` and `build/make/configure.sh`.
+The source files and functions for the different parts are added with comments.
+
+Good luck!
diff --git a/examples/meson.build b/examples/meson.build
new file mode 100644
index 000000000..9c3df73ab
--- /dev/null
+++ b/examples/meson.build
@@ -0,0 +1,452 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+examples_subpages = {}
+utils_subpages = {}
+
+examples_deps = [libvpx_dep]
+
+# List of examples to build. UTILS are tools meant for distribution
+# while EXAMPLES demonstrate specific portions of the API.
+
+# Unlike the original, I'm putting all the common files in a
+# single library to save on up to 16 copies of the same translation unit
+# (y4minput.c and tools_common.c, for instance).
+
+vpx_examples_common_headers = []
+
+vpx_examples_common_sources = []
+
+if features.get('decoders', false) or features.get('encoders', false)
+	vpx_examples_common_headers += files(
+		'../vpx_ports/mem_ops.h',
+		'../vpx_ports/mem_ops_aligned.h',
+		'../vpx_ports/msvc.h',
+		'../args.h',
+		'../ivfdec.h',
+		'../y4minput.h',
+		'../tools_common.h',
+		'../ivfenc.h', # encoders or decoders or vp8|9_encoder or (decoders and vp9_encoder)
+		'../vpx_ports/vpx_timer.h',
+		'../video_common.h',
+	)
+
+	vpx_examples_common_sources += files(
+		'../args.c',
+		'../ivfdec.c',
+		'../y4minput.c',
+		'../tools_common.c',
+		'../ivfenc.c', # encoders or decoders or vp8|9_encoder or (decoders and vp9_encoder)
+	)
+endif
+
+if features.get('decoders', false)
+	vpx_examples_common_headers += files(
+		'../vpx_ports/compiler_attributes.h',
+		'../md5_utils.h',
+		'../video_reader.h',
+	)
+
+	vpx_examples_common_sources += files(
+		'../md5_utils.c',
+		'../video_reader.c',
+	)
+endif
+
+if features.get('encoders', false) or features.get('vp9_encoder', false)
+	vpx_examples_common_headers += files(
+		'../vpxstats.h',
+	)
+
+	vpx_examples_common_sources += files(
+		'../vpxstats.c',
+	)
+endif
+
+if features.get('encoders', false) or (features.get('decoders', false) and features.get('vp9_encoder', false))
+	vpx_examples_common_headers += files(
+		'../video_writer.h',
+	)
+
+	vpx_examples_common_sources += files(
+		'../video_writer.c',
+	)
+endif
+
+vpx_examples_common = static_library(
+	'vpx_examples_common',
+	vpx_examples_common_sources,
+	extra_files: vpx_examples_common_headers,
+	dependencies: examples_deps,
+)
+
+examples_deps += declare_dependency(
+	link_with: vpx_examples_common,
+	include_directories: include_directories('.'),
+)
+
+vpxdec_headers = files(
+	'../vpx/vpx_integer.h',
+	'../y4menc.h',
+)
+
+vpxdec_srcs = files(
+	'../vpxdec.c',
+	'../y4menc.c',
+)
+
+vpxenc_headers = files(
+	'../vpxenc.h',
+	'../rate_hist.h',
+	'../warnings.h',
+)
+
+vpxenc_srcs = files(
+	'../vpxenc.c',
+	'../rate_hist.c',
+	'../warnings.c',
+)
+
+vp9_spatial_svc_encoder_headers = files(
+	'svc_context.h',
+)
+
+vp9_spatial_svc_encoder_srcs = files(
+	'vp9_spatial_svc_encoder.c',
+	'svc_encodeframe.c',
+)
+
+vpx_temporal_svc_encoder_headers = files(
+)
+
+vpx_temporal_svc_encoder_srcs = files(
+	'vpx_temporal_svc_encoder.c',
+)
+
+simple_decoder_headers = files(
+)
+
+simple_decoder_srcs  = files(
+	'simple_decoder.c',
+)
+
+postproc_headers = files(
+)
+
+postproc_srcs  = files(
+	'postproc.c',
+)
+
+decode_to_md5_srcs = files(
+	'decode_to_md5.c'
+)
+
+decode_to_md5_headers = files(
+)
+
+simple_encoder_headers = files(
+)
+
+simple_encoder_srcs = files(
+	'simple_encoder.c',
+)
+
+simple_encoder_headers = files(
+)
+
+vp9_lossless_encoder_srcs = files(
+	'vp9_lossless_encoder.c',
+)
+
+vp9_lossless_encoder_headers = files(
+)
+
+twopass_encoder_srcs = files(
+	'twopass_encoder.c',
+)
+
+twopass_encoder_headers = files(
+)
+
+decode_with_drops_srcs = files(
+	'decode_with_drops.c',
+)
+
+decode_with_drops_headers = files(
+)
+
+set_maps_srcs = files(
+	'set_maps.c',
+)
+
+set_maps_headers = files(
+)
+
+vp8cx_set_ref_srcs = files(
+	'vp8cx_set_ref.c',
+)
+
+vp8cx_set_ref_headers = files(
+)
+
+vp9cx_set_ref_srcs = files(
+	'vp9cx_set_ref.c',
+)
+
+vp9cx_set_ref_headers = files(
+)
+
+vp8_multi_resolution_encoder_srcs = files(
+	'vp8_multi_resolution_encoder.c',
+)
+
+vp9cx_set_ref_headers = files(
+)
+
+# Add compile flags and include path for libwebm sources.
+if features.get('webm_io', false)
+	examples_deps += libwebm_dep
+
+	vpxdec_headers += files(
+		'../webmdec.h',
+	)
+	vpxdec_srcs += files(
+		'../webmdec.cc'
+	)
+
+	vpxenc_headers += files(
+		'../webmenc.h',
+	)
+	vpxenc_srcs += files(
+		'../webmenc.cc'
+	)
+endif
+
+if features.get('decoders', false)
+	vpxdec_deps = examples_deps
+
+	if features.get('libyuv', false)
+		vpxdec_deps += libyuv_dep
+	endif
+
+	vpxdec = executable(
+		'vpxdec',
+		vpxdec_srcs,
+		extra_files: vpxdec_headers,
+		dependencies: vpxdec_deps,
+		install: features.get('install_bins', false),
+	)
+
+	utils_subpages += {
+		'vpxdec': 'Full featured decoder'
+	}
+endif
+
+if features.get('encoders', false)
+	vpxenc_deps = examples_deps
+
+	if features.get('libyuv', false)
+		vpxenc_deps += libyuv_dep
+	endif
+
+	vpxenc = executable(
+		'vpxenc',
+		vpxenc_srcs,
+		extra_files: vpxenc_headers,
+		dependencies: vpxenc_deps,
+		install: features.get('install_bins', false),
+	)
+
+	utils_subpages += {
+		'vpxenc': 'Full featured encoder'
+	}
+endif
+
+if features.get('vp9_encoder', false)
+	vp9_spatial_svc_encoder = executable(
+		'vp9_spatial_svc_encoder',
+		vp9_spatial_svc_encoder_srcs,
+		extra_files: vp9_spatial_svc_encoder_headers,
+		dependencies: examples_deps,
+	)
+
+	examples_subpages += {
+		'vp9_spatial_svc_encoder': 'VP9 Spatial SVC Encoder'
+	}
+endif
+
+if not features.get('shared', false)
+	resize_util = executable(
+		'resize_util',
+		files(
+			'resize_util.c'
+		),
+		dependencies: examples_deps,
+	)
+endif
+
+if features.get('encoders', false)
+	vpx_temporal_svc_encoder = executable(
+		'vpx_temporal_svc_encoder',
+		vpx_temporal_svc_encoder_srcs,
+		extra_files: vpx_temporal_svc_encoder_headers,
+		dependencies: examples_deps,
+	)
+
+	decode_to_md5 = executable(
+		'decode_to_md5',
+		decode_to_md5_srcs,
+		extra_files: decode_to_md5_headers,
+		dependencies: examples_deps,
+	)
+
+	simple_encoder = executable(
+		'simple_encoder',
+		simple_encoder_srcs,
+		extra_files: simple_encoder_headers,
+		dependencies: examples_deps,
+	)
+
+	vp9_lossless_encoder = executable(
+		'vp9_lossless_encoder',
+		vp9_lossless_encoder_srcs,
+		extra_files: vp9_lossless_encoder_headers,
+		dependencies: examples_deps,
+	)
+
+	twopass_encoder = executable(
+		'twopass_encoder',
+		twopass_encoder_srcs,
+		extra_files: twopass_encoder_headers,
+		dependencies: examples_deps,
+	)
+
+	set_maps = executable(
+		'set_maps',
+		set_maps_srcs,
+		extra_files: set_maps_headers,
+		dependencies: examples_deps,
+	)
+
+	examples_subpages += {
+		'vpx_temporal_svc_encoder': 'Temporal SVC Encoder',
+		'decode_to_md5': 'Frame by frame MD5 checksum',
+		'simple_encoder': 'Simplified encoder loop',
+		'vp9_lossless_encoder': 'Simplified lossless VP9 encoder',
+		'twopass_encoder': 'Two-pass encoder loop',
+		'set_maps': 'Set active and ROI maps',
+	}
+endif
+
+if features.get('decoders', false)
+	simple_decoder = executable(
+		'simple_decoder',
+		simple_decoder_srcs,
+		extra_files: simple_decoder_headers,
+		dependencies: examples_deps,
+	)
+
+	postproc = executable(
+		'postproc',
+		postproc_srcs,
+		extra_files: postproc_headers,
+		dependencies: examples_deps,
+	)
+
+	decode_with_drops = executable(
+		'decode_with_drops',
+		decode_with_drops_srcs,
+		extra_files: postproc_headers,
+		dependencies: examples_deps,
+	)
+
+	examples_subpages += {
+		'simple_decoder': 'Simplified decoder loop',
+		'postproc': 'Decoder postprocessor control',
+		'decode_with_drops': 'Drops frames while decoding',
+	}
+endif
+
+if features.get('vp8_encoder', false)
+	vp8cx_set_ref = executable(
+		'vp8cx_set_ref',
+		vp8cx_set_ref_srcs,
+		extra_files: vp8cx_set_ref_headers,
+		dependencies: examples_deps,
+	)
+
+	examples_subpages += {
+		'vp8cx_set_ref': 'VP8 set encoder reference frame',
+	}
+endif
+
+if features.get('vp9_encoder', false) and features.get('decoders', false)
+	vp9cx_set_ref = executable(
+		'vp9cx_set_ref',
+		vp9cx_set_ref_srcs,
+		extra_files: vp9cx_set_ref_headers,
+		dependencies: examples_deps,
+	)
+
+	examples_subpages += {
+		'vp9cx_set_ref': 'VP9 set encoder reference frame',
+	}
+endif
+
+if features.get('multi_res_encoding', false) and features.get('libyuv', false)
+	vp8_multi_resolution_encoder = executable(
+		'vp8_multi_resolution_encoder',
+		vp8_multi_resolution_encoder_srcs,
+		extra_files: vp8_multi_resolution_encoder_headers,
+		dependencies: examples_deps + libyuv_dep,
+	)
+
+	examples_subpages += {
+		'vp8_multi_resolution_encoder': 'VP8 Multiple-resolution Encoding',
+	}
+endif
+
+#
+# Documentation Rules
+#
+
+if features.get('install_docs', false)
+	doxfiles = []
+	examples_subpages_entries = []
+	utils_subpages_entries = []
+
+	foreach page, description: examples_subpages
+		doxfiles += configure_file(
+			command: [generate_component_dox, '--component', 'example', '--output', '@OUTPUT@', '@INPUT@'],
+			input: get_variable('@0@_srcs'.format(page))[0],
+			output: '@0@.dox'.format(page),
+		)
+
+		examples_subpages_entries += '    - \subpage example_@0@ @1@'.format(page, description)
+	endforeach
+
+	foreach page, description: utils_subpages
+		doxfiles += configure_file(
+			command: [generate_component_dox, '--component', 'example', '--output', '@OUTPUT@', '@INPUT@'],
+			input: get_variable('@0@_srcs'.format(page))[0],
+			output: '@0@.dox'.format(page),
+		)
+
+		utils_subpages_entries += '    - \subpage example_@0@ @1@'.format(page, description)
+	endforeach
+
+	samples_dox = configure_file(
+		input: 'samples.dox.in',
+		output: 'samples.dox',
+		configuration: {
+			'examples_subpages': '\n'.join(examples_subpages_entries),
+			'utils_subpages': '\n'.join(utils_subpages_entries),
+		}
+	)
+
+	examples_doxy = configure_file(
+		command: [doxy_template, '--sections', 'samples', '--output', '@OUTPUT@', '@INPUT@'],
+		input: [samples_dox] + doxfiles,
+		output: 'examples.doxy',
+	)
+endif
diff --git a/examples/samples.dox.in b/examples/samples.dox.in
new file mode 100644
index 000000000..75bbd72de
--- /dev/null
+++ b/examples/samples.dox.in
@@ -0,0 +1,14 @@
+/*!\page samples Sample Code
+    This SDK includes a number of sample applications.
+    Each sample documents a feature of the SDK in both prose
+    and the associated C code.
+    The following samples are included: 
+@examples_subpages@
+
+    In addition, the SDK contains a number of utilities.
+    Since these utilities are built upon the concepts described
+    in the sample code listed above, they are not documented in
+    pieces like the samples are. Their source is included here
+    for reference. The following utilities are included:
+@utils_subpages@
+*/
diff --git a/meson.build b/meson.build
new file mode 100644
index 000000000..78578a1f5
--- /dev/null
+++ b/meson.build
@@ -0,0 +1,1900 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+project(
+	'libvpx',
+	'c', 'cpp',
+	version: '1.13.0',
+	default_options: [
+		# Enforce c89 for c files. Don't be too strict about it though. Allow
+		# gnu extensions like "//" for comments.
+		'c_std=gnu89',
+		# Uncomment when Meson can handle this one for MSVC.
+		# 'cpp_std=gnu++11',
+		'warning_level=2',
+		'default_library=static',
+		'buildtype=debugoptimized',
+	],
+	license: 'BSD-3-Clause',
+	meson_version: '>=0.64',
+)
+
+features = configuration_data()
+
+asm_conversion_exe = disabler()
+asm_conversion_cmd = []
+as_sfx = '.asm'
+asm_args = []
+tune_cflags = ''
+rtcd_options = []
+link_args = []
+extra_libs = []
+
+libyuv_cpp_args = []
+
+#######################
+###### configure ######
+#######################
+
+# all_targets is a list of all targets that can be configured
+# note that these should be in dependency order for now.
+all_targets = [
+	'libs',
+	'examples',
+	'tools',
+	'docs',
+]
+
+# all targets available are enabled, by default.
+foreach t : all_targets
+	features.set(t, true)
+endforeach
+
+# we don't use diff in Meson.
+perl_executables = ['perl']
+# Adding Meson overrides manually.
+if host_machine.system() == 'windows'
+	perl_executables += ['perl_windows_exe']
+endif
+perl_exe = find_program(perl_executables, required: true)
+
+doxygen = find_program('doxygen', required: false, disabler: true)
+
+if doxygen.found()
+	doxygen_version = doxygen.version()
+
+	if doxygen_version.version_compare('>= 1.5.5.3')
+		features.set('doxygen', true)
+	endif
+endif
+
+# We don't disable codecs when their source directory does not exist
+# because it's Git and they all exist.
+
+# install everything except the sources, by default. sources will have
+# to be enabled when doing dist builds, since that's no longer a common
+# case.
+if features.get('doxygen', false)
+	features.set('install_docs', true)
+endif
+features.set('install_bins', true)
+features.set('install_libs', true)
+
+features.set('static', get_option('default_library') != 'shared')
+features.set('shared', get_option('default_library') != 'static')
+features.set('optimizations', true)
+features.set('dependency_tracking', true)
+features.set('spatial_resampling', true)
+features.set('multithread', true)
+features.set('os_support', true)
+features.set('temporal_denoising', true)
+
+CODECS = [
+	'vp8_encoder',
+	'vp8_decoder',
+	'vp9_encoder',
+	'vp9_decoder',
+]
+
+CODEC_FAMILIES = [
+	'vp8',
+	'vp9',
+]
+
+ARCH_LIST = [
+	'arm',
+	'mips',
+	'x86',
+	'x86_64',
+	'ppc',
+	'loongarch',
+]
+
+ARCH_EXT_LIST_X86 = [
+	'mmx',
+	'sse',
+	'sse2',
+	'sse3',
+	'ssse3',
+	'sse4_1',
+	'avx',
+	'avx2',
+	'avx512',
+]
+
+ARCH_EXT_LIST_LOONGSON = [
+	'mmi',
+	'lsx',
+	'lasx',
+]
+
+ARCH_EXT_LIST = [
+	'neon',
+	'neon_asm',
+
+	'mips32',
+	'dspr2',
+	'msa',
+	'mips64',
+] + ARCH_EXT_LIST_X86 + [
+	'vsx',
+] + ARCH_EXT_LIST_LOONGSON
+
+HAVE_LIST = ARCH_EXT_LIST + [
+	'vpx_ports',
+	'pthread_h',
+	'unistd_h',
+]
+
+EXPERIMENT_LIST = [
+	'fp_mb_stats',
+	'emulate_hardware',
+	'non_greedy_mv',
+	'rate_ctrl',
+	'collect_component_timing',
+]
+
+CONFIG_LIST = [
+	'dependency_tracking',
+	'external_build',
+	'install_docs',
+	'install_bins',
+	'install_libs',
+	'install_srcs',
+	'debug',
+	'gprof',
+	'gcov',
+	'rvct',
+	'gcc',
+	'msvs',
+	'pic',
+	'big_endian',
+
+	'codec_srcs',
+	'debug_libs',
+
+	'dequant_tokens',
+	'dc_recon',
+	'runtime_cpu_detect',
+	'postproc',
+	'vp9_postproc',
+	'multithread',
+	'internal_stats',
+] + CODECS + CODEC_FAMILIES + [
+	'encoders',
+	'decoders',
+	'static_msvcrt',
+	'spatial_resampling',
+	'realtime_only',
+	'onthefly_bitpacking',
+	'error_concealment',
+	'shared',
+	'static',
+	'small',
+	'postproc_visualizer',
+	'os_support',
+	'unit_tests',
+	'webm_io',
+	'libyuv',
+	'decode_perf_tests',
+	'encode_perf_tests',
+	'multi_res_encoding',
+	'temporal_denoising',
+	'vp9_temporal_denoising',
+	'consistent_recode',
+	'coefficient_range_checking',
+	'vp9_highbitdepth',
+	'better_hw_compatibility',
+	'experimental',
+	'size_limit',
+	'always_adjust_bpm',
+	'bitstream_debug',
+	'mismatch_debug',
+] + EXPERIMENT_LIST
+
+# this is the list of toggleable options in meson_options.txt
+# EXCEPT for a couple that I've separated because they're
+# derived from the Meson configuration.
+CMDLINE_SELECT = [
+	'dependency_tracking',
+	'external_build',
+	'extra_warnings',
+	'werror',
+	'install_docs',
+	'install_bins',
+	'install_libs',
+	'install_srcs',
+	'debug',
+	'gprof',
+	'gcov',
+	'pic',
+	'optimizations',
+	'ccache',
+	'runtime_cpu_detect',
+	'thumb',
+
+	'libs',
+	'examples',
+	'tools',
+	'docs',
+	'libc',
+	'as',
+	'size_limit',
+	'codec_srcs',
+	'debug_libs',
+
+	'dequant_tokens',
+	'dc_recon',
+	'postproc',
+	'vp9_postproc',
+	'multithread',
+	'internal_stats',
+] + CODECS + CODEC_FAMILIES + [
+	'static_msvcrt',
+	'spatial_resampling',
+	'realtime_only',
+	'onthefly_bitpacking',
+	'error_concealment',
+	'shared',
+	'static',
+	'small',
+	'postproc_visualizer',
+	'unit_tests',
+	'webm_io',
+	'libyuv',
+	'decode_perf_tests',
+	'encode_perf_tests',
+	'multi_res_encoding',
+	'temporal_denoising',
+	'vp9_temporal_denoising',
+	'consistent_recode',
+	'coefficient_range_checking',
+	'better_hw_compatibility',
+	'vp9_highbitdepth',
+	'experimental',
+	'always_adjust_bpm',
+	'bitstream_debug',
+	'mismatch_debug',
+]
+
+# These options are either provided or handled by Meson
+#### --- GENERATED EXTERN OPTIONS --- ####
+IGNORE_MESON_BUILTINS = [
+	'help',
+	'log',
+	'target',
+	'extra_cflags',
+	'extra_cxxflags',
+	'extra_warnings',
+	'werror',
+	'optimizations',
+	'pic',
+	'ccache',
+	'debug',
+	'gcov',
+	'dependency_tracking',
+	'libc',
+	'as',
+	'shared',
+	'static',
+	'small',
+	'static_msvcrt',
+	'debug_libs',
+	'install_srcs',
+]
+
+MESON_OPTIONS = [
+	'gprof',
+	'thumb',
+	'install_docs',
+	'install_bins',
+	'install_libs',
+	'libs',
+	'examples',
+	'tools',
+	'docs',
+	'unit_tests',
+	'decode_perf_tests',
+	'encode_perf_tests',
+	'codec_srcs',
+	'vp9_highbitdepth',
+	'better_hw_compatibility',
+	'vp8',
+	'vp9',
+	'internal_stats',
+	'postproc',
+	'vp9_postproc',
+	'multithread',
+	'spatial_resampling',
+	'realtime_only',
+	'onthefly_bitpacking',
+	'error_concealment',
+	'coefficient_range_checking',
+	'runtime_cpu_detect',
+	'postproc_visualizer',
+	'multi_res_encoding',
+	'temporal_denoising',
+	'vp9_temporal_denoising',
+	'webm_io',
+	'libyuv',
+	'vp8_encoder',
+	'vp8_decoder',
+	'vp9_encoder',
+	'vp9_decoder',
+]
+#### --- END GENERATED EXTERN OPTIONS --- ####
+
+VAR_LIST = []
+
+# process #
+
+if not get_option('auto_features').auto()
+	error('''
+		libvpx relies on feature options to enable components conditionally.
+		If you need to disable features manually, please use:
+		- the individual toggles,
+		- the enable_features and disable_features string options, for conditional setting
+		- the force_enable_features and force_enable_features string options, for forcing a value irrespective of the architecture configuration.
+	''')
+endif
+
+## process_cmdline ##
+
+features.set('extra_warnings', not ['0', '1'].contains(get_option('warning_level')))
+features.set('werror', get_option('werror'))
+features.set('debug', ['debug', 'debugoptimized'].contains(get_option('buildtype')))
+features.set('gcov', get_option('b_coverage'))
+features.set('static_msvcrt', ['static_from_buildtype', 'mt'].contains(get_option('b_vscrt')))
+features.set('debug_libs', features.get('debug', false))
+
+tune_cpu = ''
+
+foreach flag: CMDLINE_SELECT
+	if IGNORE_MESON_BUILTINS.contains(flag)
+		continue
+	elif MESON_OPTIONS.contains(flag)
+		value = get_option(flag)
+		if not value.auto()
+			features.set(flag, value.enabled())
+		endif
+	elif flag == 'size_limit'
+		size_limit_value = get_option('size_limit')
+		if size_limit_value == ''
+			continue
+		endif
+
+		size_limit_value = size_limit_value.split('x')
+
+		if size_limit_value.length() != 2
+			error('Invalid size-limit: must be of the form WIDTHxHEIGHT')
+		endif
+
+		w = size_limit_value[0].to_int()
+		h = size_limit_value[1].to_int()
+		if w <= 0 or h <= 0
+			error('Invalid size-limit: too small.')
+		elif w >= 65536 or h >= 65536
+			error('Invalid size-limit: too big.')
+		else
+			var_list += ['DECODE_WIDTH_LIMIT', 'DECODE_HEIGHT_LIMIT']
+			features.set('DECODE_WIDTH_LIMIT', w)
+			features.set('DECODE_HEIGHT_LIMIT', h)
+			features.set('size_limit', true)
+		endif
+	elif flag == 'cpu'
+		tune_cpu = get_option(flag)
+	else
+		continue
+	endif
+endforeach
+
+enable_features = get_option('enable_features')
+disable_features = get_option('disable_features')
+force_disable_features = get_option('force_disable_features')
+force_enable_features = get_option('force_enable_features')
+
+if enable_features.contains('help') or disable_features.contains('help') or force_disable_features.contains('help') or force_enable_features.contains('help')
+	error('''
+		These are the list of available features:
+		Experiments: @0@
+		Codecs:
+		Codec families:
+		Architectures:
+		Toggles:
+	'''.format(EXPERIMENT_LIST, CODECS, CODEC_FAMILIES, ARCH_EXT_LIST, CMDLINE_SELECT))
+endif
+
+foreach feature: enable_features
+	if EXPERIMENT_LIST.contains(feature)
+		if features.get('experimental', false)
+			features.set(feature, true)
+		else
+			warning('Ignoring @0@ -- not in experimental mode.'.format(feature))
+		endif
+	elif CODECS.contains(feature) or CODEC_FAMILIES.contains(feature)
+		message('\tenabling @0@'.format(feature))
+		features.set(feature, true)
+		if CODECS.contains(feature)
+			features.set('@0@_encoder'.format(feature), true)
+			features.set('@0@_decoder'.format(feature), true)
+		endif
+	elif ARCH_EXT_LIST.contains(feature)
+		continue
+	elif not features.get(feature, false) # action == 'enable and not enabled
+		if not CMDLINE_SELECT.contains(feature)
+			error('Unknown option @0@'.format(feature))
+		endif
+		message('\tenabling @0@'.format(feature))
+	endif
+	features.set(feature, true)
+endforeach
+foreach feature: disable_features
+	if EXPERIMENT_LIST.contains(feature)
+		if features.get('experimental', false)
+			features.set(feature, false)
+		else
+			warning('Ignoring @0@ -- not in experimental mode.'.format(feature))
+		endif
+	elif CODECS.contains(feature) or CODEC_FAMILIES.contains(feature)
+		message('\tdisabling @0@'.format(feature))
+		features.set(feature, true)
+		if CODECS.contains(feature)
+			features.set('@0@_encoder'.format(feature), false)
+			features.set('@0@_decoder'.format(feature), false)
+		endif
+	elif ARCH_EXT_LIST.contains(feature)
+		rtcd_options += ['--disable-@0@'.format(feature)]
+	elif features.get(feature, true) # action == disable and not disabled
+		if not CMDLINE_SELECT.contains(feature)
+			error('Unknown option @0@'.format(feature))
+		endif
+		message('\tdisabling @0@'.format(feature))
+	endif
+	features.set(feature, false)
+endforeach
+
+foreach feature: force_disable_features
+	features.set(feature, false)
+endforeach
+foreach feature: force_enable_features
+	features.set(feature, true)
+endforeach
+
+## post_process_common_cmdline ##
+
+## post_process_cmdline ##
+
+if features.get('coefficient_range_checking', false)
+	warn('coefficient-range-checking is for decoders only, disabling encoders')
+	encoders_features = ['vp8_encoder', 'vp9_encoder']
+	foreach feature: encoders_features # soft_disable
+		if not features.get(feature, false) # ! enabled
+			if not features.has(feature) # disabled
+				message('\tdisabling @0@'.format(feature))
+			endif
+			features.set(feature, false)
+		endif
+	endforeach
+endif
+
+# Enable all detected codecs, if they haven't been disabled
+foreach feature: CODECS
+	if features.get(feature, true) # soft_enabled
+		if not features.has(feature)
+			message('\tenabling @0@'.format(feature))
+		endif
+		features.set(feature, true)
+	endif
+endforeach
+
+# Enable the codec family if any component of that family is enabled
+foreach feature: CODECS
+	if features.get(feature, true)
+		features.set(feature.split('_')[0], true)
+	endif
+endforeach
+
+# Set the {en,de}coders variable if any algorithm in that class is enabled
+# Grep help: CONFIG_DECODERS, decoders, encoders
+foreach feature: CODECS
+	if features.get(feature, true)
+		features.set('@0@s'.format(feature.split('_')[1]), true)
+	endif
+endforeach
+
+### process_toolchain ###
+#### process_common_toolchain ####
+
+c = meson.get_compiler('c')
+cpp = meson.get_compiler('cpp')
+asm = meson.get_compiler('c') # asm == GCC
+
+tgt_isa = target_machine.cpu_family()
+tgt_os = target_machine.system()
+tgt_cc = c.get_id()
+
+if tgt_isa == 'arm'
+	# The __SOFTFP__ macro is unreliable, clang defines it
+	# as __SOFT_FP__. The other one matches the configure script better.
+	if c.get_define('__ARM_PCS_VFP') != ''
+		float_abi = 'hard'
+	else
+		float_abi = 'softfp'
+	endif
+endif
+
+if tgt_os == 'windows' or tgt_os == 'cygwin'
+	tgt_os = 'windows'
+elif ['darwin', 'ios', 'tvos'].contains(tgt_os)
+	# The gcc -dumpmachine bit is used to force -mmacosx-version-min/max
+	warning('Apple target detected, please supply the --m(macos|ios)-version-* and -isysroot flags through -Dc_flags or a native file')
+
+	if tgt_os == 'darwin'
+		# Detect if iOS, tvOS...
+		xcrun_exe = find_program('xcrun', required: true)
+
+		# The only one actually used is the iPhone simulator-- see later
+		# is_ios = c.get_define('TARGET_OS_MAC', prefix: '#include <TargetConditionals.h>')
+		# is_tvos = c.get_define('TARGET_OS_TV', prefix: '#include <TargetConditionals.h>')
+		is_simulator = c.get_define('TARGET_OS_SIMULATOR', prefix: '#include <TargetConditionals.h>')
+
+		# if is_ios.to_int() == 1
+		# 	tgt_os = 'ios'
+		# elif is_tvos.to_int() == 1
+		# 	tgt_os = 'tvos'
+		# el
+		if is_simulator.to_int() == 1
+			tgt_os = 'iphonesimulator'
+		endif
+	endif
+elif tgt_os == 'linux' or tgt_os.endswith('bsd')
+	tgt_os = 'linux'
+elif tgt_os == 'sunos'
+	tgt_os = 'solaris'
+endif
+
+#
+# Set up toolchain variables
+#
+
+# Mark the specific ISA requested as enabled
+if tgt_isa == 'aarch64'
+	tgt_isa = 'arm64'
+elif tgt_isa == 'arm'
+	arm_arch = c.get_define('__ARM_ARCH')
+	if arm_arch == ''
+		arm_arch = c.get_define('_M_ARM')
+	endif
+	if arm_arch == ''
+		warning('Unknown 32-bit Arm architecture version, assuming v7-a')
+		arm_arch = '7'
+	endif
+	tgt_isa = 'armv@0@'.format(arm_arch)
+elif tgt_isa.startswith('sparc')
+	tgt_isa = 'sparc'
+elif tgt_isa == 'ppc64' and target_machine.endian() == 'little'
+	tgt_isa = 'ppc64le'
+elif tgt_isa == 'mips'
+	tgt_isa = 'mips32'
+elif not tgt_isa.startswith('x86')
+	tgt_isa = 'generic'
+endif
+if features.get(tgt_isa, true) # soft_enabled
+	if not features.has(tgt_isa)
+		message('\tenabling @0@'.format(tgt_isa))
+	endif
+	features.set(tgt_isa, true)
+endif
+if c.get_argument_syntax() == 'msvc'
+	tgt_cc = 'msvs' # Upstream uses "vs@0@".format(vs_major_version_number)
+elif c.get_id() == 'icc'
+	tgt_cc = 'icc'
+elif ['gcc', 'clang'].contains(c.get_id())
+	tgt_cc = 'gcc'
+else
+	tgt_cc = 'gnu'
+endif
+features.set(tgt_cc, true)
+
+# Enable the architecture family
+if tgt_isa.startswith('arm')
+	features.set('arm', true)
+elif tgt_isa.startswith('mips')
+	features.set('mips', true)
+elif tgt_isa.startswith('ppc')
+	features.set('ppc', true)
+elif tgt_isa == 'loongarch64'
+	features.set('loongarch', true)
+	loongson_features = ['lsx', 'lasx']
+	foreach feature : loongson_features
+		if features.get(feature, true)
+			if not feature.has(feature)
+				message('\tenabling @0@'.format(feature))
+			endif
+			features.set(feature, true)
+		endif
+	endforeach
+endif
+
+# Handle Solaris variants. Solaris 10 needs -lposix4
+if tgt_os == 'solaris'
+	extra_libs += c.find_library('posix4', required: true)
+endif
+
+if tgt_isa.startswith('arm')
+	feature = 'neon'
+	if features.get(feature, true)
+		if not features.has(feature)
+			message('\tenabling @0@'.format(feature))
+		endif
+		features.set(feature, true)
+	endif
+
+	if tgt_isa == 'armv7'
+		# Only enable neon_asm when neon is also enabled.
+		if features.get('neon', false)
+			feature = 'neon_asm'
+			if features.get(feature, true)
+				if not features.has(feature)
+					message('\tenabling @0@'.format(feature))
+				endif
+				features.set(feature, true)
+			endif
+		endif
+		# If someone tries to force it through, die.
+		if not features.get('neon', true) and features.get('neon_asm', false)
+			error('Disabling neon while keeping neon-asm is not supported')
+		endif
+	endif
+
+	if tgt_cc == 'gcc'
+		tune_cflags = '-mtune=@0@'
+
+		if tgt_isa == 'armv7'
+			if features.get('neon', false) or features.get('neon_asm', false)
+				gcc_flags = ['-mfpu=neon']
+				add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c') #-ftree-vectorize
+				add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+			endif
+		endif
+
+		asm_conversion_exe = find_program('build/make/ads2gas.pl', required: true)
+		asm_conversion_cmd = []
+		as_sfx = '.S'
+
+		if tgt_os == 'windows'
+			asm_conversion_cmd += ['-noelf']
+			features.set('thumb', true)
+		endif
+
+		if features.get('thumb', false)
+			asm_conversion_cmd += ['-thumb']
+			gcc_flags = ['-mthumb', '-Wa,-mimplicit-it=always']
+			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c') #-ftree-vectorize
+			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+		endif
+	elif tgt_cc == 'msvs'
+		# A number of ARM-based Windows platforms are constrained by their
+		# respective SDKs' limitations. Fortunately, these are all 32-bit ABIs
+		# and so can be selected as 'win32'.
+
+		if tgt_isa == 'armv7'
+			asm_conversion_exe = find_program('build/make/ads2armasm_ms.pl', required: true)
+			asm_conversion_cmd = []
+			as_sfx = '.masm'
+			features.set('multithread', false)
+			features.set('unit_tests', false)
+			# We drive MSVC through Ninja here, so don't disable examples nor tools.
+		else
+			# Windows 10 on ARM, on the other hand, has full Windows SDK support
+			# for building Win32 ARM64 applications in addition to ARM64
+			# Windows Store apps. It is the only 64-bit ARM ABI that
+			# Windows supports, so it is the default definition of 'win64'.
+			# ARM64 build support officially shipped in Visual Studio 15.9.0.
+
+			# Because the ARM64 Windows SDK's arm_neon.h is ARM32-specific
+			# while LLVM's is not, probe its validity.
+			if features.get('neon', false)
+				if not c.compiles('''
+						#include <arm_neon.h>
+						int z;
+					''',
+					name: 'has a valid arm_neon.h file for the architecture'
+				)
+					features.set('win_arm64_neon_h_workaround', c.has_header('arm64_neon.h'))
+				endif
+			endif
+		endif
+	endif
+
+	if tgt_os == 'android'
+		message('Assuming standalone build with NDK toolchain.')
+		# See later for why we allow shared builds.
+		# features.set('static', true)
+		feature = 'unit_tests'
+		if features.get(feature, true)
+			if not feature.has(feature)
+				message('\tenabling @0@'.format(feature))
+			endif
+			features.set(feature, true)
+		endif
+	elif tgt_os == 'darwin'
+		if tgt_isa.startswith('arm')
+			as_sfx = '.S'
+			xcodebuild = find_program('xcodebuild', required: false)
+			if xcodebuild.found()
+				xcode_version = run_command(xcodebuild, '-version',
+					capture: true,
+					check: true
+				).stdout().strip().split('\n').get(0, '').split()
+
+				if features.get('neon', false) and xcode_version.get(1, '').version_compare('>=6.3')
+					feature = 'neon'
+					if not features.get(feature, false)
+						if not features.has(feature)
+							message('\tdisabling @0@'.format(feature))
+						endif
+						features.set(feature, false)
+					endif
+					warning('\tneon disabled: upgrade Xcode (need v6.3+)')
+					if features.get('neon_asm', false)
+						feature = 'neon_asm'
+						if not features.get(feature, false)
+							if not features.has(feature)
+								message('\tdisabling @0@'.format(feature))
+							endif
+							features.set(feature, false)
+						endif
+						warning('\tneon disabled: upgrade Xcode (need v6.3+)')
+					endif
+				endif
+			endif
+		endif
+
+		# Darwin toolchain and embed-bitcode options are Meson handled.
+		asm_conversion_exe = find_program('build/make/ads2gas_apple.pl', required: true)
+		asm_conversion_cmd = []
+	elif tgt_os == 'linux'
+		features.set('linux', true)
+	endif
+elif tgt_isa.startswith('mips')
+	tune_cflags = '-mtune=@0@'
+
+	if features.get('dspr2', false)
+		add_project_arguments(c.get_supported_arguments('-mips2r32', '-mdspr2'), language: 'cpp')
+		add_project_arguments(cpp.get_supported_arguments('-mips2r32', '-mdspr2'), language: 'cpp')
+	endif
+
+	if features.get('runtime_cpu_detect', false)
+		features.set('runtime_cpu_detect', false)
+	endif
+
+	if tune_cpu != ''
+		if tune_cpu == 'p5600'
+			gcc_flags = ['-mips32r5', '-mload-store-pairs', '-msched-weight', '-mhard-float', '-mfp64']
+			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
+			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+		elif ['i6400', 'p6600'].contains(tune_cpu)
+			gcc_flags = ['-mips64r6', '-mabi=64', '-msched-weight', '-mload-store-pairs', '-mhard-float', '-mfp64']
+			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
+			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+			add_project_link_arguments(c.get_supported_link_arguments(gcc_flags), language: 'c')
+			add_project_link_arguments(cpp.get_supported_link_arguments(gcc_flags), language: 'cpp')
+		elif tune_cpu.startswith('loongson3')
+			if c.has_argument('-march=loongson3a')
+				feature = 'mmi'
+				if features.get(feature, true)
+					if not feature.has(feature)
+						message('\tenabling @0@'.format(feature))
+					endif
+					features.set(feature, true)
+				endif
+			else
+				features.set('mmi', false)
+			endif
+
+			if c.has_argument('-mmsa')
+				feature = 'msa'
+				if features.get(feature, true)
+					if not feature.has(feature)
+						message('\tenabling @0@'.format(feature))
+					endif
+					features.set(feature, true)
+				endif
+			else
+				features.set('msa', false)
+			endif
+
+			tgt_isa = 'loongson3a'
+		endif
+
+		if features.get('mmi', false) or features.get('msa', false)
+			feature = 'runtime_cpu_detect'
+			if features.get(feature, true)
+				if not feature.has(feature)
+					message('\tenabling @0@'.format(feature))
+				endif
+				features.set(feature, true)
+			endif
+		endif
+
+		if features.get('msa', false)
+			# TODO(libyuv:793)
+			# The new mips functions in libyuv do not build
+			# with the toolchains we currently use for testing.
+			feature = 'libyuv'
+			if not features.get(feature, false) # ! enabled
+				if not features.has(feature) # disabled
+					message('\tdisabling @0@'.format(feature))
+				endif
+				features.set(feature, false)
+			endif
+		endif
+	endif
+
+	add_project_arguments(c.get_supported_arguments('-march=@0@'.format(tgt_isa)), language: 'c')
+	# KPIC is a flag that is valid only for SunCC.
+	# As such, we'll use the Meson derived version.
+elif tgt_isa == 'ppc64' and target_machine.endian() == 'little'
+	# Do not enable vsx by default.
+	# https://bugs.chromium.org/p/webm/issues/detail?id=1522
+	if not features.get('vsx', false)
+		rtcd_options += ['--disable-vsx']
+	endif
+
+	if tune_cpu.startswith('power')
+		tune_cflags = '-mcpu=@0@'
+	endif
+elif tgt_isa.startswith('x86')
+	if tgt_os == 'android'
+		feature = 'realtime_only'
+		if features.get(feature, true)
+			if not features.has(feature)
+				message('\tenabling @0@'.format(feature))
+			endif
+			features.set(feature, true)
+		endif
+	elif tgt_os == 'windows'
+		if features.get('gcc', false)
+			gcc_flags = ['-fno-common']
+			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
+			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+		endif
+	# Solaris is Meson handled, and OS/2 is unsupported by Meson.
+	endif
+
+	as = 'auto'
+
+	if tgt_cc == 'icc'
+		gcc_flags = ['-use-msasm']
+		add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
+		add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+		# add -no-intel-extensions to suppress warning #10237
+		# refer to http://software.intel.com/en-us/forums/topic/280199
+		# Meson: -i-static is deprecated
+		# See https://www.cita.utoronto.ca/~merz/intel_c10b/main_cls/mergedProjects/copts_cls/common_options/option_i_static.htm
+		gcc_flags = ['-static-intel', '-no-intel-extensions']
+		add_project_link_arguments(c.get_supported_link_arguments(gcc_flags), language: 'c')
+		add_project_link_arguments(cpp.get_supported_link_arguments(gcc_flags), language: 'cpp')
+
+		if tgt_isa == 'x86_64'
+			# -ipo is LTO, -static and -O3 all are Meson handled
+			gcc_flags = ['-no-prec-div']
+			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
+			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+			# xiar is also Meson handled
+			if tune_cpu.startswith('atom')
+				tune_cflags = '-x'
+				tune_cpu = 'SSE3_ATOM'
+			else
+				tune_cflags = '-march=@0@'
+			endif
+		endif
+	elif tgt_cc == 'gcc'
+		tune_cflags = '-march='
+		# #for 32 bit x86 builds, -O3 did not turn on this flag
+		if features.get('optimizations', false) and not features.get('gprof', true)
+			gcc_flags = ['-fomit-frame-pointer']
+			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
+			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+		endif
+	elif tgt_cc == 'msvs'
+		# Based on the Gerrit review, it seems the author intended to ban
+		# VS 2017 and earlier.
+		# See https://chromium-review.googlesource.com/c/webm/libvpx/+/751863
+		if c.version().version_compare('< 19.20.27508')
+			warning('This version of Visual Studio does not support avx512, disabling.....')
+			rtcd_options += ['--disable-avx512']
+			feature = 'avx512'
+			if not features.get(feature, false) # ! enabled
+				if not features.has(feature) # disabled
+					message('\tdisabling @0@'.format(feature))
+				endif
+				features.set(feature, false)
+			endif
+		endif
+	endif
+
+	x86_bits = 32
+	if target_machine.cpu_family() == 'x86_64'
+		x86_bits = 64
+	endif
+
+	feature = 'runtime_cpu_detect'
+	if features.get(tgt_isa, true) # soft_enabled
+		if not features.has(tgt_isa)
+			message('\tenabling @0@'.format(tgt_isa))
+		endif
+		features.set(tgt_isa, true)
+	endif
+
+	# Unline the original, we do can test cflags here :)
+	disable_exts = false
+	foreach ext : ARCH_EXT_LIST_X86
+		# disable higher order extensions to simplify asm dependencies
+		if disable_exts
+			if features.get(ext, true)
+				rtcd_options += ['--disable-@0@'.format(ext)]
+				message('\tdisabling @0@'.format(ext))
+				features.set(ext, false)
+			endif
+		elif not features.get(ext, true)
+			disable_exts = true
+		else
+			if ext == 'avx512'
+				exts = ['avx512f', 'avx512cd', 'avx512bw', 'avx512dq', 'avx512vl']
+				foreach feature : exts
+					if features.get('gcc', false) and features.get(ext, true) and not c.has_argument('-m@0@'.format(feature))
+						rtcd_options += ['--disable-@0@'.format(ext)]
+					else
+						if features.get(ext, true) # soft_enabled
+							if not features.has(ext)
+								message('\tenabling @0@'.format(ext))
+							endif
+							features.set(ext, true)
+						endif
+					endif
+				endforeach
+				if features.get('gcc', true) and not c.compiles('''
+					#include <immintrin.h>
+					void f(void) {
+						__m512i x = _mm512_set1_epi16(0);
+						(void)x;
+					}
+					''',
+					name: 'supports AVX512',
+					args: '-mavx512f'
+				)
+					warning('disabling avx512: not supported by compiler')
+					features.set('avx512', false)
+					rtcd_options += ['--disable-avx512']
+				endif
+			else
+				# use the shortened version for the flag: sse4_1 -> sse4
+				exts = []
+				if ext.contains('_')
+					exts += [ext.split('_')[0]]
+				else
+					exts += [ext]
+				endif
+				opt = ext
+				foreach feature : exts
+					if features.get('gcc', false) and features.get(opt, true) and not c.has_argument('-m@0@'.format(feature))
+						rtcd_options += ['--disable-@0@'.format(feature)]
+					else
+						if features.get(opt, true) # soft_enabled
+							if not features.has(opt)
+								message('\tenabling @0@'.format(opt))
+							endif
+							features.set(opt, true)
+						endif
+					endif
+				endforeach
+			endif
+		endif
+	endforeach
+
+	nasm_exe = find_program('nasm', required: false)
+	if meson.version().version_compare('> 1.1.0')
+		yasm_exe = find_program('yasm', required: false)
+	else
+		# Removing Yasm support because Meson adds optimization flags
+		# which it doesn't support.
+		# https://github.com/mesonbuild/meson/issues/11726
+		yasm_exe = disabler()
+	endif
+	# Adding Meson overrides manually.
+	if not nasm_exe.found() and not yasm_exe.found()
+		if host_machine.system() == 'windows'
+			nasm_exe = find_program('nasm_windows_exe')
+		elif host_machine.system() == 'darwin'
+			nasm_exe = find_program('nasm_macos_exe')
+		endif
+	endif
+	if nasm_exe.found()
+		# Apple ships version 0.98 of nasm through at least Xcode 6. Revisit
+		# this check if they start shipping a compatible version.
+		out = run_command(nasm_exe, '-v', capture: true, check: true).stdout().strip()
+		as = 'nasm'
+		if out.contains('Apple')
+			warning('Unsupported version of nasm: @0@'.format(out))
+			as = 'auto'
+		elif ['linux', 'solaris'].contains(tgt_os)
+			out = out.split()
+			if out[1].to_lower() == 'version'
+				if out[2].version_compare('<2.09')
+					error('nasm @0@ does not support section alignment'.format(out[2]))
+				endif
+			else
+				error('unexpected nasm version string: @0@'.format(out))
+			endif
+		endif
+	elif yasm_exe.found()
+		as = 'yasm'
+	endif
+
+	if as == 'auto'
+		error('Neither yasm nor nasm have been found. See the prerequisites section in the README for more info.')
+	else
+		add_languages('nasm', required: true)
+	endif
+
+	as_sfx = '.asm'
+
+	# Nasm flags are Meson handled.
+	if tgt_os == 'iphonesimulator'
+		sdk_version = run_command(xcrun_exe, '--sdk', tgt_os, '--show-sdk-version', check: true, capture: true)
+		if sdk_version.version_compare('> 8.0')
+			# yasm v1.3.0 doesn't know what -fembed-bitcode means, so turning it
+			# on is pointless (unless building a C-only lib). Warn the user, but
+			# do nothing here.
+			warning('Bitcode embed disabled for simulator targets.')
+		endif
+	endif
+elif tgt_isa.startswith('loongarch')
+	inline_asm = 'void foo(void) { __asm__ volatile(@0@); }'
+	if features.get('lsx', false)
+		features.set('lsx', c.compiles(inline_asm.format('"vadd.b $vr0, $vr1, $vr1"', name: 'inline asm for Loongson lsx')))
+	endif
+	if features.get('lsx', false)
+		feature = 'runtime_cpu_detect'
+		if features.get(feature, true) # soft_enabled
+			if not features.has(feature)
+				message('\tenabling @0@'.format(feature))
+			endif
+			features.set(feature, true)
+		endif
+	endif
+	if features.get('lasx', false)
+		features.set('lasx', c.compiles(inline_asm.format('"xvadd.b $xr0, $xr1, $xr1"', name: 'inline asm for Loongson lasx')))
+	endif
+	if features.get('lasx', false)
+		feature = 'runtime_cpu_detect'
+		if features.get(feature, true) # soft_enabled
+			if not features.has(feature)
+				message('\tenabling @0@'.format(feature))
+			endif
+			features.set(feature, true)
+		endif
+	endif
+elif ['gnu', 'gcc'].contains(tgt_cc)
+	features.set('gcc', true)
+endif
+
+# Try to enable CPU specific tuning
+if tune_cpu != ''
+	if tune_cflags != ''
+		add_project_arguments(
+			c.get_supported_arguments(tune_cflags.format(tune_cpu), checked: 'require'),
+			language: 'c'
+		)
+	else
+		warning('CPU tuning not supported by this toolchain')
+	endif
+endif
+
+# gcov is Meson handled
+
+if features.get('gprof', false)
+	gcc_flags = ['-pg']
+
+	add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
+	add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+endif
+
+# optimizations are Meson handled
+
+# pic is Meson handled
+
+# dropping the longjmp interception check because it's been shipped for
+# well over a decade now.
+
+# gnu_strip is meson handled via Dstrip
+
+# Try to determine target endianness
+features.set('big_endian', target_machine.endian() == 'big')
+if c.compiles('static inline int function(void) {}', name: 'supports inline keyword')
+	features.set('INLINE', 'inline')
+endif
+
+# Almost every platform uses pthreads.
+if features.get('multithread', false)
+	threads_dep = c.find_library('threads', required: false)
+	if c.compiles('''
+		#include <pthread.h>
+		#include <stddef.h>
+		int main(void) { return pthread_create(NULL, NULL, NULL, NULL); }''',
+		name: 'supports pthreads',
+		dependencies: threads_dep
+	)
+		extra_libs += threads_dep
+	else
+		features.set('pthread_h', false)
+	endif
+endif
+
+# only for MIPS platforms
+if tgt_isa.startswith('mips')
+	if features.get('big_endian', false)
+		if features.get('dspr2', false)
+			warning('dspr2 optimizations are available only for little endian platforms')
+			features.set('dspr2', false)
+		endif
+		if features.get('msa', false)
+			warning('msa optimizations are available only for little endian platforms')
+			features.get('msa', false)
+		endif
+		if features.get('mmi', false)
+			warning('mmi optimizations are available only for little endian platforms')
+			features.get('mmi', false)
+		endif
+	endif
+endif
+
+# only for LOONGARCH platforms
+if tgt_isa.startswith('loongarch')
+	if features.get('big_endian', false)
+		if features.get('lsx', false)
+			warning('lsx optimizations are available only for little endian platforms')
+			features.set('lsx', false)
+		endif
+		if features.get('lasx', false)
+			warning('lasx optimizations are available only for little endian platforms')
+			features.get('lasx', false)
+		endif
+	endif
+endif
+
+# glibc needs these
+if features.get('linux', false)
+	add_project_arguments(
+		'-D_LARGEFILE_SOURCE', '-D_FILE_OFFSET_BITS=64',
+		language: ['c', 'cpp']
+	)
+elif tgt_os == 'android'
+	api_level = c.get_define('__ANDROID_API__')
+	if api_level.version_compare('< 24') and tgt_isa == 'armv7'
+		warning('Disabling transparent large-file-support for Android API < 24 on armv7-a')
+		add_project_arguments(
+			'-U_FILE_OFFSET_BITS',
+			language: ['c', 'cpp']
+		)
+	endif
+endif
+
+if features.get('gcc', false)
+	gcc_flags = [
+		'-Wdeclaration-after-statement',
+		'-Wdisabled-optimization',
+		'-Wextra-semi',
+		'-Wextra-semi-stmt',
+		'-Wfloat-conversion',
+		'-Wformat=2',
+		'-Wparentheses-equality',
+		'-Wpointer-arith',
+		'-Wtype-limits',
+		'-Wcast-qual',
+		'-Wvla',
+		'-Wimplicit-function-declaration',
+		'-Wmissing-declarations',
+		'-Wmissing-prototypes',
+		'-Wuninitialized',
+		'-Wunreachable-code-loop-increment',
+		'-Wunused',
+	]
+
+	add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
+	add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+
+	# gtest does not do well with
+	# these flags so add them explicitly to CFLAGS only.
+	add_project_arguments(c.get_supported_arguments('-Wundef'), language: 'c')
+	add_project_arguments(c.get_supported_arguments('-Wframe-larger-than=52000'), language: 'c')
+
+	if (features.get('mips', false) or features.get('INLINE', '') == '') and features.get('extra_warnings', false)
+		add_project_arguments(c.get_supported_arguments('-Wno-unused-function'), language: 'c')
+		add_project_arguments(cpp.get_supported_arguments('-Wno-unused-function'), language: 'cpp')
+	endif
+
+	# Avoid this warning for third_party C++ sources. Some reorganization
+	# would be needed to apply this only to test/*.cc.
+	add_project_arguments(c.get_supported_arguments('-Wshorten-64-to-32'), language: 'c')
+
+	# Quiet gcc 6 vs 7 abi warnings:
+	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=77728
+	if features.get('arm', false)
+		add_project_arguments(cpp.get_supported_arguments('-Wno-psabi'), language: 'cpp')
+	endif
+
+	# Enforce C++11 compatibility.
+	add_project_arguments(
+		cpp.get_supported_arguments(
+			'-Wc++14-extensions',
+			'-Wc++17-extensions',
+			'-Wc++20-extensions',
+		),
+		language: 'cpp'
+	)
+	# disable some warnings specific to libyuv.
+	libyuv_cpp_args += cpp.get_supported_arguments(
+		'-Wno-missing-declarations',
+		'-Wno-missing-prototypes',
+		'-Wno-pass-failed',
+		'-Wno-unused-parameter',
+	)
+endif
+
+if features.get('icc', false)
+	# Warning levels are governed globally by Meson.
+	icc_flags = [
+		'-Wpointer-arith',
+		# ICC has a number of floating point optimizations that we disable
+		# in favor of deterministic output WRT to other compilers
+		'-fp-model=precise',
+	]
+
+	add_project_arguments(c.get_supported_arguments(icc_flags), language: 'c')
+	add_project_arguments(cpp.get_supported_arguments(icc_flags), language: 'cpp')
+endif
+
+# Enable extra, harmless warnings. These might provide additional insight
+# to what the compiler is doing and why, but in general, but they shouldn't
+# be treated as fatal, even if we're treating warnings as errors.
+extra_warnings = [
+	'-Wdisabled-optimization',
+	'-Winline',
+	# RVCT is not yet supported by Meson.
+	# '--remarks',
+]
+
+if features.get('extra_warnings', false)
+	add_project_arguments(c.get_supported_arguments(extra_warnings), language: 'c')
+	if features.get('gcc', false) and features.get('werror', false)
+		foreach w: extra_warnings
+			add_project_arguments(c.get_supported_arguments('-Wno-error=@0@'.format(w)), language: 'c')
+		endforeach
+	endif
+endif
+
+if features.get('mips', false)
+	features.set('dequant_tokens', true)
+	features.set('dc_recon', true)
+endif
+
+if features.get('internal_stats', false)
+	features.set('vp9_postproc', true)
+endif
+
+# "Enable" the postbuild target if building for visual studio.
+# The only relevant bits for Meson is the __inline definition.
+if tgt_cc == 'msvs'
+	if get_option('backend').startswith('vs')
+		features.set('solution', true)
+	endif
+	features.set('INLINE', '__inline')
+	add_project_arguments(
+		'-D_CRT_SECURE_NO_WARNINGS', '-D_CRT_SECURE_NO_DEPRECATE',
+		language: ['c', 'cpp']
+	)
+endif
+
+# Other toolchain specific defaults
+if target_machine.cpu_family().startswith('x86')
+	feature = 'postproc'
+	if features.get(feature, true)
+		if not features.has(feature)
+			message('\tenabling @0@'.format(feature))
+		endif
+		features.set(feature, true)
+	endif
+endif
+
+if features.get('postproc_visualizer', false) and not features.get('postproc', false)
+	error('postproc_visualizer requires postproc to be enabled')
+endif
+
+# Enable unit tests by default if we have a working C++ compiler.
+if tgt_cc == 'msvs'
+	enable_features = ['unit_tests', 'webm_io', 'libyuv']
+	foreach feature: enable_features
+		if features.get(feature, true)
+			if not features.has(feature)
+				message('\tenabling @0@'.format(feature))
+			endif
+			features.set(feature, true)
+		endif
+	endforeach
+elif tgt_os == 'android'
+	enable_features = ['libyuv']
+	if cpp.has_argument('-std=gnu++11')
+		add_project_arguments('-std=gnu++11', language: 'cpp')
+		enable_features += ['webm_io']
+	endif
+	foreach feature: enable_features
+		if features.get(feature, true)
+			if not features.has(feature)
+				message('\tenabling @0@'.format(feature))
+			endif
+			features.set(feature, true)
+		endif
+	endforeach
+	# GTestLog must be modified to use Android logging utilities.
+elif tgt_os == 'darwin'
+	# Meson already handles the cpp_std flag.
+	# iOS/ARM builds do not work with gtest. This does not match
+	# x86 targets.
+elif target_machine.system() == 'iphonesimulator'
+	enable_features = ['libyuv']
+	if cpp.has_argument('-std=gnu++11')
+		add_project_arguments('-std=gnu++11', language: 'cpp')
+		enable_features += ['webm_io']
+	endif
+	foreach feature: enable_features
+		if features.get(feature, true)
+			if not features.has(feature)
+				message('\tenabling @0@'.format(feature))
+			endif
+			features.set(feature, true)
+		endif
+	endforeach
+elif target_machine.system() == 'windows'
+	# Some mingw toolchains don't have pthread available by default.
+	# Treat these more like visual studio where threading in gtest
+	# would be disabled for the same reason.
+	enable_features = []
+	if cpp.has_argument('-std=gnu++11')
+		add_project_arguments('-std=gnu++11', language: 'cpp')
+		enable_features += ['unit_tests', 'webm_io']
+	endif
+	if cpp.compiles('int z;')
+		enable_features += ['libyuv']
+	endif
+	foreach feature: enable_features
+		if features.get(feature, true)
+			if not features.has(feature)
+				message('\tenabling @0@'.format(feature))
+			endif
+			features.set(feature, true)
+		endif
+	endforeach
+else
+	enable_features = []
+	if cpp.has_argument('-std=gnu++11')
+		add_project_arguments('-std=gnu++11', language: 'cpp')
+		if features.get('pthread_h', false)
+			enable_features += ['unit_tests']
+		endif
+		enable_features += ['webm_io']
+	endif
+	if cpp.compiles('int z;')
+		enable_features += ['libyuv']
+	endif
+	foreach feature: enable_features
+		if features.get(feature, true)
+			if not features.has(feature)
+				message('\tenabling @0@'.format(feature))
+			endif
+			features.set(feature, true)
+		endif
+	endforeach
+endif
+
+### process_detect ###
+
+# Shared builds are supported everywhere thanks to
+# the Meson generation of the module definition files.
+# if features.get('shared', false) and not ['linux', 'solaris', 'darwin', 'iphonesimulator'].contains(tgt_os) and not features.get('gnu', false)
+# 	# Again, no OS/2 because Meson itself doens't support it
+# 	error('Shared library build is only supported on ELF and Darwin for now')
+# endif
+
+features.set('unistd_h', c.has_header('unistd.h'))
+if c.has_header('vpx/vpx_integer.h', include_directories: include_directories('.'))
+	features.set('vpx_vpx_integer_h', true)
+	features.set('vpx_ports', true)
+endif
+
+if features.get('neon', false)
+	c.has_header('arm_neon.h', required: true)
+endif
+
+### process_targets ###
+
+cfgdata = configuration_data()
+
+cfgdata.set('INLINE', features.get('INLINE', ''))
+
+foreach arch : ARCH_LIST
+	cfgdata.set10('VPX_ARCH_@0@'.format(arch.to_upper()), features.get(arch, false))
+endforeach
+
+foreach have : HAVE_LIST
+	cfgdata.set10('HAVE_@0@'.format(have.to_upper()), features.get(have, false))
+endforeach
+
+foreach feature : CONFIG_LIST
+	cfgdata.set10('CONFIG_@0@'.format(feature.to_upper()), features.get(feature, false))
+endforeach
+
+foreach var : VAR_LIST
+	cfgdata.set10(var.to_upper(), features.get(var, false))
+endforeach
+
+version_str = 'v@0@'.format(meson.project_version())
+bare_version = meson.project_version().split('.')
+
+git = find_program('git', required: false)
+if git.found()
+	git_tag = run_command('git', 'describe', '--match=v[0-9]*',
+		capture: true,
+		check: false,
+		env: {
+			'GIT_DIR': meson.current_source_dir() / '.git'
+		}
+	)
+	if git_tag.returncode() == 0
+		version_str = git_tag.stdout().strip()
+		bare_version = version_str.substring(1).split('.')
+	endif
+endif
+
+python_exe = find_program('python3', version: '>= 3.8', required: true)
+
+major_version = bare_version.get(0, 0)
+minor_version = bare_version.get(1, 0)
+patch_version = bare_version.get(2, '').split('-').get(0, 0)
+extra_version = run_command(
+	python_exe,
+	'-c',
+	'print(\'-\'.join(\'@0@\'.split(\'-\')[1:]))'.format(version_str),
+	capture: true,
+	check: true
+).stdout().strip()
+
+vpx_config_h = configure_file(
+	output: 'vpx_config.h',
+	configuration: cfgdata,
+)
+
+if features.get('win_arm64_neon_h_workaround', false)
+	vpx_neon_h = configure_file(
+		input: 'meson/arm_neon.h',
+		output: 'arm_neon.h',
+		copy: true
+	)
+endif
+
+version_cfgdata = configuration_data()
+
+#since they'll be used as integers below make sure they are or force to 0
+version_cfgdata.set('VERSION_MAJOR', major_version)
+version_cfgdata.set('VERSION_MINOR', minor_version)
+version_cfgdata.set('VERSION_PATCH', patch_version)
+version_cfgdata.set_quoted('VERSION_EXTRA', extra_version)
+version_cfgdata.set('VERSION_PACKED', '((VERSION_MAJOR<<16)|(VERSION_MINOR<<8)|(VERSION_PATCH))')
+version_cfgdata.set_quoted('VERSION_STRING_NOSP', version_str)
+version_cfgdata.set_quoted('VERSION_STRING', ' @0@'.format(version_str))
+
+vpx_version_h = configure_file(
+	output: 'vpx_version.h',
+	configuration: version_cfgdata
+)
+
+config_mk_generator = find_program('meson/transform_config.py', required: true)
+
+config_mk = configure_file(
+	command: [config_mk_generator, '@OUTPUT@', '@INPUT@'],
+	input: [vpx_config_h, vpx_version_h],
+	output: 'config.mk',
+)
+
+##
+## END APPLICATION SPECIFIC CONFIGURATION
+##
+
+if meson.version().version_compare('>= 1.1.0')
+	configure_args = meson.build_options().strip()
+else
+	extractor = find_program('meson/capture_build_options.py', required: true)
+	configure_args = run_command(extractor, check: true).stdout().strip()
+endif
+
+vpx_config_data = configuration_data()
+vpx_config_data.set_quoted('CONFIGURE_ARGS', configure_args)
+
+vpx_config_c = configure_file(
+	input: 'meson/vpx_config.c',
+	output: 'vpx_config.c',
+	configuration: vpx_config_data,
+)
+
+# libs.mk
+
+rtcd_exe = find_program('build/make/rtcd.pl', required: true)
+
+extra_libs += c.find_library('m', required: false)
+
+codec_srcs = [
+	vpx_config_c,
+]
+codec_doc_srcs = []
+codec_doc_sections = []
+codec_headers = []
+codec_exports = []
+codec_rtcds = {}
+
+# What no one told me, and is veery tucked into the Makefiles,
+# is that Google's relying on regexp'd per-file architecture flags.
+# Best we can do here is simulate them and make libraries that'll be
+# link_whole'd into the final binary.
+if tgt_cc == 'msvs'
+	arch_flags = {
+		'mmx': [],
+		'sse2': [],
+		'sse3': [],
+		'ssse3': [],
+		'sse4_1': [],
+		'avx': c.get_supported_arguments('-march:avx'),
+		'avx2': c.get_supported_arguments('-march:avx2'),
+		'avx512': c.get_supported_arguments('-march:avx512'),
+	}
+else
+	arch_flags = {
+		# x86[_64]
+		'mmx': ['-mmmx'],
+		'sse2': ['-msse2'],
+		'sse3': ['-msse3'],
+		'ssse3': ['-mssse3'],
+		'sse4_1': ['-msse4.1'],
+		'avx': ['-mavx'],
+		'avx2': ['-mavx2'],
+		'avx512': ['-mavx512f', '-mavx512cd', '-mavx512bw', '-mavx512dq', '-mavx512vl'],
+
+		# POWER
+		'vsx' : ['-maltivec', '-mvsx'],
+
+		# MIPS
+		'msa': ['-mmsa'],
+
+		# LOONGARCH
+		'lsx': ['-mlsx'],
+		'lasx': ['-mlasx'],
+	}
+endif
+
+codec_arch_prereqs = []
+codec_arch_srcs = {}
+codec_arch_headers = {}
+codec_arch_libs = []
+
+#
+# Rule to make assembler configuration file from C configuration file
+#
+config_asm_generator = find_program('meson/transform_config_asm.py', required: true)
+
+if asm_conversion_exe.found()
+	# Android expects conversion to output ".asm" to ".asm.S"
+	# See e.g. idct_neon.asm
+	stdinout_wrapper_exe = find_program('meson/stdinout_wrapper.py', required: true)
+	asm_transformer = generator(
+		stdinout_wrapper_exe,
+		arguments: ['--input', '@INPUT@', '--output', '@OUTPUT@', asm_conversion_exe.full_path()] + asm_conversion_cmd,
+		output: '@0@@1@'.format('@BASENAME@', as_sfx)
+	)
+endif
+
+if features.get('x86', false) or features.get('x86_64', false)
+	config_asm = configure_file(
+		command: [config_asm_generator, '@INPUT@', '@OUTPUT@', '--format=yasm'],
+		input: vpx_config_h,
+		output: 'vpx_config.asm',
+	)
+elif asm_conversion_exe.found()
+	ads_config_asm = configure_file(
+		command: [config_asm_generator, '@INPUT@', '@OUTPUT@'],
+		input: vpx_config_h,
+		output: 'vpx_config.adstmp',
+	)
+	config_asm = configure_file(
+		command: [stdinout_wrapper_exe, '--input', '@INPUT@', '--output', '@OUTPUT@', asm_conversion_exe.full_path()] + asm_conversion_cmd,
+		input: ads_config_asm,
+		output: 'vpx_config.asm',
+	)
+else
+	config_asm = configure_file(
+		command: [config_asm_generator, '@INPUT@', '@OUTPUT@'],
+		input: vpx_config_h,
+		output: 'vpx_config.asm',
+	)
+endif
+
+rtcd_h_template = [rtcd_exe, '--arch=@0@'.format(tgt_isa), '--config=@INPUT0@'] + rtcd_options
+
+doxy_template = find_program('meson/generate_doxy.py', required: true)
+
+generate_component_dox = find_program('meson/generate_component_dox.py', required: true)
+
+#
+# Add assembler dependencies for configuration.
+#
+
+codec_srcs += vpx_version_h
+
+subdir('third_party')
+subdir('vpx')
+subdir('vpx_mem')
+subdir('vpx_scale')
+subdir('vpx_ports')
+subdir('vpx_dsp')
+subdir('vpx_util')
+subdir('vp8')
+subdir('vp9')
+
+foreach symbol, input_file : codec_rtcds
+	rtcd_filename = '@0@.h'.format(symbol)
+	rtcd_h = configure_file(
+		command: rtcd_h_template + ['--sym=@0@'.format(symbol), '@INPUT1@'],
+		input: [config_mk, input_file],
+		output: rtcd_filename,
+		capture: true,
+	)
+
+	codec_srcs += rtcd_h
+	codec_arch_prereqs += rtcd_h
+endforeach
+
+gen_def_exe = find_program('meson/gen_def.py', required: true)
+
+gen_def_cmd = [
+	gen_def_exe,
+	'--name=vpx',
+	'--out=@OUTPUT@'
+]
+
+if tgt_os != 'windows' and c.symbols_have_underscore_prefix()
+	gen_def_cmd += ['--underscore']
+endif
+
+if ['darwin', 'iphonesimulator'].contains(tgt_os)
+	vpx_def_name = 'libvpx.syms'
+	vpx_def = configure_file(
+		command: gen_def_cmd + ['--format=mac', '@INPUT@'],
+		input: codec_exports,
+		output: vpx_def_name,
+	)
+	link_args += ['-Wl,-exported_symbols_list,@0@'.format(meson.current_build_dir() / vpx_def_name)]
+elif tgt_os == 'windows'
+	vpx_def = configure_file(
+		command: gen_def_cmd + ['--format=win', '@INPUT@'],
+		input: codec_exports,
+		output: 'libvpx.def',
+	)
+else
+	vpx_def_name = 'libvpx.ver'
+	vpx_def = configure_file(
+		command: gen_def_cmd + ['--format=linux', '@INPUT@'],
+		input: codec_exports,
+		output: vpx_def_name,
+	)
+	link_args += ['-Wl,--version-script,@0@'.format(meson.current_build_dir() / vpx_def_name)]
+endif
+
+soversion = '8.0.0'
+
+foreach arch, srcs : codec_arch_srcs
+	codec_arch_libs += static_library(
+		'vpx-@0@'.format(arch),
+		codec_arch_prereqs + srcs,
+		extra_files: codec_arch_headers.get(comp_name, []),
+		c_args: arch_flags.get(arch, []),
+		dependencies: extra_libs,
+	)
+endforeach
+
+if features.get('static', false) and features.get('shared', false)
+	libvpx = both_libraries(
+		'vpx',
+		codec_srcs,
+		link_args: link_args,
+		extra_files: codec_headers,
+		dependencies: extra_libs,
+		link_whole: codec_arch_libs,
+		version: soversion,
+		vs_module_defs: vpx_def,
+		install: features.get('install_libs'),
+	)
+else
+	libvpx = library(
+		'vpx',
+		codec_srcs,
+		link_args: link_args,
+		extra_files: codec_headers,
+		dependencies: extra_libs,
+		link_whole: codec_arch_libs,
+		version: soversion,
+		vs_module_defs: vpx_def,
+		install: features.get('install_libs'),
+	)
+endif
+
+libvpx_dep = declare_dependency(
+	link_with: libvpx,
+	dependencies: extra_libs,
+	include_directories: include_directories('.'),
+)
+
+meson.override_dependency('libvpx', libvpx_dep)
+
+pkg = import('pkgconfig')
+
+pkg.generate(
+	libvpx,
+	description: 'WebM Project VPx codec implementation',
+	version: meson.project_version(),
+)
+
+if features.get('examples', false)
+	subdir('examples')
+endif
+
+if features.get('tools', false)
+	subdir('tools')
+endif
+
+if features.get('unit_tests', false)
+	if features.get('encoders', false)
+		rc_rtc_headers = files(
+			'vpx/vp8.h',
+			'vpx/vp8cx.h',
+			'vpx/vpx_ext_ratectrl.h',
+			'vpx/internal/vpx_ratectrl_rtc.h',
+		)
+
+		rc_rtc_srcs = []
+
+		if features.get('vp9_encoder', false)
+			rc_rtc_headers += files(
+				'vp9/ratectrl_rtc.h',
+			)
+			rc_rtc_srcs += files(
+				'vp9/ratectrl_rtc.cc',
+			)
+		endif
+		if features.get('vp8_encoder', false)
+			rc_rtc_headers += files(
+				'vp8/vp8_ratectrl_rtc.h',
+			)
+			rc_rtc_srcs += files(
+				'vp8/vp8_ratectrl_rtc.cc',
+			)
+		endif
+		vpxrc_lib = static_library(
+			'vpxrc',
+			rc_rtc_srcs,
+			extra_files: codec_headers + rc_rtc_headers,
+			dependencies: extra_libs + libvpx_dep,
+		)
+	endif
+
+	if features.get('vp9_encoder', false) and features.get('rate_ctrl', false)
+		simple_encode_lib = static_library(
+			'simple_encode',
+			codec_srcs + files(
+				'vp9/simple_encode.cc',
+				'ivfenc.c'
+			),
+			extra_files: codec_headers + files(
+				'vp9/simple_encode.h',
+				'ivfenc.h',
+			),
+			dependencies: extra_libs + libvpx_dep,
+		)
+	endif
+
+	curl_exe = find_program('curl', required: false, disabler: true)
+	check_test_data = find_program('meson/check_test_data.py', required: true)
+	vpxdec_sh = find_program('test/vpxdec.sh', required: false, disabler: true)
+	vpxenc_sh = find_program('test/vpxenc.sh', required: false, disabler: true)
+	examples_sh = find_program('test/examples.sh', required: false, disabler: true)
+
+	subdir('test')
+endif
+
+if features.get('install_docs', false)
+	libs_doxy = configure_file(
+		command: [doxy_template, '--sections', codec_doc_sections, '--include', meson.current_source_dir(), '--output', '@OUTPUT@', '@INPUT@'],
+		input: codec_doc_srcs,
+		output: 'libs.doxy',
+	)
+
+	codec_dox = files(
+		'mainpage.dox',
+		'keywords.dox',
+		'usage.dox',
+		'usage_cx.dox',
+		'usage_dx.dox',
+	)
+
+	example_path = [
+		meson.current_source_dir(), #for CHANGELOG, README, etc
+		meson.current_build_dir() / 'examples',
+	]
+
+	generate_doxyfile = find_program('meson/generate_doxyfile.py', required: true)
+
+	doxyfile_prelude = files(
+		'libs.doxy_template'
+	)
+
+	if features.get('examples', false)
+		doxyfile_prelude += examples_doxy
+	endif
+
+	if features.get('tools', false)
+		doxyfile_prelude += tools_doxy
+	endif
+
+	doxyfile_prelude += libs_doxy
+
+	doxyfile = configure_file(
+		command: [
+			generate_doxyfile,
+			'--prelude', doxyfile_prelude,
+			'--strip', meson.current_source_dir(), meson.current_build_dir(),
+			'--example-path', example_path,
+			'--output', '@OUTPUT@',
+			'@INPUT@'],
+		output: 'Doxyfile',
+		input: codec_dox
+	)
+
+	docs = custom_target(
+		'docs',
+		input: doxyfile,
+		output: 'html',
+		command: [doxygen, doxyfile],
+		console: true,
+		install: true,
+		install_dir: get_option('datadir') / meson.project_name(),
+	)
+endif
diff --git a/meson/arm_neon.h b/meson/arm_neon.h
new file mode 100644
index 000000000..1121204c1
--- /dev/null
+++ b/meson/arm_neon.h
@@ -0,0 +1,17 @@
+/* Copyright (c) 2011 The WebM project authors. All Rights Reserved. */
+/*  */
+/* Use of this source code is governed by a BSD-style license */
+/* that can be found in the LICENSE file in the root of the source */
+/* tree. An additional intellectual property rights grant can be found */
+/* in the file PATENTS.  All contributing project authors may */
+/* be found in the AUTHORS file in the root of the source tree. */
+/* This file automatically "generated" by Meson. Please check when updating! */
+#ifndef VPX_WIN_ARM_NEON_H_WORKAROUND
+#define VPX_WIN_ARM_NEON_H_WORKAROUND
+/* The Windows SDK has arm_neon.h, but unlike on other platforms it is
+ * ARM32-only. ARM64 NEON support is provided by arm64_neon.h, a proper
+ * superset of arm_neon.h. Work around this by providing a more local
+ * arm_neon.h that simply #includes arm64_neon.h.
+ */
+#include <arm64_neon.h>
+#endif /* VPX_WIN_ARM_NEON_H_WORKAROUND */
diff --git a/meson/capture_build_options.py b/meson/capture_build_options.py
new file mode 100644
index 000000000..4a40081a3
--- /dev/null
+++ b/meson/capture_build_options.py
@@ -0,0 +1,18 @@
+#!/usr/bin/env python3
+
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from __future__ import annotations
+import re
+import os
+
+if __name__ == '__main__':
+	with open(f'{os.environ["MESON_BUILD_ROOT"]}/meson-logs/meson-log.txt', encoding="utf-8", mode='r') as f:
+		lines = [line for line in f if 'Build Options' in line]
+
+		options = re.match(r'Build Options:\s+(.+)$', lines[-1])
+
+		if options is not None:
+			print(options.group(1))
+
diff --git a/meson/check_test_data.py b/meson/check_test_data.py
new file mode 100644
index 000000000..a0b212443
--- /dev/null
+++ b/meson/check_test_data.py
@@ -0,0 +1,45 @@
+#!/usr/bin/env python3
+
+# SPDX-FileNotice: This file is based on the FFmpeg Meson build version
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from __future__ import annotations
+from argparse import ArgumentParser, FileType
+from pathlib import Path
+import re
+from warnings import warn
+
+try:
+	from hashlib import file_digest
+except ImportError:
+	import hashlib
+	from io import BufferedReader
+	def file_digest(f: BufferedReader, algorithm: str):
+		return hashlib.new(algorithm, f.read())
+
+if __name__ == '__main__':
+	parser = ArgumentParser(description='Validate a list of files')
+	parser.add_argument('manifest', type=FileType('r', encoding='utf-8'), help='Path to the SHA-1 hash manifest')
+
+	args = parser.parse_args()
+
+	sha_map = {}
+
+	for line in args.manifest:
+		if option := re.match(r'([a-fA-F0-9]+)\s+\*?(.+)', line.strip()):
+			sha_map[option.group(1)] = option.group(2)
+
+	print('Checking test data:\n')
+	for file, hash in sha_map.items():
+		with Path(file) as f:
+			if not f.exists():
+				warn(f'{f} does not exist, skipping...')
+				continue
+			digest = file_digest(f.open('rb'), 'sha1').hexdigest()
+			if digest != hash:
+				raise ValueError(f'Hash mismatch for {f}: expected {hash}, got {hash}')
+			else:
+				print(f'{f}: OK\n')
+
+	print('Test data OK\n')
diff --git a/meson/gen_def.py b/meson/gen_def.py
new file mode 100755
index 000000000..cc834da0c
--- /dev/null
+++ b/meson/gen_def.py
@@ -0,0 +1,100 @@
+#!/usr/bin/env python3
+
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from __future__ import annotations
+from argparse import ArgumentParser, FileType, REMAINDER
+from io import TextIOWrapper
+import re
+from sys import stdout
+
+SYMBOL = r'^(text|data)\s+(.+)$'
+COMMENT = r'^#(.+)'
+
+# Unlike the stock generator script, this one does not accept 'name'
+# as that tells LINK.EXE to change the library export file name.
+def collate_windows_exports(files: list[TextIOWrapper], needs_underscore: bool) -> list[str]:
+	lines = ['EXPORTS']
+	underscore = '_' if needs_underscore else ''
+
+	for file in files:
+		for symbol in file.readlines():
+			symbol = symbol.strip()
+			option = re.match(SYMBOL, symbol)
+			if option:
+				suffix = '\tDATA' if option.group(1) == 'data' else ''
+				lines.append(f"\t{underscore}{option.group(2)}{suffix}")
+			elif re.match(COMMENT, symbol):
+				continue
+			else:
+				raise RuntimeError(f'Unknown line: {symbol}')
+
+	return lines
+
+def collate_linux_ver(files: list[TextIOWrapper], needs_underscore: bool) -> list[str]:
+	lines = ['{ global:']
+	underscore = '_' if needs_underscore else ''
+
+	for file in files:
+		for symbol in file.readlines():
+			symbol = symbol.strip()
+			option = re.match(SYMBOL, symbol)
+			if option:
+				lines.append(f"{underscore}{option.group(2)};")
+			elif re.match(COMMENT, symbol):
+				continue
+			else:
+				raise RuntimeError(f'Unknown line: {symbol}')
+
+	lines += ['local: *; };']
+
+	return lines
+
+def collate_macos_sym(files: list[TextIOWrapper], needs_underscore: bool) -> list[str]:
+	lines = []
+	underscore = '_' if needs_underscore else ''
+
+	for file in files:
+		for symbol in file.readlines():
+			symbol = symbol.strip()
+			option = re.match(SYMBOL, symbol)
+			if option:
+				lines.append(f"{underscore}{option.group(2)}")
+			elif re.match(COMMENT, symbol):
+				continue
+			else:
+				raise RuntimeError(f'Unknown line: {symbol}')
+
+	return lines
+
+def collate_exports(files: list[TextIOWrapper], format='win', needs_underscore=False) -> list[str]:
+	if format == 'mac':
+		return collate_macos_sym(files, needs_underscore)
+	elif format == 'linux':
+		return collate_linux_ver(files, needs_underscore)
+	else:
+		return collate_windows_exports(files, needs_underscore)
+
+if __name__ == '__main__':
+	parser = ArgumentParser(description='''
+		This script generates a module definition file containing a list of symbols
+		to export from a library. Source files are technically bash scripts (and thus may
+		use #comment syntax) but in general, take the form of a list of symbols:
+
+		  <kind> symbol1 [symbol2, symbol3, ...]
+
+		where <kind> is either 'text' or 'data'
+		''')
+	parser.add_argument('--out', type=FileType('w', encoding='utf-8'), default=stdout, help='Write output to a file')
+	parser.add_argument('--name', type=str, help='Name of the library (required)')
+	parser.add_argument('--format', type=str, choices=['win', 'mac', 'linux'], default='win', help='Format of the module definition file')
+	parser.add_argument('--underscore', action='store_true', help='The symbols need an underscore for exporting')
+	parser.add_argument('files', nargs=REMAINDER, type=FileType('r', encoding='utf-8'))
+	args = parser.parse_args()
+
+	lines = collate_exports(args.files, format=args.format, needs_underscore=args.underscore)
+
+	for line in lines:
+		args.out.write(line)
+		args.out.write('\n')
diff --git a/meson/generate_component_dox.py b/meson/generate_component_dox.py
new file mode 100644
index 000000000..361ae9240
--- /dev/null
+++ b/meson/generate_component_dox.py
@@ -0,0 +1,25 @@
+#!/usr/bin/env python3
+
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from __future__ import annotations
+from argparse import ArgumentParser, FileType
+from io import TextIOWrapper
+from pathlib import Path
+
+if __name__ == '__main__':
+	parser = ArgumentParser(description='Create a Doxyfile for an component')
+	parser.add_argument('--component', required=True, help='Component type')
+	parser.add_argument('--output', type=FileType('w', encoding='utf-8'), required=True, help='Write to this file')
+	parser.add_argument('source', type=Path, help='Source file of the component')
+	args = parser.parse_args()
+
+	f: TextIOWrapper = args.output
+
+	source: Path = args.source
+	page_name = source.stem.replace('.', '_')
+
+	f.write(f'/*!\page {args.component}_{page_name} {page_name} \n')
+	f.write(f'   \includelineno {source.resolve(strict=True).as_posix()}\n')
+	f.write('*/\n')
diff --git a/meson/generate_doxy.py b/meson/generate_doxy.py
new file mode 100644
index 000000000..9ef0fb660
--- /dev/null
+++ b/meson/generate_doxy.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from __future__ import annotations
+from argparse import ArgumentParser, FileType
+from pathlib import Path
+from io import TextIOWrapper
+
+if __name__ == '__main__':
+	parser = ArgumentParser(description='Create a section Doxyfile')
+	parser.add_argument('--sections', nargs='+', required=True, help='Doxyfile template')
+	parser.add_argument('--include', type=Path, help='Add this folder to the include path')
+	parser.add_argument('--output', type=FileType('w', encoding='utf-8'), required=True, help='Write to this file')
+	parser.add_argument('files', nargs='+', type=Path, help='Inputs to the Doxyfile')
+	args = parser.parse_args()
+
+	f: TextIOWrapper = args.output
+
+	inputs = ' '.join([f.as_posix() for f in args.files])
+	include: str | None = args.include
+	sections = ' '.join(args.sections)
+
+	f.write(f'INPUT += {inputs}\n')
+	if include is not None:
+		args.output.write(f'INCLUDE_PATH += {include.as_posix()}\n')
+	f.write(f'ENABLED_SECTIONS += {sections}\n')
diff --git a/meson/generate_doxyfile.py b/meson/generate_doxyfile.py
new file mode 100644
index 000000000..edea48a6c
--- /dev/null
+++ b/meson/generate_doxyfile.py
@@ -0,0 +1,44 @@
+#!/usr/bin/env python3
+
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from __future__ import annotations
+from argparse import ArgumentParser, FileType
+from io import StringIO
+from pathlib import Path
+import os
+
+def with_trailing(p: Path) -> str:
+	return f"{p.as_posix()}{'/' if p.is_dir() else ''}"
+
+if __name__ == '__main__':
+	parser = ArgumentParser(description='Create a Doxyfile for the whole project')
+	parser.add_argument('--prelude', nargs='+', type=Path, help='Templates that will be copied to the file')
+	parser.add_argument('--strip', nargs='+', type=Path, help='Make paths inside this directory relative')
+	parser.add_argument('--example-path', nargs='+', type=Path, help='Directory that contains example code fragments')
+	parser.add_argument('--output', type=FileType('w', encoding='utf-8'), required=True, help='Write to this file')
+	parser.add_argument('inputs', nargs='+', type=Path, help='Inputs for the Doxygen documentation')
+	args = parser.parse_args()
+
+	f = StringIO()
+
+	files: list[Path] = args.prelude
+
+	for file in files:
+		with file.open(encoding='utf-8') as input:
+			f.write(input.read())
+	f.write('# MESON override OUTPUT_DIR\n')
+	f.write('OUTPUT_DIRECTORY       = \n')
+	if args.strip is not None:
+		paths_to_strip: str = ' '.join([f.as_posix() for f in args.strip])
+		f.write(f'STRIP_FROM_PATH += {paths_to_strip}\n')
+	if len(args.inputs) > 0:
+		inputs = ' '.join([f.as_posix() for f in args.inputs])
+		f.write(f'INPUT += {inputs}\n')
+	if len(args.example_path) > 0:
+		example_paths = ' '.join(map(with_trailing, args.example_path))
+		f.write(f'EXAMPLE_PATH += {example_paths}\n')
+
+	with args.output as output:
+		output.write(f.getvalue())
diff --git a/meson/parse_options.py b/meson/parse_options.py
new file mode 100644
index 000000000..825b5eeac
--- /dev/null
+++ b/meson/parse_options.py
@@ -0,0 +1,171 @@
+#!/usr/bin/env python3
+
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from __future__ import annotations
+import re
+from warnings import warn
+
+def parse_options(lines: list[str]) -> dict:
+	current_options: dict = {}
+	boolean_regexp = r'--(enable|disable)-([^\s]+)\s+(.+)'
+	combo_regexp = r'^--([a-z0-9_\-]+)=\{?([A-Za-z]+\|[A-Za-z|]+)\}?\s+(.+)$'
+	stock_regexp = r'^--([a-z0-9_\-]+)(?:=[A-Za-z]+)?\s+(.+)$'
+	codec_regexp = r'^([a-z0-9_\-]+):\s+(encoder|decoder)(?:\s+)?(encoder|decoder)?$'
+
+	for line in lines:
+		line = line.strip()
+		option = re.match(boolean_regexp, line)
+		if option:
+			current_options[option.group(2).lower().replace('-', '_')] = {
+				'type': 'boolean',
+				'value': 'enabled' if option.group(1) == 'disable' else 'unset',
+				'description': option.group(3).strip()
+			}
+			continue
+		option = re.match(combo_regexp, line)
+		if option:
+			current_options[option.group(1).lower().replace('-', '_')] = {
+				'type': 'combo',
+				'choices': option.group(2).split('|'),
+				'description': option.group(3)
+			}
+			continue
+		option = re.match(codec_regexp, line)
+		if option:
+			feature = option.group(2).strip()
+			current_options[f'{option.group(1)}_{feature}'.lower().replace('-', '_')] = {
+				'type': 'boolean',
+				'value': 'enabled' if option.group(1) == 'disable' else 'unset',
+				'description': f'Enable the {option.group(1).upper()} {feature} only'
+			}
+			if option.group(3):
+				additional_feature = option.group(3).strip()
+				current_options[f'{option.group(1)}_{additional_feature}'.lower().replace('-', '_')] = {
+					'type': 'boolean',
+					'value': 'enabled' if option.group(1) == 'disable' else 'unset',
+					'description': f'Enable the {option.group(1).upper()} {additional_feature} only'
+				}
+				current_options[f'{option.group(1)}'.lower().replace('-', '_')] = {
+					'type': 'boolean',
+					'value': 'enabled' if option.group(1) == 'disable' else 'unset',
+					'description': f'Enable the {option.group(1).upper()} codec'
+				}
+			else:
+				current_options[f'{option.group(1)}'.lower().replace('-', '_')] = {
+					'type': 'boolean',
+					'value': 'enabled' if option.group(1) == 'disable' else 'unset',
+					'description': f'Enable the {option.group(1).upper()} {feature}'
+				}
+			continue
+		option = re.match(stock_regexp, line)
+		if option:
+			current_options[option.group(1).lower().replace('-', '_')] = {
+				'type': 'string',
+				'description': option.group(2)
+			}
+		elif line.startswith('--') and not re.match(r'.+\<[a-z]+\>.*', line):
+			warn(f"Unhandled option: {line}, did you apply meson/patch-configure.diff?", FutureWarning)
+
+	return current_options
+
+MESON_HANDLED_OPTIONS = [
+	'help',
+	'log',
+	'target',
+	'extra_cflags',
+	'extra_cxxflags',
+	'extra_warnings',
+	'werror',
+	'optimizations',
+	'pic',
+	'ccache',
+	'debug',
+	'gcov',
+	'dependency_tracking',
+	'libc',
+	'as',
+	'shared',
+	'static',
+	'small',
+	'static_msvcrt',
+	'debug_libs',
+	'install_srcs',
+]
+
+def filter_meson_handled_options(pair) -> bool:
+	k, _v = pair
+	return k not in MESON_HANDLED_OPTIONS
+
+def update_meson_options(options: dict):
+	has_generated = False
+	lines = []
+	with open('meson_options.txt', 'r', encoding='utf-8') as meson_file:
+		opening = '#### --- GENERATED EXTERN OPTIONS --- ####\n'
+		closing = opening.replace('GENERATED', 'END GENERATED')
+		for l in meson_file.readlines():
+			if l == opening:
+				has_generated = True
+				lines.append(l)
+				for key, kv in options.items():
+					if kv['type'] == 'combo':
+						choices = ', '.join([f"'{i}'" for i in kv['choices']])
+						lines.append(f"option('{key}', type: 'combo', choices: [{choices}], description: '{kv['description']}')\n")
+					elif kv['type'] == 'boolean':
+						if kv['value'] != 'unset':
+							value = f"value: '{kv['value']}', "
+						else:
+							value = ''
+						lines.append(f"option('{key}', type: 'feature', {value}description: '{kv['description']}')\n")
+					else:
+						if kv.get('value') and len(kv['value']) != 0:
+							value = f"value: '{kv['value']}', "
+						else:
+							value = ''
+						lines.append(f"option('{key}', type: 'string', {value}description: '{kv['description']}')\n")
+			elif l == closing:
+				lines.append(l)
+				has_generated = False
+			elif not has_generated:
+				lines.append(l)
+
+	with open('meson_options.txt', 'w') as meson_file:
+		meson_file.write(''.join(lines))
+
+def update_meson_build(options: dict):
+	has_generated = False
+	lines = []
+	booleans = [i for i in options.keys() if options.get(i)['type'] == 'boolean']
+	with open('meson.build', 'r', encoding='utf-8') as meson_file:
+		opening = '#### --- GENERATED EXTERN OPTIONS --- ####\n'
+		closing = opening.replace('GENERATED', 'END GENERATED')
+		for l in meson_file.readlines():
+			if l == opening:
+				has_generated = True
+				lines.append(l)
+				lines.append('IGNORE_MESON_BUILTINS = [\n')
+				for i in MESON_HANDLED_OPTIONS:
+					lines.append(f"\t'{i}',\n")
+				lines.append(']\n')
+				lines.append('\n')
+				lines.append('MESON_OPTIONS = [\n')
+				for i in booleans:
+					lines.append(f"\t'{i}',\n")
+				lines.append(']\n')
+			elif l == closing:
+				lines.append(l)
+				has_generated = False
+			elif not has_generated:
+				lines.append(l)
+
+	with open('meson.build', 'w') as meson_file:
+		meson_file.write(''.join(lines))
+
+if __name__=='__main__':
+	# ./configure --help > tmp_meson_options.txt
+	with open('tmp_meson_options.txt', 'r', encoding='utf-8') as f:
+		options = parse_options(f.readlines())
+		options = dict(filter(filter_meson_handled_options, options.items()))
+		update_meson_options(options)
+		update_meson_build(options)
diff --git a/meson/parse_sources.py b/meson/parse_sources.py
new file mode 100644
index 000000000..5693aaddd
--- /dev/null
+++ b/meson/parse_sources.py
@@ -0,0 +1,219 @@
+#!/usr/bin/env python3
+
+# SPDX-FileNotice: This file is based on the FFmpeg Meson build version
+# SPDX-FileCopyrightText: 2018 Mathieu Duponchelle <mathieu@centricular.com>
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from __future__ import annotations
+import io
+import os
+from pathlib import PurePosixPath
+import re
+
+SOURCE_TYPE_EXTS_MAP = {
+	'c': 'c',
+	'cpp': 'c',
+	'cc': 'c',
+	'h': 'h',
+	'hpp': 'h',
+	'hxx': 'h',
+	'asm': 'asm',
+	'S': 'c', # because it's not Nasm
+	'yuv': 'data',
+	'y4m': 'data',
+	'ivf': 'data',
+	'webm': 'data',
+	'md5': 'data',
+	'sha1': 'data',
+	'res': 'data',
+	'rawfile': 'data',
+}
+
+def valid_file(target: str, ofile: str, source_type: str) -> bool:
+	if source_type == 'data':
+		return True
+	tgt = os.path.join(os.getcwd(), target, ofile)
+	return os.path.exists(tgt)
+
+def make_to_meson(target: str, paths: list[str]):
+	source_maps = {}
+
+	skipped = set('mk')
+
+	for path in paths:
+		with open(path, 'r') as f:
+			accum = []
+			accumulate = False
+			component = None
+			label = None
+			source_type = None
+
+			for l in f.readlines():
+				l = l.strip().split('#', 1)[0].strip()
+
+				if accumulate:
+					ofiles = l
+				elif option := re.match(r'([A-Z0-9_]+)(?:-yes)?\s+[+:]=\s+([a-zA-Z0-9_/.]+\.[a-zA-Z0-9]+)$', l):
+					component = ''.join(option.group(1).split('_SRCS')).lower()
+					label = ''
+					ofiles = option.group(2)
+					source_type = SOURCE_TYPE_EXTS_MAP.get(PurePosixPath(option.group(2)).suffix.strip('.'))
+				elif option := re.match(r'([A-Z0-9_]+)-.+(?:HAVE_|CONFIG_)([A-Z0-9_]+).+[+:]=\s+([a-zA-Z0-9_/.-]+)$', l):
+					# remove the component suffix
+					component = ''.join(option.group(1).split('_SRCS')).lower()
+					label = option.group(2)
+					ofiles = option.group(3)
+					source_type = SOURCE_TYPE_EXTS_MAP.get(PurePosixPath(option.group(3)).suffix.strip('.'))
+				elif option := re.match(r'([A-Z0-9_]+)-yes\s+[+:]=\s+(.+)\$\(ASM\)\s*', l):
+					# remove the component suffix and patch the extension in
+					component = ''.join(option.group(1).split('_SRCS')).lower()
+					label = ''
+					ofiles = f'{option.group(2)}.asm'
+					source_type = 'c'
+				elif option := re.match(r'([A-Z0-9_]+)-.+(?:HAVE_|CONFIG_)([A-Z0-9_]+).+[+:]=\s+(.+)\$\(ASM\)\s*', l):
+					# remove the component suffix and patch the extension in
+					component = ''.join(option.group(1).split('_SRCS')).lower()
+					label = option.group(2)
+					ofiles = f'{option.group(3)}.asm'
+					source_type = 'c'
+				else:
+					continue
+
+				if not source_type or not component or not label:
+					raise RuntimeError('Unspecified input file data was found')
+
+				accumulate = ofiles.endswith('\\')
+				ofiles = ofiles.strip('\\')
+				ofiles = ofiles.split()
+				ifiles = [ofile for ofile in ofiles if valid_file(target, ofile, source_type)]
+
+				if len([of for of in ofiles if not of.startswith("$")]) != len(ifiles):
+					print("WARNING: %s and %s size don't match, not building!" % ([of for of in ofiles if not of.startswith("$")], ifiles))
+					skipped.add(label)
+
+				if accumulate:
+					accum += ifiles
+				else:
+					component_sources: dict[str, list[str]] = source_maps.setdefault(source_type, {}).setdefault(component, {})
+					component_sources[label] = component_sources.setdefault(label, list()) + accum + ifiles
+					accum = []
+
+			if not label:
+				raise RuntimeError('Unspecified component type')
+
+			# Makefiles can end with '\' and this is just a porting script ;)
+			if accum:
+				component_sources: dict[str, list[str]] = source_maps.setdefault(source_type, {}).setdefault(component, {})
+				component_sources[label] = component_sources.setdefault(label, list()) + accum
+				accum = []
+
+
+	lines = []
+	has_not_generated = False
+	try:
+		with open(os.path.join(target, 'meson.build'), 'r') as meson_file:
+			for l in meson_file.readlines():
+				if l == '#### --- GENERATED --- ####\n':
+					lines += [l, '\n']
+					has_not_generated = True
+					break
+				lines.append(l)
+	except FileNotFoundError:
+		pass
+
+	f = io.StringIO()
+
+	# types -> component -> label (feature)
+	source_types = (
+		('', source_maps.setdefault('c', {})),
+		('headers_', source_maps.setdefault('h', {})),
+		('asm_', source_maps.setdefault('asm', {})),
+		('data_', source_maps.setdefault('data', {})),
+	)
+
+	for source_type, components in source_types:
+		for component, component_sources in components.items():
+			default_sources = component_sources.pop('', [])
+
+			file_opening = '[' if source_type == 'data_' else 'files('
+			file_closing = ']' if source_type == 'data_' else ')'
+
+			f.write(f'{component}_{source_type}sources = {file_opening}\n')
+			for source in default_sources:
+				if '$' in source:
+					print ('Warning: skipping %s' % source)
+					continue
+				f.write(f"\t'{source}',\n")
+			f.write('{file_closing}\n\n')
+
+			f.write(f'{component}_{source_type}optional_sources = {{\n')
+			for label in sorted (component_sources):
+				if label in skipped:
+					f.write(f"\t# '{label.lower()}' : {file_opening}\n")
+				else:
+					f.write(f"\t'{label.lower()}' : {file_opening}\n")
+				l = len (component_sources[label])
+				for i, source in enumerate(component_sources[label]):
+					if '$' in source:
+						print ('Warning: skipping %s' % source)
+						continue
+					f.write(f"\t\t'{source}'{',' if i + 1 < l else ''}\n")
+				f.write(f'\t{file_closing},\n')
+			f.write('}\n\n')
+
+	if has_not_generated:
+		lines.append(f.getvalue())
+		with open(os.path.join(target, 'meson.build'), 'r') as meson_file:
+			out_generated = False
+			for l in meson_file.readlines():
+				if l == '#### --- END GENERATED --- ####\n':
+					out_generated = True
+				if out_generated:
+					lines.append(l)
+		content = ''.join(lines)
+	else:
+		content = f.getvalue()
+
+
+	with open(os.path.join(target, 'meson.build'), 'w') as meson_file:
+		meson_file.write(content)
+
+paths = {
+	'vp8': [
+	    'vp8/vp8_common.mk',
+	    'vp8/vp8cx.mk',
+	    'vp8/vp8dx.mk',
+	],
+	'vp9': [
+	    'vp9/vp9_common.mk',
+	    'vp9/vp9cx.mk',
+	    'vp9/vp9dx.mk',
+	],
+	'vpx_dsp': [
+	    'vpx_dsp/vpx_dsp.mk',
+	],
+	'vpx_scale': [
+	    'vpx_scale/vpx_scale.mk',
+	],
+	'vpx_mem': [
+	    'vpx_mem/vpx_mem.mk',
+	],
+	'vpx_ports': [
+	    'vpx_ports/vpx_ports.mk',
+	],
+	'vpx': [
+	    'vpx/vpx_codec.mk',
+	],
+	'vpx_util': [
+	    'vpx_util/vpx_util.mk',
+	],
+	'test': [
+		'test/test.mk',
+		'test/test-data.mk',
+	],
+}
+
+if __name__=='__main__':
+	for component, path in paths.items():
+		make_to_meson(component, path)
diff --git a/meson/patch-configure.diff b/meson/patch-configure.diff
new file mode 100644
index 000000000..5e79bbb70
--- /dev/null
+++ b/meson/patch-configure.diff
@@ -0,0 +1,60 @@
+diff --git a/build/make/configure.sh b/build/make/configure.sh
+index 4bf090f00..183bfe725 100644
+--- a/build/make/configure.sh
++++ b/build/make/configure.sh
+@@ -75,8 +75,7 @@ Build options:
+   --extra-cflags=ECFLAGS      add ECFLAGS to CFLAGS [$CFLAGS]
+   --extra-cxxflags=ECXXFLAGS  add ECXXFLAGS to CXXFLAGS [$CXXFLAGS]
+   ${toggle_extra_warnings}    emit harmless warnings (always non-fatal)
+-  ${toggle_werror}            treat warnings as errors, if possible
+-                              (not available with all compilers)
++  ${toggle_werror}            treat warnings as errors, if possible (not available with all compilers)
+   ${toggle_optimizations}     turn on/off compiler optimization flags
+   ${toggle_pic}               turn on/off Position Independent Code
+   ${toggle_ccache}            turn on/off compiler cache
+@@ -84,8 +83,7 @@ Build options:
+   ${toggle_gprof}             enable/disable gprof profiling instrumentation
+   ${toggle_gcov}              enable/disable gcov coverage instrumentation
+   ${toggle_thumb}             enable/disable building arm assembly in thumb mode
+-  ${toggle_dependency_tracking}
+-                              disable to speed up one-time build
++  ${toggle_dependency_tracking} disable to speed up one-time build
+ 
+ Install options:
+   ${toggle_install_docs}      control whether docs are installed
+diff --git a/configure b/configure
+index ae289f77b..094194fca 100755
+--- a/configure
++++ b/configure
+@@ -35,9 +35,7 @@ Advanced options:
+   ${toggle_debug_libs}            in/exclude debug version of libraries
+   ${toggle_static_msvcrt}         use static MSVCRT (VS builds only)
+   ${toggle_vp9_highbitdepth}      use VP9 high bit depth (10/12) profiles
+-  ${toggle_better_hw_compatibility}
+-                                  enable encoder to produce streams with better
+-                                  hardware decoder compatibility
++  ${toggle_better_hw_compatibility} enable encoder to produce streams with better hardware decoder compatibility
+   ${toggle_vp8}                   VP8 codec support
+   ${toggle_vp9}                   VP9 codec support
+   ${toggle_internal_stats}        output of encoder internal stats for debug, if supported (encoders)
+@@ -48,9 +46,7 @@ Advanced options:
+   ${toggle_realtime_only}         enable this option while building for real-time encoding
+   ${toggle_onthefly_bitpacking}   enable on-the-fly bitpacking in real-time encoding
+   ${toggle_error_concealment}     enable this option to get a decoder which is able to conceal losses
+-  ${toggle_coefficient_range_checking}
+-                                  enable decoder to check if intermediate
+-                                  transform coefficients are in valid range
++  ${toggle_coefficient_range_checking} enable decoder to check if intermediate transform coefficients are in valid range
+   ${toggle_runtime_cpu_detect}    runtime cpu detection
+   ${toggle_shared}                shared library support
+   ${toggle_static}                static library support
+@@ -58,8 +54,7 @@ Advanced options:
+   ${toggle_postproc_visualizer}   macro block / block level visualizers
+   ${toggle_multi_res_encoding}    enable multiple-resolution encoding
+   ${toggle_temporal_denoising}    enable temporal denoising and disable the spatial denoiser
+-  ${toggle_vp9_temporal_denoising}
+-                                  enable vp9 temporal denoising
++  ${toggle_vp9_temporal_denoising} enable vp9 temporal denoising
+   ${toggle_webm_io}               enable input from and output to WebM container
+   ${toggle_libyuv}                enable libyuv
+ 
diff --git a/meson/stdinout_wrapper.py b/meson/stdinout_wrapper.py
new file mode 100644
index 000000000..5062fc8a2
--- /dev/null
+++ b/meson/stdinout_wrapper.py
@@ -0,0 +1,19 @@
+#!/usr/bin/env python3
+
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from __future__ import annotations
+from argparse import ArgumentParser, FileType, REMAINDER
+import subprocess
+
+if __name__ == '__main__':
+	parser = ArgumentParser(description='Redirect I/O streams from/to the given files')
+	parser.add_argument('--input', type=FileType('rb'), help='Pipe this file to STDIN')
+	parser.add_argument('--output', type=FileType('w', encoding='utf-8'), help='Pipe STDOUT to this file')
+	parser.add_argument('executable', help='Executable to run')
+	parser.add_argument('args', nargs=REMAINDER, help='Arguments')
+
+	args = parser.parse_args()
+
+	subprocess.run([args.executable] + args.args, input=args.input.read(), stdout=args.output, check=True)
diff --git a/meson/transform_config.py b/meson/transform_config.py
new file mode 100644
index 000000000..0ac5e0c05
--- /dev/null
+++ b/meson/transform_config.py
@@ -0,0 +1,53 @@
+#!/usr/bin/env python3
+
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from __future__ import annotations
+from argparse import ArgumentParser
+from pathlib import Path
+import re
+
+def parse_options(lines: list[str]) -> list[str]:
+	options = []
+	for line in lines:
+		if option := re.match(r'#define\s+(VPX_ARCH|HAVE|CONFIG)(_[A-Z0-9_]+)\s+([01])', line):
+			if option.group(3) == '1':
+				options.append(f'{option.group(1)}{option.group(2)}=yes\n')
+		elif option := re.match(r'#define\s+(VERSION_STRING)\s+"(.+)"', line):
+			options.append(f'{option.group(1)}={option.group(2).strip()}')
+	return options
+
+
+def print_webm_license(prefix='', suffix='') -> list[str]:
+	return [
+		f'{prefix} Copyright (c) 2011 The WebM project authors. All Rights Reserved.{suffix}\n',
+		f'{prefix} {suffix}\n',
+		f'{prefix} Use of this source code is governed by a BSD-style license{suffix}\n',
+		f'{prefix} that can be found in the LICENSE file in the root of the source{suffix}\n',
+		f'{prefix} tree. An additional intellectual property rights grant can be found{suffix}\n',
+		f'{prefix} in the file PATENTS.  All contributing project authors may{suffix}\n',
+		f'{prefix} be found in the AUTHORS file in the root of the source tree.{suffix}\n',
+	]
+
+
+def create_config_mk_file(input: list[str], output: Path):
+	with open(output, 'w', encoding='utf-8') as f:
+		lines = print_webm_license(prefix='##')
+		lines += parse_options(input)
+		f.writelines(lines)
+
+if __name__ == '__main__':
+	parser = ArgumentParser()
+	parser.add_argument('output', type=Path, help='Path to config.mk')
+	parser.add_argument('input', nargs='+', type=Path, help='Path to configuration headers')
+	args = parser.parse_args()
+
+	lines = []
+
+	inputs: list[Path] = args.input
+	for input in inputs:
+		with input.open('r', encoding='utf-8') as f:
+			lines.extend(f.readlines())
+
+	create_config_mk_file(lines, args.output)
diff --git a/meson/transform_config_asm.py b/meson/transform_config_asm.py
new file mode 100644
index 000000000..d32eaa846
--- /dev/null
+++ b/meson/transform_config_asm.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from __future__ import annotations
+from argparse import ArgumentParser
+from pathlib import Path
+import re
+
+def parse_all_options(lines: list[str]) -> dict[str, str]:
+	options = {}
+	for line in lines:
+		if option := re.match(r'#define\s+(VPX_ARCH|HAVE|CONFIG)(_[A-Z0-9_]+)\s+([01])', line):
+			options[f'{option.group(1)}{option.group(2)}'] = option.group(3)
+	return options
+
+def create_config_asm_file(options: dict[str, str], output: Path, format='yasm'):
+	with open(output, 'w', encoding='utf-8') as f:
+		if format == 'yasm':
+			lines = [f'{k} equ {v}\n' for k, v in options.items()]
+		elif format == 'ads':
+			lines = [f'{k} EQU {v}\n' for k, v in options.items()]
+			lines += ['END\n']
+		else:
+			lines = [f'{k} .equ {v}\n' for k, v in options.items()]
+		f.writelines(lines)
+
+if __name__ == '__main__':
+	parser = ArgumentParser()
+	parser.add_argument('input', type=Path, help='Path to configuration header')
+	parser.add_argument('--format', choices=['yasm', 'ads', 'gas'], default='ads', help='Format of the assembly file')
+	parser.add_argument('output', type=Path, help='Path to config.asm')
+	args = parser.parse_args()
+	with open(args.input, 'r', encoding='utf-8') as f:
+		options = parse_all_options(f.readlines())
+		create_config_asm_file(options, args.output, format=args.format)
diff --git a/meson/vpx_config.c b/meson/vpx_config.c
new file mode 100644
index 000000000..1b684084c
--- /dev/null
+++ b/meson/vpx_config.c
@@ -0,0 +1,10 @@
+/* Copyright (c) 2011 The WebM project authors. All Rights Reserved. */
+/*  */
+/* Use of this source code is governed by a BSD-style license */
+/* that can be found in the LICENSE file in the root of the source */
+/* tree. An additional intellectual property rights grant can be found */
+/* in the file PATENTS.  All contributing project authors may */
+/* be found in the AUTHORS file in the root of the source tree. */
+#include "vpx/vpx_codec.h"
+static const char* const cfg = @CONFIGURE_ARGS@;
+const char *vpx_codec_build_config(void) {return cfg;}
diff --git a/meson_options.txt b/meson_options.txt
new file mode 100644
index 000000000..7dc06dea5
--- /dev/null
+++ b/meson_options.txt
@@ -0,0 +1,49 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+option('enable_features', type: 'array', description: 'Enable  these (possibly undocumented) configuration entries')
+option('disable_features', type: 'array', description: 'Disable these (possibly undocumented) configuration entries')
+option('force_enable_features', type: 'array', description: 'Forcibly set these (possibly undocumented) configuration entries as enabled')
+option('force_disable_features', type: 'array', description: 'Forcibly set these (possibly undocumented) configuration entries as disabled')
+#### --- GENERATED EXTERN OPTIONS --- ####
+option('cpu', type: 'string', description: 'tune for the specified CPU (ARM: cortex-a8, X86: sse3)')
+option('gprof', type: 'feature', description: 'enable/disable gprof profiling instrumentation')
+option('thumb', type: 'feature', description: 'enable/disable building arm assembly in thumb mode')
+option('install_docs', type: 'feature', description: 'control whether docs are installed')
+option('install_bins', type: 'feature', value: 'enabled', description: 'control whether binaries are installed')
+option('install_libs', type: 'feature', value: 'enabled', description: 'control whether libraries are installed')
+option('libs', type: 'feature', value: 'enabled', description: 'libraries')
+option('examples', type: 'feature', value: 'enabled', description: 'examples')
+option('tools', type: 'feature', value: 'enabled', description: 'tools')
+option('docs', type: 'feature', value: 'enabled', description: 'documentation')
+#### MANUAL
+option('unit_tests', type: 'feature', value: 'disabled', description: 'unit tests')
+option('decode_perf_tests', type: 'feature', description: 'build decoder perf tests with unit tests')
+option('encode_perf_tests', type: 'feature', description: 'build encoder perf tests with unit tests')
+option('size_limit', type: 'string', description: 'max size to allow in the decoder')
+option('codec_srcs', type: 'feature', description: 'in/exclude codec library source code')
+option('vp9_highbitdepth', type: 'feature', description: 'use VP9 high bit depth (10/12) profiles')
+option('better_hw_compatibility', type: 'feature', description: 'enable encoder to produce streams with better hardware decoder compatibility')
+option('vp8', type: 'feature', description: 'Enable the VP8 codec')
+option('vp9', type: 'feature', description: 'Enable the VP9 codec')
+option('internal_stats', type: 'feature', description: 'output of encoder internal stats for debug, if supported (encoders)')
+option('postproc', type: 'feature', description: 'postprocessing')
+option('vp9_postproc', type: 'feature', description: 'vp9 specific postprocessing')
+option('multithread', type: 'feature', value: 'enabled', description: 'multithreaded encoding and decoding')
+option('spatial_resampling', type: 'feature', value: 'enabled', description: 'spatial sampling (scaling) support')
+option('realtime_only', type: 'feature', description: 'enable this option while building for real-time encoding')
+option('onthefly_bitpacking', type: 'feature', description: 'enable on-the-fly bitpacking in real-time encoding')
+option('error_concealment', type: 'feature', description: 'enable this option to get a decoder which is able to conceal losses')
+option('coefficient_range_checking', type: 'feature', description: 'enable decoder to check if intermediate transform coefficients are in valid range')
+option('runtime_cpu_detect', type: 'feature', description: 'runtime cpu detection')
+option('postproc_visualizer', type: 'feature', description: 'macro block / block level visualizers')
+option('multi_res_encoding', type: 'feature', description: 'enable multiple-resolution encoding')
+option('temporal_denoising', type: 'feature', value: 'enabled', description: 'enable temporal denoising and disable the spatial denoiser')
+option('vp9_temporal_denoising', type: 'feature', description: 'enable vp9 temporal denoising')
+option('webm_io', type: 'feature', description: 'enable input from and output to WebM container')
+option('libyuv', type: 'feature', description: 'enable libyuv')
+option('vp8_encoder', type: 'feature', description: 'Enable the VP8 encoder only')
+option('vp8_decoder', type: 'feature', description: 'Enable the VP8 decoder only')
+option('vp9_encoder', type: 'feature', description: 'Enable the VP9 encoder only')
+option('vp9_decoder', type: 'feature', description: 'Enable the VP9 decoder only')
+#### --- END GENERATED EXTERN OPTIONS --- ####
diff --git a/subprojects/.gitignore b/subprojects/.gitignore
new file mode 100644
index 000000000..e14daf2a4
--- /dev/null
+++ b/subprojects/.gitignore
@@ -0,0 +1,3 @@
+strawberry-perl*
+nasm-*
+packagecache
diff --git a/subprojects/nasm-mac.wrap b/subprojects/nasm-mac.wrap
new file mode 100644
index 000000000..396961ffe
--- /dev/null
+++ b/subprojects/nasm-mac.wrap
@@ -0,0 +1,9 @@
+[wrap-file]
+directory = nasm-2.16.01
+source_url = https://www.nasm.us/pub/nasm/releasebuilds/2.16.01/macosx/nasm-2.16.01-macosx.zip
+source_filename = nasm-2.16.01-macosx.zip
+source_hash = d53c9a1bc9cd92d22e37924d31e9c68413fa03104fd165a6e7b7faf8800a1822
+patch_directory = nasm
+
+[provide]
+program_names = nasm_macos_exe
diff --git a/subprojects/nasm-win.wrap b/subprojects/nasm-win.wrap
new file mode 100644
index 000000000..b103ddc9a
--- /dev/null
+++ b/subprojects/nasm-win.wrap
@@ -0,0 +1,9 @@
+[wrap-file]
+directory = nasm-2.16.01
+source_url = https://www.nasm.us/pub/nasm/releasebuilds/2.16.01/win32/nasm-2.16.01-win32.zip
+source_filename = nasm-2.16.01-win32.zip
+source_hash = e289fa70c88594b092c916344bb8bfcd6896b604bfab284ab57b1372997c820c
+patch_directory = nasm
+
+[provide]
+program_names = nasm_windows_exe
diff --git a/subprojects/packagefiles/nasm/meson.build b/subprojects/packagefiles/nasm/meson.build
new file mode 100644
index 000000000..5e3d92fc6
--- /dev/null
+++ b/subprojects/packagefiles/nasm/meson.build
@@ -0,0 +1,13 @@
+project('nasm', 'c', license: 'BSD-2-Clause')
+
+if host_machine.system() == 'windows'
+	nasm_exe = find_program('nasm', required: true)
+	meson.override_find_program('nasm_windows_exe', nasm_exe)
+elif host_machine.system() == 'darwin'
+	python_exe = find_program('patch_nasm.py')
+	run_command(python_exe, meson.current_source_dir(), check: true)
+	nasm_exe = find_program('nasm', required: true)
+	meson.override_find_program('nasm_macos_exe', nasm_exe)
+else
+	error('This wrap only supports Windows or macOS')
+endif
diff --git a/subprojects/packagefiles/nasm/patch_nasm.py b/subprojects/packagefiles/nasm/patch_nasm.py
new file mode 100644
index 000000000..d41e9cb65
--- /dev/null
+++ b/subprojects/packagefiles/nasm/patch_nasm.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python3
+
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from pathlib import Path
+import os
+import stat
+from argparse import ArgumentParser
+
+if __name__ == '__main__':
+	parser = ArgumentParser(description='Make Nasm executable')
+	parser.add_argument('dir', type=Path, help='Source directory')
+	args = parser.parse_args()
+	os.chmod(args.dir / "nasm", stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH | stat.S_IWUSR)
diff --git a/subprojects/packagefiles/perl/meson.build b/subprojects/packagefiles/perl/meson.build
new file mode 100644
index 000000000..26d084fd4
--- /dev/null
+++ b/subprojects/packagefiles/perl/meson.build
@@ -0,0 +1,8 @@
+project('strawberryperl', 'c', license: ' Artistic-1.0-Perl OR GPL-1.0-or-later')
+
+perl_exe = find_program('perl',
+	dirs: [meson.current_source_dir() / 'perl' / 'bin'],
+	required: true
+)
+
+meson.override_find_program('perl_windows_exe', perl_exe)
diff --git a/subprojects/perl-win.wrap b/subprojects/perl-win.wrap
new file mode 100644
index 000000000..f2074299b
--- /dev/null
+++ b/subprojects/perl-win.wrap
@@ -0,0 +1,10 @@
+[wrap-file]
+directory = strawberry-perl-5.32.1.1-32bit-portable
+source_url = https://strawberryperl.com/download/5.32.1.1/strawberry-perl-5.32.1.1-32bit-portable.zip
+source_filename = strawberry-perl-5.32.1.1-32bit-portable.zip
+source_hash = d9c5711d12573a0f6d977792caa58364b1d46217521ae5c25cf5cc378a7c23c0
+patch_directory = perl
+lead_directory_missing = true
+
+[provide]
+program_names = perl_windows_exe
diff --git a/test/meson.build b/test/meson.build
new file mode 100644
index 000000000..26a55d980
--- /dev/null
+++ b/test/meson.build
@@ -0,0 +1,1593 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+# test.mk
+
+#### --- GENERATED --- ####
+
+libvpx_test_sources = files(
+	'bench.cc',
+	'test_libvpx.cc',
+	'../md5_utils.c', # MANUAL
+	'../y4minput.c', # MANUAL
+	'test_vectors.cc',
+	'decode_test_driver.cc',
+	# 'decode_perf_test.cc', # MANUAL
+	# 'encode_perf_test.cc', # MANUAL
+	# 'invalid_file_test.cc', # MANUAL
+	# 'vp8_boolcoder_test.cc', # MANUAL
+	# 'vp8_fragments_test.cc', # MANUAL
+	# 'idct_test.cc', # MANUAL
+	# 'predict_test.cc', # MANUAL
+	# 'vpx_scale_test.cc', # MANUAL
+	# 'idct8x8_test.cc', # MANUAL
+	# 'partial_idct_test.cc', # MANUAL
+	# 'superframe_test.cc', # MANUAL
+	# 'tile_independence_test.cc', # MANUAL
+	# 'vp9_boolcoder_test.cc', # MANUAL
+	# 'vp9_encoder_parms_get_to_decoder.cc', # MANUAL
+	# 'vp9_roi_test.cc', # MANUAL
+	# 'convolve_test.cc', # MANUAL
+	# 'lpf_test.cc', # MANUAL
+	# 'vp9_intrapred_test.cc', # MANUAL
+	# 'vp9_denoiser_test.cc', # MANUAL
+)
+
+libvpx_test_optional_sources = {
+	'decoders' : files(
+		# '../webmdec.cc', # MANUAL
+		'decode_api_test.cc',
+		'test_vector_test.cc'
+	),
+	'encoders' : files(
+		'altref_test.cc',
+		'aq_segment_test.cc',
+		'alt_ref_aq_segment_test.cc',
+		'vp8_datarate_test.cc',
+		'vp9_datarate_test.cc',
+		'encode_api_test.cc',
+		'error_resilience_test.cc',
+		'realtime_test.cc',
+		'resize_test.cc',
+		'encode_test_driver.cc',
+		# 'sad_test.cc',, # MANUAL
+		# 'sum_squares_test.cc', # MANUAL
+	),
+	'internal_stats' : files(
+		# 'blockiness_test.cc', # MANUAL
+		# 'consistency_test.cc' # MANUAL
+	),
+	'non_greedy_mv' : files(
+		# 'non_greedy_mv_test.cc' # MANUAL
+	),
+	'postproc' : files(
+		# 'add_noise_test.cc', # MANUAL
+		# 'pp_filter_test.cc' # MANUAL
+	),
+	'sse2' : files(
+		# 'vp8_denoiser_sse2_test.cc' # MANUAL
+	),
+	'vp8_decoder' : files(
+		# 'vp8_decrypt_test.cc' # MANUAL
+	),
+	'vp8_encoder' : files(
+		'config_test.cc',
+		'cq_test.cc',
+		'keyframe_test.cc',
+		# 'quantize_test.cc', # MANUAL
+		# 'set_roi.cc', # MANUAL
+		# 'variance_test.cc', # MANUAL
+		# 'vp8_fdct4x4_test.cc' # MANUAL
+	),
+	'vp9_decoder' : files(
+		'byte_alignment_test.cc',
+		'decode_svc_test.cc',
+		'external_frame_buffer_test.cc',
+		'user_priv_test.cc',
+		# 'vp9_skip_loopfilter_test.cc', # MANUAL
+		# 'vp9_decrypt_test.cc', # MANUAL
+		# 'vp9_thread_test.cc' # MANUAL
+	),
+	'vp9_encoder' : files(
+		'active_map_refresh_test.cc',
+		'active_map_test.cc',
+		'borders_test.cc',
+		'cpu_speed_test.cc',
+		'frame_size_tests.cc',
+		'vp9_lossless_test.cc',
+		'vp9_end_to_end_test.cc',
+		'decode_corrupted.cc',
+		'vp9_ethread_test.cc',
+		'vp9_motion_vector_test.cc',
+		'level_test.cc',
+		'svc_datarate_test.cc',
+		'svc_test.cc',
+		'svc_end_to_end_test.cc',
+		'timestamp_test.cc',
+		'vp9_ext_ratectrl_test.cc',
+		# 'avg_test.cc', # MANUAL
+		# 'comp_avg_pred_test.cc', # MANUAL
+		# 'dct16x16_test.cc', # MANUAL
+		# 'dct32x32_test.cc', # MANUAL
+		# 'dct_partial_test.cc', # MANUAL
+		# 'dct_test.cc', # MANUAL
+		# 'fdct8x8_test.cc', # MANUAL
+		# 'hadamard_test.cc', # MANUAL
+		# 'minmax_test.cc', # MANUAL
+		# 'vp9_scale_test.cc', # MANUAL
+		# 'yuv_temporal_filter_test.cc', # MANUAL
+		# 'variance_test.cc', # MANUAL
+		# 'vp9_block_error_test.cc', # MANUAL
+		# 'vp9_quantize_test.cc', # MANUAL
+		# 'vp9_subtract_test.cc', # MANUAL
+		# 'vp9_arf_freq_test.cc' # MANUAL
+	),
+}
+
+libwebm_parser_sources = files(
+	# '../third_party/libwebm/mkvparser/mkvparser.cc', # MANUAL
+	# '../third_party/libwebm/mkvparser/mkvreader.cc', # MANUAL
+)
+
+libwebm_parser_optional_sources = {
+}
+
+simple_encode_test_sources = files(
+)
+
+simple_encode_test_optional_sources = {
+	'rate_ctrl' : files(
+		# 'simple_encode_test.cc' # MANUAL
+	),
+}
+
+test_intra_pred_speed_sources = files(
+	# 'test_intra_pred_speed.cc', # MANUAL
+)
+
+test_intra_pred_speed_optional_sources = {
+}
+
+rc_interface_test_sources = files(
+	# 'test_rc_interface.cc', # MANUAL
+	# 'decode_test_driver.cc', # MANUAL
+)
+
+rc_interface_test_optional_sources = {
+	'encoders' : files(
+		# 'encode_test_driver.cc' # MANUAL
+	),
+	'vp8_encoder' : files(
+		# 'vp8_ratectrl_rtc_test.cc' # MANUAL
+	),
+	'vp9_encoder' : files(
+		# 'vp9_ratectrl_rtc_test.cc' # MANUAL
+	),
+}
+
+libvpx_test_headers_sources = files(
+	'acm_random.h',
+	'bench.h',
+	'buffer.h',
+	'clear_system_state.h',
+	'codec_factory.h',
+	'md5_helper.h',
+	'register_state_check.h',
+	'test_vectors.h',
+	'util.h',
+	'video_source.h',
+	'../md5_utils.h', # MANUAL
+	'../y4minput.h', # MANUAL
+	'decode_test_driver.h',
+	'encode_test_driver.h',
+	'vpx_scale_test.h',
+)
+
+libvpx_test_headers_optional_sources = {
+	'decoders' : files(
+		'ivf_video_source.h',
+		'../tools_common.h',
+		# '../webmdec.h', # MANUAL
+		# 'webm_video_source.h' # MANUAL
+	),
+	'encoders' : files(
+		'i420_video_source.h',
+		'y4m_video_source.h',
+		'yuv_video_source.h'
+	),
+	'vp9_encoder' : files(
+		'svc_test.h',
+		'../vp9/simple_encode.h'
+	),
+}
+
+libwebm_parser_headers_sources = files(
+	# '../third_party/libwebm/mkvparser/mkvparser.h', # MANUAL
+	# '../third_party/libwebm/mkvparser/mkvreader.h', # MANUAL
+	# '../third_party/libwebm/common/webmids.h', # MANUAL
+)
+
+libwebm_parser_headers_optional_sources = {
+}
+
+rc_interface_test_headers_sources = files(
+	# 'decode_test_driver.h', # MANUAL
+	# 'codec_factory.h', # MANUAL
+)
+
+rc_interface_test_headers_optional_sources = {
+	'encoders' : files(
+		'encode_test_driver.h'
+	),
+}
+
+libvpx_test_data_data_sources = [
+]
+
+libvpx_test_data_data_optional_sources = {
+	'encoders' : [
+		'hantro_collage_w352h288.yuv',
+		'hantro_collage_w352h288_nv12.yuv',
+		'hantro_odd.yuv',
+		'desktop_office1.1280_720-020.yuv',
+		'slides_code_term_web_plot.1920_1080.yuv',
+		'desktopqvga.320_240.yuv',
+		'park_joy_90p_10_420_20f.y4m',
+		'park_joy_90p_10_422_20f.y4m',
+		'park_joy_90p_10_444_20f.y4m',
+		'park_joy_90p_10_440.yuv',
+		'park_joy_90p_12_420_20f.y4m',
+		'park_joy_90p_12_422_20f.y4m',
+		'park_joy_90p_12_444_20f.y4m',
+		'park_joy_90p_12_440.yuv',
+		'park_joy_90p_8_420_a10-1.y4m',
+		'park_joy_90p_8_420.y4m',
+		'park_joy_90p_8_422.y4m',
+		'park_joy_90p_8_444.y4m',
+		'park_joy_90p_8_440.yuv'
+	],
+	'vp8_decoder' : [
+		'vp80-00-comprehensive-001.ivf',
+		'vp80-00-comprehensive-001.ivf.md5',
+		'vp80-00-comprehensive-002.ivf',
+		'vp80-00-comprehensive-002.ivf.md5',
+		'vp80-00-comprehensive-003.ivf',
+		'vp80-00-comprehensive-003.ivf.md5',
+		'vp80-00-comprehensive-004.ivf',
+		'vp80-00-comprehensive-004.ivf.md5',
+		'vp80-00-comprehensive-005.ivf',
+		'vp80-00-comprehensive-005.ivf.md5',
+		'vp80-00-comprehensive-006.ivf',
+		'vp80-00-comprehensive-006.ivf.md5',
+		'vp80-00-comprehensive-007.ivf',
+		'vp80-00-comprehensive-007.ivf.md5',
+		'vp80-00-comprehensive-008.ivf',
+		'vp80-00-comprehensive-008.ivf.md5',
+		'vp80-00-comprehensive-009.ivf',
+		'vp80-00-comprehensive-009.ivf.md5',
+		'vp80-00-comprehensive-010.ivf',
+		'vp80-00-comprehensive-010.ivf.md5',
+		'vp80-00-comprehensive-011.ivf',
+		'vp80-00-comprehensive-011.ivf.md5',
+		'vp80-00-comprehensive-012.ivf',
+		'vp80-00-comprehensive-012.ivf.md5',
+		'vp80-00-comprehensive-013.ivf',
+		'vp80-00-comprehensive-013.ivf.md5',
+		'vp80-00-comprehensive-014.ivf',
+		'vp80-00-comprehensive-014.ivf.md5',
+		'vp80-00-comprehensive-015.ivf',
+		'vp80-00-comprehensive-015.ivf.md5',
+		'vp80-00-comprehensive-016.ivf',
+		'vp80-00-comprehensive-016.ivf.md5',
+		'vp80-00-comprehensive-017.ivf',
+		'vp80-00-comprehensive-017.ivf.md5',
+		'vp80-00-comprehensive-018.ivf',
+		'vp80-00-comprehensive-018.ivf.md5',
+		'vp80-01-intra-1400.ivf',
+		'vp80-01-intra-1400.ivf.md5',
+		'vp80-01-intra-1411.ivf',
+		'vp80-01-intra-1411.ivf.md5',
+		'vp80-01-intra-1416.ivf',
+		'vp80-01-intra-1416.ivf.md5',
+		'vp80-01-intra-1417.ivf',
+		'vp80-01-intra-1417.ivf.md5',
+		'vp80-02-inter-1402.ivf',
+		'vp80-02-inter-1402.ivf.md5',
+		'vp80-02-inter-1412.ivf',
+		'vp80-02-inter-1412.ivf.md5',
+		'vp80-02-inter-1418.ivf',
+		'vp80-02-inter-1418.ivf.md5',
+		'vp80-02-inter-1424.ivf',
+		'vp80-02-inter-1424.ivf.md5',
+		'vp80-03-segmentation-01.ivf',
+		'vp80-03-segmentation-01.ivf.md5',
+		'vp80-03-segmentation-02.ivf',
+		'vp80-03-segmentation-02.ivf.md5',
+		'vp80-03-segmentation-03.ivf',
+		'vp80-03-segmentation-03.ivf.md5',
+		'vp80-03-segmentation-04.ivf',
+		'vp80-03-segmentation-04.ivf.md5',
+		'vp80-03-segmentation-1401.ivf',
+		'vp80-03-segmentation-1401.ivf.md5',
+		'vp80-03-segmentation-1403.ivf',
+		'vp80-03-segmentation-1403.ivf.md5',
+		'vp80-03-segmentation-1407.ivf',
+		'vp80-03-segmentation-1407.ivf.md5',
+		'vp80-03-segmentation-1408.ivf',
+		'vp80-03-segmentation-1408.ivf.md5',
+		'vp80-03-segmentation-1409.ivf',
+		'vp80-03-segmentation-1409.ivf.md5',
+		'vp80-03-segmentation-1410.ivf',
+		'vp80-03-segmentation-1410.ivf.md5',
+		'vp80-03-segmentation-1413.ivf',
+		'vp80-03-segmentation-1413.ivf.md5',
+		'vp80-03-segmentation-1414.ivf',
+		'vp80-03-segmentation-1414.ivf.md5',
+		'vp80-03-segmentation-1415.ivf',
+		'vp80-03-segmentation-1415.ivf.md5',
+		'vp80-03-segmentation-1425.ivf',
+		'vp80-03-segmentation-1425.ivf.md5',
+		'vp80-03-segmentation-1426.ivf',
+		'vp80-03-segmentation-1426.ivf.md5',
+		'vp80-03-segmentation-1427.ivf',
+		'vp80-03-segmentation-1427.ivf.md5',
+		'vp80-03-segmentation-1432.ivf',
+		'vp80-03-segmentation-1432.ivf.md5',
+		'vp80-03-segmentation-1435.ivf',
+		'vp80-03-segmentation-1435.ivf.md5',
+		'vp80-03-segmentation-1436.ivf',
+		'vp80-03-segmentation-1436.ivf.md5',
+		'vp80-03-segmentation-1437.ivf',
+		'vp80-03-segmentation-1437.ivf.md5',
+		'vp80-03-segmentation-1441.ivf',
+		'vp80-03-segmentation-1441.ivf.md5',
+		'vp80-03-segmentation-1442.ivf',
+		'vp80-03-segmentation-1442.ivf.md5',
+		'vp80-04-partitions-1404.ivf',
+		'vp80-04-partitions-1404.ivf.md5',
+		'vp80-04-partitions-1405.ivf',
+		'vp80-04-partitions-1405.ivf.md5',
+		'vp80-04-partitions-1406.ivf',
+		'vp80-04-partitions-1406.ivf.md5',
+		'vp80-05-sharpness-1428.ivf',
+		'vp80-05-sharpness-1428.ivf.md5',
+		'vp80-05-sharpness-1429.ivf',
+		'vp80-05-sharpness-1429.ivf.md5',
+		'vp80-05-sharpness-1430.ivf',
+		'vp80-05-sharpness-1430.ivf.md5',
+		'vp80-05-sharpness-1431.ivf',
+		'vp80-05-sharpness-1431.ivf.md5',
+		'vp80-05-sharpness-1433.ivf',
+		'vp80-05-sharpness-1433.ivf.md5',
+		'vp80-05-sharpness-1434.ivf',
+		'vp80-05-sharpness-1434.ivf.md5',
+		'vp80-05-sharpness-1438.ivf',
+		'vp80-05-sharpness-1438.ivf.md5',
+		'vp80-05-sharpness-1439.ivf',
+		'vp80-05-sharpness-1439.ivf.md5',
+		'vp80-05-sharpness-1440.ivf',
+		'vp80-05-sharpness-1440.ivf.md5',
+		'vp80-05-sharpness-1443.ivf',
+		'vp80-05-sharpness-1443.ivf.md5',
+		'vp80-06-smallsize.ivf',
+		'vp80-06-smallsize.ivf.md5',
+		'invalid-bug-1443.ivf',
+		'invalid-bug-1443.ivf.res',
+		'invalid-bug-148271109.ivf',
+		'invalid-bug-148271109.ivf.res',
+		'invalid-token-partition.ivf',
+		'invalid-token-partition.ivf.res',
+		'invalid-vp80-00-comprehensive-018.ivf.2kf_0x6.ivf',
+		'invalid-vp80-00-comprehensive-018.ivf.2kf_0x6.ivf.res',
+		'invalid-vp80-00-comprehensive-s17661_r01-05_b6-.ivf',
+		'invalid-vp80-00-comprehensive-s17661_r01-05_b6-.ivf.res'
+	],
+	'vp9_decoder' : [
+		'vp90-2-00-quantizer-00.webm',
+		'vp90-2-00-quantizer-00.webm.md5',
+		'vp90-2-00-quantizer-01.webm',
+		'vp90-2-00-quantizer-01.webm.md5',
+		'vp90-2-00-quantizer-02.webm',
+		'vp90-2-00-quantizer-02.webm.md5',
+		'vp90-2-00-quantizer-03.webm',
+		'vp90-2-00-quantizer-03.webm.md5',
+		'vp90-2-00-quantizer-04.webm',
+		'vp90-2-00-quantizer-04.webm.md5',
+		'vp90-2-00-quantizer-05.webm',
+		'vp90-2-00-quantizer-05.webm.md5',
+		'vp90-2-00-quantizer-06.webm',
+		'vp90-2-00-quantizer-06.webm.md5',
+		'vp90-2-00-quantizer-07.webm',
+		'vp90-2-00-quantizer-07.webm.md5',
+		'vp90-2-00-quantizer-08.webm',
+		'vp90-2-00-quantizer-08.webm.md5',
+		'vp90-2-00-quantizer-09.webm',
+		'vp90-2-00-quantizer-09.webm.md5',
+		'vp90-2-00-quantizer-10.webm',
+		'vp90-2-00-quantizer-10.webm.md5',
+		'vp90-2-00-quantizer-11.webm',
+		'vp90-2-00-quantizer-11.webm.md5',
+		'vp90-2-00-quantizer-12.webm',
+		'vp90-2-00-quantizer-12.webm.md5',
+		'vp90-2-00-quantizer-13.webm',
+		'vp90-2-00-quantizer-13.webm.md5',
+		'vp90-2-00-quantizer-14.webm',
+		'vp90-2-00-quantizer-14.webm.md5',
+		'vp90-2-00-quantizer-15.webm',
+		'vp90-2-00-quantizer-15.webm.md5',
+		'vp90-2-00-quantizer-16.webm',
+		'vp90-2-00-quantizer-16.webm.md5',
+		'vp90-2-00-quantizer-17.webm',
+		'vp90-2-00-quantizer-17.webm.md5',
+		'vp90-2-00-quantizer-18.webm',
+		'vp90-2-00-quantizer-18.webm.md5',
+		'vp90-2-00-quantizer-19.webm',
+		'vp90-2-00-quantizer-19.webm.md5',
+		'vp90-2-00-quantizer-20.webm',
+		'vp90-2-00-quantizer-20.webm.md5',
+		'vp90-2-00-quantizer-21.webm',
+		'vp90-2-00-quantizer-21.webm.md5',
+		'vp90-2-00-quantizer-22.webm',
+		'vp90-2-00-quantizer-22.webm.md5',
+		'vp90-2-00-quantizer-23.webm',
+		'vp90-2-00-quantizer-23.webm.md5',
+		'vp90-2-00-quantizer-24.webm',
+		'vp90-2-00-quantizer-24.webm.md5',
+		'vp90-2-00-quantizer-25.webm',
+		'vp90-2-00-quantizer-25.webm.md5',
+		'vp90-2-00-quantizer-26.webm',
+		'vp90-2-00-quantizer-26.webm.md5',
+		'vp90-2-00-quantizer-27.webm',
+		'vp90-2-00-quantizer-27.webm.md5',
+		'vp90-2-00-quantizer-28.webm',
+		'vp90-2-00-quantizer-28.webm.md5',
+		'vp90-2-00-quantizer-29.webm',
+		'vp90-2-00-quantizer-29.webm.md5',
+		'vp90-2-00-quantizer-30.webm',
+		'vp90-2-00-quantizer-30.webm.md5',
+		'vp90-2-00-quantizer-31.webm',
+		'vp90-2-00-quantizer-31.webm.md5',
+		'vp90-2-00-quantizer-32.webm',
+		'vp90-2-00-quantizer-32.webm.md5',
+		'vp90-2-00-quantizer-33.webm',
+		'vp90-2-00-quantizer-33.webm.md5',
+		'vp90-2-00-quantizer-34.webm',
+		'vp90-2-00-quantizer-34.webm.md5',
+		'vp90-2-00-quantizer-35.webm',
+		'vp90-2-00-quantizer-35.webm.md5',
+		'vp90-2-00-quantizer-36.webm',
+		'vp90-2-00-quantizer-36.webm.md5',
+		'vp90-2-00-quantizer-37.webm',
+		'vp90-2-00-quantizer-37.webm.md5',
+		'vp90-2-00-quantizer-38.webm',
+		'vp90-2-00-quantizer-38.webm.md5',
+		'vp90-2-00-quantizer-39.webm',
+		'vp90-2-00-quantizer-39.webm.md5',
+		'vp90-2-00-quantizer-40.webm',
+		'vp90-2-00-quantizer-40.webm.md5',
+		'vp90-2-00-quantizer-41.webm',
+		'vp90-2-00-quantizer-41.webm.md5',
+		'vp90-2-00-quantizer-42.webm',
+		'vp90-2-00-quantizer-42.webm.md5',
+		'vp90-2-00-quantizer-43.webm',
+		'vp90-2-00-quantizer-43.webm.md5',
+		'vp90-2-00-quantizer-44.webm',
+		'vp90-2-00-quantizer-44.webm.md5',
+		'vp90-2-00-quantizer-45.webm',
+		'vp90-2-00-quantizer-45.webm.md5',
+		'vp90-2-00-quantizer-46.webm',
+		'vp90-2-00-quantizer-46.webm.md5',
+		'vp90-2-00-quantizer-47.webm',
+		'vp90-2-00-quantizer-47.webm.md5',
+		'vp90-2-00-quantizer-48.webm',
+		'vp90-2-00-quantizer-48.webm.md5',
+		'vp90-2-00-quantizer-49.webm',
+		'vp90-2-00-quantizer-49.webm.md5',
+		'vp90-2-00-quantizer-50.webm',
+		'vp90-2-00-quantizer-50.webm.md5',
+		'vp90-2-00-quantizer-51.webm',
+		'vp90-2-00-quantizer-51.webm.md5',
+		'vp90-2-00-quantizer-52.webm',
+		'vp90-2-00-quantizer-52.webm.md5',
+		'vp90-2-00-quantizer-53.webm',
+		'vp90-2-00-quantizer-53.webm.md5',
+		'vp90-2-00-quantizer-54.webm',
+		'vp90-2-00-quantizer-54.webm.md5',
+		'vp90-2-00-quantizer-55.webm',
+		'vp90-2-00-quantizer-55.webm.md5',
+		'vp90-2-00-quantizer-56.webm',
+		'vp90-2-00-quantizer-56.webm.md5',
+		'vp90-2-00-quantizer-57.webm',
+		'vp90-2-00-quantizer-57.webm.md5',
+		'vp90-2-00-quantizer-58.webm',
+		'vp90-2-00-quantizer-58.webm.md5',
+		'vp90-2-00-quantizer-59.webm',
+		'vp90-2-00-quantizer-59.webm.md5',
+		'vp90-2-00-quantizer-60.webm',
+		'vp90-2-00-quantizer-60.webm.md5',
+		'vp90-2-00-quantizer-61.webm',
+		'vp90-2-00-quantizer-61.webm.md5',
+		'vp90-2-00-quantizer-62.webm',
+		'vp90-2-00-quantizer-62.webm.md5',
+		'vp90-2-00-quantizer-63.webm',
+		'vp90-2-00-quantizer-63.webm.md5',
+		'vp90-2-01-sharpness-1.webm',
+		'vp90-2-01-sharpness-1.webm.md5',
+		'vp90-2-01-sharpness-2.webm',
+		'vp90-2-01-sharpness-2.webm.md5',
+		'vp90-2-01-sharpness-3.webm',
+		'vp90-2-01-sharpness-3.webm.md5',
+		'vp90-2-01-sharpness-4.webm',
+		'vp90-2-01-sharpness-4.webm.md5',
+		'vp90-2-01-sharpness-5.webm',
+		'vp90-2-01-sharpness-5.webm.md5',
+		'vp90-2-01-sharpness-6.webm',
+		'vp90-2-01-sharpness-6.webm.md5',
+		'vp90-2-01-sharpness-7.webm',
+		'vp90-2-01-sharpness-7.webm.md5',
+		'vp90-2-02-size-08x08.webm',
+		'vp90-2-02-size-08x08.webm.md5',
+		'vp90-2-02-size-08x10.webm',
+		'vp90-2-02-size-08x10.webm.md5',
+		'vp90-2-02-size-08x16.webm',
+		'vp90-2-02-size-08x16.webm.md5',
+		'vp90-2-02-size-08x18.webm',
+		'vp90-2-02-size-08x18.webm.md5',
+		'vp90-2-02-size-08x32.webm',
+		'vp90-2-02-size-08x32.webm.md5',
+		'vp90-2-02-size-08x34.webm',
+		'vp90-2-02-size-08x34.webm.md5',
+		'vp90-2-02-size-08x64.webm',
+		'vp90-2-02-size-08x64.webm.md5',
+		'vp90-2-02-size-08x66.webm',
+		'vp90-2-02-size-08x66.webm.md5',
+		'vp90-2-02-size-10x08.webm',
+		'vp90-2-02-size-10x08.webm.md5',
+		'vp90-2-02-size-10x10.webm',
+		'vp90-2-02-size-10x10.webm.md5',
+		'vp90-2-02-size-10x16.webm',
+		'vp90-2-02-size-10x16.webm.md5',
+		'vp90-2-02-size-10x18.webm',
+		'vp90-2-02-size-10x18.webm.md5',
+		'vp90-2-02-size-10x32.webm',
+		'vp90-2-02-size-10x32.webm.md5',
+		'vp90-2-02-size-10x34.webm',
+		'vp90-2-02-size-10x34.webm.md5',
+		'vp90-2-02-size-10x64.webm',
+		'vp90-2-02-size-10x64.webm.md5',
+		'vp90-2-02-size-10x66.webm',
+		'vp90-2-02-size-10x66.webm.md5',
+		'vp90-2-02-size-16x08.webm',
+		'vp90-2-02-size-16x08.webm.md5',
+		'vp90-2-02-size-16x10.webm',
+		'vp90-2-02-size-16x10.webm.md5',
+		'vp90-2-02-size-16x16.webm',
+		'vp90-2-02-size-16x16.webm.md5',
+		'vp90-2-02-size-16x18.webm',
+		'vp90-2-02-size-16x18.webm.md5',
+		'vp90-2-02-size-16x32.webm',
+		'vp90-2-02-size-16x32.webm.md5',
+		'vp90-2-02-size-16x34.webm',
+		'vp90-2-02-size-16x34.webm.md5',
+		'vp90-2-02-size-16x64.webm',
+		'vp90-2-02-size-16x64.webm.md5',
+		'vp90-2-02-size-16x66.webm',
+		'vp90-2-02-size-16x66.webm.md5',
+		'vp90-2-02-size-18x08.webm',
+		'vp90-2-02-size-18x08.webm.md5',
+		'vp90-2-02-size-18x10.webm',
+		'vp90-2-02-size-18x10.webm.md5',
+		'vp90-2-02-size-18x16.webm',
+		'vp90-2-02-size-18x16.webm.md5',
+		'vp90-2-02-size-18x18.webm',
+		'vp90-2-02-size-18x18.webm.md5',
+		'vp90-2-02-size-18x32.webm',
+		'vp90-2-02-size-18x32.webm.md5',
+		'vp90-2-02-size-18x34.webm',
+		'vp90-2-02-size-18x34.webm.md5',
+		'vp90-2-02-size-18x64.webm',
+		'vp90-2-02-size-18x64.webm.md5',
+		'vp90-2-02-size-18x66.webm',
+		'vp90-2-02-size-18x66.webm.md5',
+		'vp90-2-02-size-32x08.webm',
+		'vp90-2-02-size-32x08.webm.md5',
+		'vp90-2-02-size-32x10.webm',
+		'vp90-2-02-size-32x10.webm.md5',
+		'vp90-2-02-size-32x16.webm',
+		'vp90-2-02-size-32x16.webm.md5',
+		'vp90-2-02-size-32x18.webm',
+		'vp90-2-02-size-32x18.webm.md5',
+		'vp90-2-02-size-32x32.webm',
+		'vp90-2-02-size-32x32.webm.md5',
+		'vp90-2-02-size-32x34.webm',
+		'vp90-2-02-size-32x34.webm.md5',
+		'vp90-2-02-size-32x64.webm',
+		'vp90-2-02-size-32x64.webm.md5',
+		'vp90-2-02-size-32x66.webm',
+		'vp90-2-02-size-32x66.webm.md5',
+		'vp90-2-02-size-34x08.webm',
+		'vp90-2-02-size-34x08.webm.md5',
+		'vp90-2-02-size-34x10.webm',
+		'vp90-2-02-size-34x10.webm.md5',
+		'vp90-2-02-size-34x16.webm',
+		'vp90-2-02-size-34x16.webm.md5',
+		'vp90-2-02-size-34x18.webm',
+		'vp90-2-02-size-34x18.webm.md5',
+		'vp90-2-02-size-34x32.webm',
+		'vp90-2-02-size-34x32.webm.md5',
+		'vp90-2-02-size-34x34.webm',
+		'vp90-2-02-size-34x34.webm.md5',
+		'vp90-2-02-size-34x64.webm',
+		'vp90-2-02-size-34x64.webm.md5',
+		'vp90-2-02-size-34x66.webm',
+		'vp90-2-02-size-34x66.webm.md5',
+		'vp90-2-02-size-64x08.webm',
+		'vp90-2-02-size-64x08.webm.md5',
+		'vp90-2-02-size-64x10.webm',
+		'vp90-2-02-size-64x10.webm.md5',
+		'vp90-2-02-size-64x16.webm',
+		'vp90-2-02-size-64x16.webm.md5',
+		'vp90-2-02-size-64x18.webm',
+		'vp90-2-02-size-64x18.webm.md5',
+		'vp90-2-02-size-64x32.webm',
+		'vp90-2-02-size-64x32.webm.md5',
+		'vp90-2-02-size-64x34.webm',
+		'vp90-2-02-size-64x34.webm.md5',
+		'vp90-2-02-size-64x64.webm',
+		'vp90-2-02-size-64x64.webm.md5',
+		'vp90-2-02-size-64x66.webm',
+		'vp90-2-02-size-64x66.webm.md5',
+		'vp90-2-02-size-66x08.webm',
+		'vp90-2-02-size-66x08.webm.md5',
+		'vp90-2-02-size-66x10.webm',
+		'vp90-2-02-size-66x10.webm.md5',
+		'vp90-2-02-size-66x16.webm',
+		'vp90-2-02-size-66x16.webm.md5',
+		'vp90-2-02-size-66x18.webm',
+		'vp90-2-02-size-66x18.webm.md5',
+		'vp90-2-02-size-66x32.webm',
+		'vp90-2-02-size-66x32.webm.md5',
+		'vp90-2-02-size-66x34.webm',
+		'vp90-2-02-size-66x34.webm.md5',
+		'vp90-2-02-size-66x64.webm',
+		'vp90-2-02-size-66x64.webm.md5',
+		'vp90-2-02-size-66x66.webm',
+		'vp90-2-02-size-66x66.webm.md5',
+		'vp90-2-02-size-130x132.webm',
+		'vp90-2-02-size-130x132.webm.md5',
+		'vp90-2-02-size-132x130.webm',
+		'vp90-2-02-size-132x130.webm.md5',
+		'vp90-2-02-size-132x132.webm',
+		'vp90-2-02-size-132x132.webm.md5',
+		'vp90-2-02-size-178x180.webm',
+		'vp90-2-02-size-178x180.webm.md5',
+		'vp90-2-02-size-180x178.webm',
+		'vp90-2-02-size-180x178.webm.md5',
+		'vp90-2-02-size-180x180.webm',
+		'vp90-2-02-size-180x180.webm.md5',
+		'vp90-2-02-size-lf-1920x1080.webm',
+		'vp90-2-02-size-lf-1920x1080.webm.md5',
+		'vp90-2-03-deltaq.webm',
+		'vp90-2-03-deltaq.webm.md5',
+		'vp90-2-03-size-196x196.webm',
+		'vp90-2-03-size-196x196.webm.md5',
+		'vp90-2-03-size-196x198.webm',
+		'vp90-2-03-size-196x198.webm.md5',
+		'vp90-2-03-size-196x200.webm',
+		'vp90-2-03-size-196x200.webm.md5',
+		'vp90-2-03-size-196x202.webm',
+		'vp90-2-03-size-196x202.webm.md5',
+		'vp90-2-03-size-196x208.webm',
+		'vp90-2-03-size-196x208.webm.md5',
+		'vp90-2-03-size-196x210.webm',
+		'vp90-2-03-size-196x210.webm.md5',
+		'vp90-2-03-size-196x224.webm',
+		'vp90-2-03-size-196x224.webm.md5',
+		'vp90-2-03-size-196x226.webm',
+		'vp90-2-03-size-196x226.webm.md5',
+		'vp90-2-03-size-198x196.webm',
+		'vp90-2-03-size-198x196.webm.md5',
+		'vp90-2-03-size-198x198.webm',
+		'vp90-2-03-size-198x198.webm.md5',
+		'vp90-2-03-size-198x200.webm',
+		'vp90-2-03-size-198x200.webm.md5',
+		'vp90-2-03-size-198x202.webm',
+		'vp90-2-03-size-198x202.webm.md5',
+		'vp90-2-03-size-198x208.webm',
+		'vp90-2-03-size-198x208.webm.md5',
+		'vp90-2-03-size-198x210.webm',
+		'vp90-2-03-size-198x210.webm.md5',
+		'vp90-2-03-size-198x224.webm',
+		'vp90-2-03-size-198x224.webm.md5',
+		'vp90-2-03-size-198x226.webm',
+		'vp90-2-03-size-198x226.webm.md5',
+		'vp90-2-03-size-200x196.webm',
+		'vp90-2-03-size-200x196.webm.md5',
+		'vp90-2-03-size-200x198.webm',
+		'vp90-2-03-size-200x198.webm.md5',
+		'vp90-2-03-size-200x200.webm',
+		'vp90-2-03-size-200x200.webm.md5',
+		'vp90-2-03-size-200x202.webm',
+		'vp90-2-03-size-200x202.webm.md5',
+		'vp90-2-03-size-200x208.webm',
+		'vp90-2-03-size-200x208.webm.md5',
+		'vp90-2-03-size-200x210.webm',
+		'vp90-2-03-size-200x210.webm.md5',
+		'vp90-2-03-size-200x224.webm',
+		'vp90-2-03-size-200x224.webm.md5',
+		'vp90-2-03-size-200x226.webm',
+		'vp90-2-03-size-200x226.webm.md5',
+		'vp90-2-03-size-202x196.webm',
+		'vp90-2-03-size-202x196.webm.md5',
+		'vp90-2-03-size-202x198.webm',
+		'vp90-2-03-size-202x198.webm.md5',
+		'vp90-2-03-size-202x200.webm',
+		'vp90-2-03-size-202x200.webm.md5',
+		'vp90-2-03-size-202x202.webm',
+		'vp90-2-03-size-202x202.webm.md5',
+		'vp90-2-03-size-202x208.webm',
+		'vp90-2-03-size-202x208.webm.md5',
+		'vp90-2-03-size-202x210.webm',
+		'vp90-2-03-size-202x210.webm.md5',
+		'vp90-2-03-size-202x224.webm',
+		'vp90-2-03-size-202x224.webm.md5',
+		'vp90-2-03-size-202x226.webm',
+		'vp90-2-03-size-202x226.webm.md5',
+		'vp90-2-03-size-208x196.webm',
+		'vp90-2-03-size-208x196.webm.md5',
+		'vp90-2-03-size-208x198.webm',
+		'vp90-2-03-size-208x198.webm.md5',
+		'vp90-2-03-size-208x200.webm',
+		'vp90-2-03-size-208x200.webm.md5',
+		'vp90-2-03-size-208x202.webm',
+		'vp90-2-03-size-208x202.webm.md5',
+		'vp90-2-03-size-208x208.webm',
+		'vp90-2-03-size-208x208.webm.md5',
+		'vp90-2-03-size-208x210.webm',
+		'vp90-2-03-size-208x210.webm.md5',
+		'vp90-2-03-size-208x224.webm',
+		'vp90-2-03-size-208x224.webm.md5',
+		'vp90-2-03-size-208x226.webm',
+		'vp90-2-03-size-208x226.webm.md5',
+		'vp90-2-03-size-210x196.webm',
+		'vp90-2-03-size-210x196.webm.md5',
+		'vp90-2-03-size-210x198.webm',
+		'vp90-2-03-size-210x198.webm.md5',
+		'vp90-2-03-size-210x200.webm',
+		'vp90-2-03-size-210x200.webm.md5',
+		'vp90-2-03-size-210x202.webm',
+		'vp90-2-03-size-210x202.webm.md5',
+		'vp90-2-03-size-210x208.webm',
+		'vp90-2-03-size-210x208.webm.md5',
+		'vp90-2-03-size-210x210.webm',
+		'vp90-2-03-size-210x210.webm.md5',
+		'vp90-2-03-size-210x224.webm',
+		'vp90-2-03-size-210x224.webm.md5',
+		'vp90-2-03-size-210x226.webm',
+		'vp90-2-03-size-210x226.webm.md5',
+		'vp90-2-03-size-224x196.webm',
+		'vp90-2-03-size-224x196.webm.md5',
+		'vp90-2-03-size-224x198.webm',
+		'vp90-2-03-size-224x198.webm.md5',
+		'vp90-2-03-size-224x200.webm',
+		'vp90-2-03-size-224x200.webm.md5',
+		'vp90-2-03-size-224x202.webm',
+		'vp90-2-03-size-224x202.webm.md5',
+		'vp90-2-03-size-224x208.webm',
+		'vp90-2-03-size-224x208.webm.md5',
+		'vp90-2-03-size-224x210.webm',
+		'vp90-2-03-size-224x210.webm.md5',
+		'vp90-2-03-size-224x224.webm',
+		'vp90-2-03-size-224x224.webm.md5',
+		'vp90-2-03-size-224x226.webm',
+		'vp90-2-03-size-224x226.webm.md5',
+		'vp90-2-03-size-226x196.webm',
+		'vp90-2-03-size-226x196.webm.md5',
+		'vp90-2-03-size-226x198.webm',
+		'vp90-2-03-size-226x198.webm.md5',
+		'vp90-2-03-size-226x200.webm',
+		'vp90-2-03-size-226x200.webm.md5',
+		'vp90-2-03-size-226x202.webm',
+		'vp90-2-03-size-226x202.webm.md5',
+		'vp90-2-03-size-226x208.webm',
+		'vp90-2-03-size-226x208.webm.md5',
+		'vp90-2-03-size-226x210.webm',
+		'vp90-2-03-size-226x210.webm.md5',
+		'vp90-2-03-size-226x224.webm',
+		'vp90-2-03-size-226x224.webm.md5',
+		'vp90-2-03-size-226x226.webm',
+		'vp90-2-03-size-226x226.webm.md5',
+		'vp90-2-03-size-352x288.webm',
+		'vp90-2-03-size-352x288.webm.md5',
+		'vp90-2-05-resize.ivf',
+		'vp90-2-05-resize.ivf.md5',
+		'vp90-2-06-bilinear.webm',
+		'vp90-2-06-bilinear.webm.md5',
+		'vp90-2-07-frame_parallel.webm',
+		'vp90-2-07-frame_parallel.webm.md5',
+		'vp90-2-07-frame_parallel-1.webm',
+		'vp90-2-07-frame_parallel-1.webm.md5',
+		'vp90-2-08-tile-4x1.webm',
+		'vp90-2-08-tile-4x1.webm.md5',
+		'vp90-2-08-tile-4x4.webm',
+		'vp90-2-08-tile-4x4.webm.md5',
+		'vp90-2-08-tile_1x2.webm',
+		'vp90-2-08-tile_1x2.webm.md5',
+		'vp90-2-08-tile_1x2_frame_parallel.webm',
+		'vp90-2-08-tile_1x2_frame_parallel.webm.md5',
+		'vp90-2-08-tile_1x4.webm',
+		'vp90-2-08-tile_1x4.webm.md5',
+		'vp90-2-08-tile_1x4_frame_parallel.webm',
+		'vp90-2-08-tile_1x4_frame_parallel.webm.md5',
+		'vp90-2-08-tile_1x8.webm',
+		'vp90-2-08-tile_1x8.webm.md5',
+		'vp90-2-08-tile_1x8_frame_parallel.webm',
+		'vp90-2-08-tile_1x8_frame_parallel.webm.md5',
+		'vp90-2-09-aq2.webm',
+		'vp90-2-09-aq2.webm.md5',
+		'vp90-2-09-lf_deltas.webm',
+		'vp90-2-09-lf_deltas.webm.md5',
+		'vp90-2-09-subpixel-00.ivf',
+		'vp90-2-09-subpixel-00.ivf.md5',
+		'vp90-2-10-show-existing-frame.webm',
+		'vp90-2-10-show-existing-frame.webm.md5',
+		'vp90-2-10-show-existing-frame2.webm',
+		'vp90-2-10-show-existing-frame2.webm.md5',
+		'vp90-2-11-size-351x287.webm',
+		'vp90-2-11-size-351x287.webm.md5',
+		'vp90-2-11-size-351x288.webm',
+		'vp90-2-11-size-351x288.webm.md5',
+		'vp90-2-11-size-352x287.webm',
+		'vp90-2-11-size-352x287.webm.md5',
+		'vp90-2-12-droppable_1.ivf',
+		'vp90-2-12-droppable_1.ivf.md5',
+		'vp90-2-12-droppable_2.ivf',
+		'vp90-2-12-droppable_2.ivf.md5',
+		'vp90-2-12-droppable_3.ivf',
+		'vp90-2-12-droppable_3.ivf.md5',
+		'vp90-2-13-largescaling.webm',
+		'vp90-2-13-largescaling.webm.md5',
+		'vp90-2-14-resize-fp-tiles-1-16.webm',
+		'vp90-2-14-resize-fp-tiles-1-16.webm.md5',
+		'vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm',
+		'vp90-2-14-resize-fp-tiles-1-2-4-8-16.webm.md5',
+		'vp90-2-14-resize-fp-tiles-1-2.webm',
+		'vp90-2-14-resize-fp-tiles-1-2.webm.md5',
+		'vp90-2-14-resize-fp-tiles-1-4.webm',
+		'vp90-2-14-resize-fp-tiles-1-4.webm.md5',
+		'vp90-2-14-resize-fp-tiles-1-8.webm',
+		'vp90-2-14-resize-fp-tiles-1-8.webm.md5',
+		'vp90-2-14-resize-fp-tiles-16-1.webm',
+		'vp90-2-14-resize-fp-tiles-16-1.webm.md5',
+		'vp90-2-14-resize-fp-tiles-16-2.webm',
+		'vp90-2-14-resize-fp-tiles-16-2.webm.md5',
+		'vp90-2-14-resize-fp-tiles-16-4.webm',
+		'vp90-2-14-resize-fp-tiles-16-4.webm.md5',
+		'vp90-2-14-resize-fp-tiles-16-8-4-2-1.webm',
+		'vp90-2-14-resize-fp-tiles-16-8-4-2-1.webm.md5',
+		'vp90-2-14-resize-fp-tiles-16-8.webm',
+		'vp90-2-14-resize-fp-tiles-16-8.webm.md5',
+		'vp90-2-14-resize-fp-tiles-2-1.webm',
+		'vp90-2-14-resize-fp-tiles-2-1.webm.md5',
+		'vp90-2-14-resize-fp-tiles-2-16.webm',
+		'vp90-2-14-resize-fp-tiles-2-16.webm.md5',
+		'vp90-2-14-resize-fp-tiles-2-4.webm',
+		'vp90-2-14-resize-fp-tiles-2-4.webm.md5',
+		'vp90-2-14-resize-fp-tiles-2-8.webm',
+		'vp90-2-14-resize-fp-tiles-2-8.webm.md5',
+		'vp90-2-14-resize-fp-tiles-4-1.webm',
+		'vp90-2-14-resize-fp-tiles-4-1.webm.md5',
+		'vp90-2-14-resize-fp-tiles-4-16.webm',
+		'vp90-2-14-resize-fp-tiles-4-16.webm.md5',
+		'vp90-2-14-resize-fp-tiles-4-2.webm',
+		'vp90-2-14-resize-fp-tiles-4-2.webm.md5',
+		'vp90-2-14-resize-fp-tiles-4-8.webm',
+		'vp90-2-14-resize-fp-tiles-4-8.webm.md5',
+		'vp90-2-14-resize-fp-tiles-8-1.webm',
+		'vp90-2-14-resize-fp-tiles-8-1.webm.md5',
+		'vp90-2-14-resize-fp-tiles-8-16.webm',
+		'vp90-2-14-resize-fp-tiles-8-16.webm.md5',
+		'vp90-2-14-resize-fp-tiles-8-2.webm',
+		'vp90-2-14-resize-fp-tiles-8-2.webm.md5',
+		'vp90-2-14-resize-fp-tiles-8-4.webm',
+		'vp90-2-14-resize-fp-tiles-8-4.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-1-2-4-8.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-1-2-4-8.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-1-2.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-1-2.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-1-4.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-1-4.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-1-8.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-1-8.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-2-1.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-2-1.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-2-4.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-2-4.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-2-8.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-2-8.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-4-1.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-4-1.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-4-2.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-4-2.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-4-8.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-4-8.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-8-1.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-8-1.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-8-2.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-8-2.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-8-4-2-1.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-8-4-2-1.webm.md5',
+		'vp90-2-14-resize-10frames-fp-tiles-8-4.webm',
+		'vp90-2-14-resize-10frames-fp-tiles-8-4.webm.md5',
+		'vp90-2-15-segkey.webm',
+		'vp90-2-15-segkey.webm.md5',
+		'vp90-2-15-segkey_adpq.webm',
+		'vp90-2-15-segkey_adpq.webm.md5',
+		'vp90-2-16-intra-only.webm',
+		'vp90-2-16-intra-only.webm.md5',
+		'vp90-2-17-show-existing-frame.webm',
+		'vp90-2-17-show-existing-frame.webm.md5',
+		'vp90-2-18-resize.ivf',
+		'vp90-2-18-resize.ivf.md5',
+		'vp90-2-19-skip.webm',
+		'vp90-2-19-skip.webm.md5',
+		'vp90-2-19-skip-01.webm',
+		'vp90-2-19-skip-01.webm.md5',
+		'vp90-2-19-skip-02.webm',
+		'vp90-2-19-skip-02.webm.md5',
+		'vp91-2-04-yuv422.webm',
+		'vp91-2-04-yuv422.webm.md5',
+		'vp91-2-04-yuv440.webm',
+		'vp91-2-04-yuv440.webm.md5',
+		'vp91-2-04-yuv444.webm',
+		'vp91-2-04-yuv444.webm.md5',
+		'vp90-2-20-big_superframe-01.webm',
+		'vp90-2-20-big_superframe-01.webm.md5',
+		'vp90-2-20-big_superframe-02.webm',
+		'vp90-2-20-big_superframe-02.webm.md5',
+		# 'vp92-2-20-10bit-yuv420.webm', # MANUAL
+		# 'vp92-2-20-10bit-yuv420.webm.md5', # MANUAL
+		# 'vp92-2-20-12bit-yuv420.webm', # MANUAL
+		# 'vp92-2-20-12bit-yuv420.webm.md5', # MANUAL
+		# 'vp93-2-20-10bit-yuv422.webm', # MANUAL
+		# 'vp93-2-20-10bit-yuv422.webm.md5', # MANUAL
+		# 'vp93-2-20-12bit-yuv422.webm', # MANUAL
+		# 'vp93-2-20-12bit-yuv422.webm.md5', # MANUAL
+		# 'vp93-2-20-10bit-yuv440.webm', # MANUAL
+		# 'vp93-2-20-10bit-yuv440.webm.md5', # MANUAL
+		# 'vp93-2-20-12bit-yuv440.webm', # MANUAL
+		# 'vp93-2-20-12bit-yuv440.webm.md5', # MANUAL
+		# 'vp93-2-20-10bit-yuv444.webm', # MANUAL
+		# 'vp93-2-20-10bit-yuv444.webm.md5', # MANUAL
+		# 'vp93-2-20-12bit-yuv444.webm', # MANUAL
+		# 'vp93-2-20-12bit-yuv444.webm.md5', # MANUAL
+		'invalid-vp90-01-v3.webm',
+		'invalid-vp90-01-v3.webm.res',
+		'invalid-vp90-02-v2.webm',
+		'invalid-vp90-02-v2.webm.res',
+		'invalid-vp90-03-v3.webm',
+		'invalid-vp90-03-v3.webm.res',
+		'invalid-vp90-2-00-quantizer-00.webm.ivf.s5861_r01-05_b6-.v2.ivf',
+		'invalid-vp90-2-00-quantizer-00.webm.ivf.s5861_r01-05_b6-.v2.ivf.res',
+		'invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-.ivf',
+		'invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-.ivf.res',
+		'invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-z.ivf',
+		'invalid-vp90-2-00-quantizer-11.webm.ivf.s52984_r01-05_b6-z.ivf.res',
+		'invalid-vp90-2-00-quantizer-63.ivf.kf_65527x61446.ivf',
+		'invalid-vp90-2-00-quantizer-63.ivf.kf_65527x61446.ivf.res',
+		'invalid-vp90-2-03-size-202x210.webm.ivf.s113306_r01-05_b6-.ivf',
+		'invalid-vp90-2-03-size-202x210.webm.ivf.s113306_r01-05_b6-.ivf.res',
+		'invalid-vp90-2-03-size-224x196.webm.ivf.s44156_r01-05_b6-.ivf',
+		'invalid-vp90-2-03-size-224x196.webm.ivf.s44156_r01-05_b6-.ivf.res',
+		'invalid-vp90-2-05-resize.ivf.s59293_r01-05_b6-.ivf',
+		'invalid-vp90-2-05-resize.ivf.s59293_r01-05_b6-.ivf.res',
+		'invalid-vp90-2-08-tile_1x2_frame_parallel.webm.ivf.s47039_r01-05_b6-.ivf',
+		'invalid-vp90-2-08-tile_1x2_frame_parallel.webm.ivf.s47039_r01-05_b6-.ivf.res',
+		'invalid-vp90-2-08-tile_1x8_frame_parallel.webm.ivf.s288_r01-05_b6-.ivf',
+		'invalid-vp90-2-08-tile_1x8_frame_parallel.webm.ivf.s288_r01-05_b6-.ivf.res',
+		'invalid-vp90-2-08-tile_1x4_frame_parallel_all_key.webm',
+		'invalid-vp90-2-08-tile_1x4_frame_parallel_all_key.webm.res',
+		'invalid-vp90-2-09-aq2.webm.ivf.s3984_r01-05_b6-.v2.ivf',
+		'invalid-vp90-2-09-aq2.webm.ivf.s3984_r01-05_b6-.v2.ivf.res',
+		'invalid-vp90-2-09-subpixel-00.ivf.s19552_r01-05_b6-.v2.ivf',
+		'invalid-vp90-2-09-subpixel-00.ivf.s19552_r01-05_b6-.v2.ivf.res',
+		'invalid-vp90-2-09-subpixel-00.ivf.s20492_r01-05_b6-.v2.ivf',
+		'invalid-vp90-2-09-subpixel-00.ivf.s20492_r01-05_b6-.v2.ivf.res',
+		'invalid-vp90-2-10-show-existing-frame.webm.ivf.s180315_r01-05_b6-.ivf',
+		'invalid-vp90-2-10-show-existing-frame.webm.ivf.s180315_r01-05_b6-.ivf.res',
+		'invalid-vp90-2-12-droppable_1.ivf.s3676_r01-05_b6-.ivf',
+		'invalid-vp90-2-12-droppable_1.ivf.s3676_r01-05_b6-.ivf.res',
+		'invalid-vp90-2-12-droppable_1.ivf.s73804_r01-05_b6-.ivf',
+		'invalid-vp90-2-12-droppable_1.ivf.s73804_r01-05_b6-.ivf.res',
+		'invalid-vp90-2-21-resize_inter_320x180_5_3-4.webm.ivf.s45551_r01-05_b6-.ivf',
+		'invalid-vp90-2-21-resize_inter_320x180_5_3-4.webm.ivf.s45551_r01-05_b6-.ivf.res',
+		'invalid-vp91-2-mixedrefcsp-444to420.ivf',
+		'invalid-vp91-2-mixedrefcsp-444to420.ivf.res',
+		'invalid-vp90-2-07-frame_parallel-1.webm',
+		'invalid-vp90-2-07-frame_parallel-2.webm',
+		'invalid-vp90-2-07-frame_parallel-3.webm',
+		'invalid-crbug-629481.webm',
+		'invalid-crbug-629481.webm.res',
+		'invalid-crbug-1558.ivf',
+		'invalid-crbug-1558.ivf.res',
+		'invalid-crbug-1562.ivf',
+		'invalid-crbug-1562.ivf.res',
+		'invalid-crbug-667044.webm',
+		'invalid-crbug-667044.webm.res',
+		'crbug-1539.rawfile',
+		# 'vp90-2-bbb_426x240_tile_1x1_180kbps.webm', # MANUAL
+		# 'vp90-2-bbb_640x360_tile_1x2_337kbps.webm', # MANUAL
+		# 'vp90-2-bbb_854x480_tile_1x2_651kbps.webm', # MANUAL
+		# 'vp90-2-bbb_1280x720_tile_1x4_1310kbps.webm', # MANUAL
+		# 'vp90-2-bbb_1920x1080_tile_1x1_2581kbps.webm', # MANUAL
+		# 'vp90-2-bbb_1920x1080_tile_1x4_2586kbps.webm', # MANUAL
+		# 'vp90-2-bbb_1920x1080_tile_1x4_fpm_2304kbps.webm', # MANUAL
+		# 'vp90-2-sintel_426x182_tile_1x1_171kbps.webm', # MANUAL
+		# 'vp90-2-sintel_640x272_tile_1x2_318kbps.webm', # MANUAL
+		# 'vp90-2-sintel_854x364_tile_1x2_621kbps.webm', # MANUAL
+		# 'vp90-2-sintel_1280x546_tile_1x4_1257kbps.webm', # MANUAL
+		# 'vp90-2-sintel_1920x818_tile_1x4_fpm_2279kbps.webm', # MANUAL
+		# 'vp90-2-tos_426x178_tile_1x1_181kbps.webm', # MANUAL
+		# 'vp90-2-tos_640x266_tile_1x2_336kbps.webm', # MANUAL
+		# 'vp90-2-tos_854x356_tile_1x2_656kbps.webm', # MANUAL
+		# 'vp90-2-tos_854x356_tile_1x2_fpm_546kbps.webm', # MANUAL
+		# 'vp90-2-tos_1280x534_tile_1x4_1306kbps.webm', # MANUAL
+		# 'vp90-2-tos_1280x534_tile_1x4_fpm_952kbps.webm', # MANUAL
+		# 'vp90-2-tos_1920x800_tile_1x4_fpm_2335kbps.webm', # MANUAL
+		'vp90-2-21-resize_inter_320x180_5_1-2.webm',
+		'vp90-2-21-resize_inter_320x180_5_1-2.webm.md5',
+		'vp90-2-21-resize_inter_320x180_5_3-4.webm',
+		'vp90-2-21-resize_inter_320x180_5_3-4.webm.md5',
+		'vp90-2-21-resize_inter_320x180_7_1-2.webm',
+		'vp90-2-21-resize_inter_320x180_7_1-2.webm.md5',
+		'vp90-2-21-resize_inter_320x180_7_3-4.webm',
+		'vp90-2-21-resize_inter_320x180_7_3-4.webm.md5',
+		'vp90-2-21-resize_inter_320x240_5_1-2.webm',
+		'vp90-2-21-resize_inter_320x240_5_1-2.webm.md5',
+		'vp90-2-21-resize_inter_320x240_5_3-4.webm',
+		'vp90-2-21-resize_inter_320x240_5_3-4.webm.md5',
+		'vp90-2-21-resize_inter_320x240_7_1-2.webm',
+		'vp90-2-21-resize_inter_320x240_7_1-2.webm.md5',
+		'vp90-2-21-resize_inter_320x240_7_3-4.webm',
+		'vp90-2-21-resize_inter_320x240_7_3-4.webm.md5',
+		'vp90-2-21-resize_inter_640x360_5_1-2.webm',
+		'vp90-2-21-resize_inter_640x360_5_1-2.webm.md5',
+		'vp90-2-21-resize_inter_640x360_5_3-4.webm',
+		'vp90-2-21-resize_inter_640x360_5_3-4.webm.md5',
+		'vp90-2-21-resize_inter_640x360_7_1-2.webm',
+		'vp90-2-21-resize_inter_640x360_7_1-2.webm.md5',
+		'vp90-2-21-resize_inter_640x360_7_3-4.webm',
+		'vp90-2-21-resize_inter_640x360_7_3-4.webm.md5',
+		'vp90-2-21-resize_inter_640x480_5_1-2.webm',
+		'vp90-2-21-resize_inter_640x480_5_1-2.webm.md5',
+		'vp90-2-21-resize_inter_640x480_5_3-4.webm',
+		'vp90-2-21-resize_inter_640x480_5_3-4.webm.md5',
+		'vp90-2-21-resize_inter_640x480_7_1-2.webm',
+		'vp90-2-21-resize_inter_640x480_7_1-2.webm.md5',
+		'vp90-2-21-resize_inter_640x480_7_3-4.webm',
+		'vp90-2-21-resize_inter_640x480_7_3-4.webm.md5',
+		'vp90-2-21-resize_inter_1280x720_5_1-2.webm',
+		'vp90-2-21-resize_inter_1280x720_5_1-2.webm.md5',
+		'vp90-2-21-resize_inter_1280x720_5_3-4.webm',
+		'vp90-2-21-resize_inter_1280x720_5_3-4.webm.md5',
+		'vp90-2-21-resize_inter_1280x720_7_1-2.webm',
+		'vp90-2-21-resize_inter_1280x720_7_1-2.webm.md5',
+		'vp90-2-21-resize_inter_1280x720_7_3-4.webm',
+		'vp90-2-21-resize_inter_1280x720_7_3-4.webm.md5',
+		'vp90-2-21-resize_inter_1920x1080_5_1-2.webm',
+		'vp90-2-21-resize_inter_1920x1080_5_1-2.webm.md5',
+		'vp90-2-21-resize_inter_1920x1080_5_3-4.webm',
+		'vp90-2-21-resize_inter_1920x1080_5_3-4.webm.md5',
+		'vp90-2-21-resize_inter_1920x1080_7_1-2.webm',
+		'vp90-2-21-resize_inter_1920x1080_7_1-2.webm.md5',
+		'vp90-2-21-resize_inter_1920x1080_7_3-4.webm',
+		'vp90-2-21-resize_inter_1920x1080_7_3-4.webm.md5',
+		'vp90-2-22-svc_1280x720_3.ivf',
+		'vp90-2-22-svc_1280x720_3.ivf.md5',
+		'vp90-2-22-svc_1280x720_1.webm',
+		'vp90-2-22-svc_1280x720_1.webm.md5'
+	],
+	'vp9_encoder' : [
+		'desktop_credits.y4m',
+		'niklas_1280_720_30.y4m',
+		'noisy_clip_640_360.y4m',
+		'rush_hour_444.y4m',
+		'screendata.y4m',
+		'niklas_640_480_30.yuv',
+		'bus_352x288_420_f20_b8.yuv',
+		'niklas_1280_720_30.yuv',
+		'desktop_640_360_30.yuv',
+		'kirland_640_480_30.yuv',
+		'macmarcomoving_640_480_30.yuv',
+		'macmarcostationary_640_480_30.yuv',
+		'niklas_1280_720_30.yuv',
+		'tacomanarrows_640_480_30.yuv',
+		'tacomasmallcameramovement_640_480_30.yuv',
+		'thaloundeskmtg_640_480_30.yuv'
+	],
+}
+
+if features.get('webm_io', false) # MANUAL
+	libvpx_test_optional_sources += {
+		'decoders' : libvpx_test_optional_sources['decoders'] + files(
+			# '../third_party/libwebm/mkvparser/mkvparser.cc',
+			# '../third_party/libwebm/mkvparser/mkvreader.cc',
+			'../webmdec.cc',
+			'vp9_skip_loopfilter_test.cc',
+		)
+	}
+
+	libvpx_test_headers_optional_sources += {
+		'decoders' : libvpx_test_headers_optional_sources['decoders'] + files(
+			# '../third_party/libwebm/mkvparser/mkvparser.h',
+			# '../third_party/libwebm/mkvparser/mkvreader.h',
+			# '../third_party/libwebm/common/webmids.h',
+			'../webmdec.h',
+			'webm_video_source.h',
+		)
+	}
+endif
+
+# Currently we only support decoder perf tests for vp9. Also they read from WebM
+# files, so WebM IO is required.
+if features.get('decode_perf_tests', false) and features.get('vp9_decoder', false) and features.get('webm_io', false) # MANUAL
+	libvpx_test_sources += files(
+		'decode_perf_test.cc',
+	)
+endif
+
+# encode perf tests are vp9 only
+if features.get('encode_perf_tests', false) and features.get('vp9_encoder', false) # MANUAL
+	libvpx_test_sources += files(
+		'encode_perf_test.cc',
+	)
+endif
+
+## Multi-codec blackbox tests.
+if features.get('vp8_encoder', false) or features.get('vp9_encoder', false) # MANUAL
+	libvpx_test_sources += files(
+		'invalid_file_test.cc',
+	)
+endif
+
+##
+## WHITE BOX TESTS
+##
+## Whitebox tests invoke functions not exposed via the public API. Certain
+## shared library builds don't make these functions accessible.
+##
+# (note from Amy)
+# Those shared library builds are actually linkers that follow
+# the module definitions. Alternatively, this implies that they are
+# either MSVC or a compiler with -fvisibility=hidden by default.
+if not features.get('shared', false) # MANUAL
+	## VP8
+	if features.get('vp8', false)
+		# These tests require both the encoder and decoder to be built.
+		if features.get('vp8_encoder', false) and features.get('vp8_decoder', false)
+			libvpx_test_sources += files(
+				'vp8_boolcoder_test.cc',
+				'vp8_fragments_test.cc',
+			)
+		endif
+
+		libvpx_test_optional_sources += {
+			'postproc' : libvpx_test_optional_sources['postproc'] + files(
+				'add_noise_test.cc',
+				'pp_filter_test.cc',
+			),
+			'vp8_decoder' : libvpx_test_optional_sources['vp8_decoder'] + files(
+				'vp8_decrypt_test.cc',
+				'set_roi.cc',
+				'variance_test.cc',
+				'vp8_fdct4x4_test.cc',
+			)
+		}
+
+		quantize_test_allowed_architectures = [
+			'sse2', 'ssse3', 'sse4_1', 'neon', 'msa', 'mmi'
+		]
+
+		quantize_test_allowed = false
+		foreach arch : quantize_test_allowed_architectures
+			if features.get(arch, false)
+				quantize_test_allowed = true
+				break
+			endif
+		endforeach
+
+		if quantize_test_allowed
+			libvpx_test_optional_sources += {
+				'vp8_decoder' : libvpx_test_optional_sources['vp8_decoder'] + files(
+					'quantize_test.cc',
+				)
+			}
+		endif
+
+		libvpx_test_sources += files(
+			'idct_test.cc',
+			'predict_test.cc',
+			'vpx_scale_test.cc',
+		)
+
+		libvpx_test_headers_sources += files(
+			'vpx_scale_test.h',
+		)
+
+		if features.get('vp8_encoder', false) and features.get('temporal_denoising', false)
+			libvpx_test_optional_sources += {
+				'sse2' : libvpx_test_optional_sources['sse2'] + files(
+					'vp8_denoiser_sse2_test.cc',
+				)
+			}
+		endif
+	endif
+
+	## VP9
+	if features.get('vp9', false)
+		# These tests require both the encoder and decoder to be built.
+		if features.get('vp9_encoder', false) and features.get('vp9_decoder', false)
+			# IDCT test currently depends on FDCT function
+			libvpx_test_sources += files(
+				'idct8x8_test.cc',
+				'partial_idct_test.cc',
+				'superframe_test.cc',
+				'tile_independence_test.cc',
+				'vp9_boolcoder_test.cc',
+				'vp9_encoder_parms_get_to_decoder.cc',
+				'vp9_roi_test.cc',
+			)
+		endif
+
+		libvpx_test_sources += files(
+			'convolve_test.cc',
+			'lpf_test.cc',
+			'vp9_intrapred_test.cc',
+		)
+
+		libvpx_test_optional_sources += {
+			'vp9_decoder' : libvpx_test_optional_sources['vp9_decoder'] + files(
+				'vp9_decrypt_test.cc',
+				'vp9_thread_test.cc',
+			),
+			'vp9_encoder' : libvpx_test_optional_sources['vp9_encoder'] + files(
+				'avg_test.cc',
+				'comp_avg_pred_test.cc',
+				'dct16x16_test.cc',
+				'dct32x32_test.cc',
+				'dct_partial_test.cc',
+				'dct_test.cc',
+				'fdct8x8_test.cc',
+				'hadamard_test.cc',
+				'minmax_test.cc',
+				'vp9_scale_test.cc',
+				'variance_test.cc',
+				'vp9_quantize_test.cc',
+				'vp9_subtract_test.cc',
+			)
+		}
+
+		if not features.get('realtime_only', false)
+			libvpx_test_optional_sources += {
+				'vp9_encoder' : libvpx_test_optional_sources['vp9_encoder'] + files(
+					'yuv_temporal_filter_test.cc',
+				)
+			}
+		endif
+
+		if features.get('sse2', false) or features.get('avx2', false)
+			libvpx_test_optional_sources += {
+				'vp9_encoder' : libvpx_test_optional_sources['vp9_encoder'] + files(
+					'vp9_block_error_test.cc',
+				)
+			}
+		endif
+
+		if features.get('vp9_encoder', false)
+			libvpx_test_optional_sources += {
+				'internal_stats' : libvpx_test_optional_sources['internal_stats'] + files(
+					'blockiness_test.cc',
+					'consistency_test.cc',
+					'non_greedy_mv_test.cc',
+				)
+			}
+		endif
+
+		if features.get('vp9_encoder', false) and features.get('vp9_temporal_denoising', false)
+			libvpx_test_sources += files(
+				'vp9_denoiser_test.cc',
+			)
+		endif
+
+		libvpx_test_optional_sources += {
+			'vp9_encoder' : libvpx_test_optional_sources['vp9_encoder'] + files(
+				'vp9_arf_freq_test.cc',
+			)
+		}
+
+		if features.get('vp9_encoder', false)
+			simple_encode_test_optional_sources += {
+				'rate_ctrl' : simple_encode_test_optional_sources['rate_ctrl']+ files(
+					'simple_encode_test.cc',
+				)
+			}
+		endif
+	endif
+
+	## Multi-codec / unconditional whitebox tests.
+	libvpx_test_optional_sources += {
+		'encoders' : libvpx_test_optional_sources['encoders'] + files(
+			'sad_test.cc'
+		)
+	}
+
+	if features.get('neon', false) or features.get('sse2', false) or features.get('msa', false)
+		libvpx_test_optional_sources += {
+			'encoders' : libvpx_test_optional_sources['encoders'] + files(
+				'sum_squares_test.cc'
+			)
+		}
+	endif
+
+	test_intra_pred_speed_sources += files(
+		'test_intra_pred_speed.cc',
+		'../md5_utils.c',
+	)
+
+	test_intra_pred_speed_headers_sources = files(
+		'../md5_utils.h',
+	)
+
+	rc_interface_test_optional_sources += {
+		'encoders' : rc_interface_test_optional_sources['encoders'] + files(
+			'encode_test_driver.cc'
+		),
+		'vp8_encoder' : rc_interface_test_optional_sources['encoders'] + files(
+			'vp8_ratectrl_rtc_test.cc'
+		),
+		'vp9_encoder' : rc_interface_test_optional_sources['encoders'] + files(
+			'vp9_ratectrl_rtc_test.cc'
+		),
+	}
+
+	rc_interface_test_sources = files(
+		'test_rc_interface.cc',
+		'decode_test_driver.cc',
+	)
+
+	rc_interface_test_headers_sources += files(
+		'decode_test_driver.h',
+		'codec_factory.h',
+	)
+endif
+
+if features.get('vp9_highbitdepth', false)
+	libvpx_test_data_data_optional_sources += {
+		'vp9_decoder' : libvpx_test_data_data_optional_sources['vp9_decoder'] + [
+			'vp92-2-20-10bit-yuv420.webm',
+			'vp92-2-20-10bit-yuv420.webm.md5',
+			'vp92-2-20-12bit-yuv420.webm',
+			'vp92-2-20-12bit-yuv420.webm.md5',
+			'vp93-2-20-10bit-yuv422.webm',
+			'vp93-2-20-10bit-yuv422.webm.md5',
+			'vp93-2-20-12bit-yuv422.webm',
+			'vp93-2-20-12bit-yuv422.webm.md5',
+			'vp93-2-20-10bit-yuv440.webm',
+			'vp93-2-20-10bit-yuv440.webm.md5',
+			'vp93-2-20-12bit-yuv440.webm',
+			'vp93-2-20-12bit-yuv440.webm.md5',
+			'vp93-2-20-10bit-yuv444.webm',
+			'vp93-2-20-10bit-yuv444.webm.md5',
+			'vp93-2-20-12bit-yuv444.webm',
+			'vp93-2-20-12bit-yuv444.webm.md5',
+		]
+	}
+endif
+
+if features.get('decode_perf_tests', false)
+	libvpx_test_data_data_optional_sources += {
+		'vp9_encoder' : libvpx_test_data_data_optional_sources['vp9_encoder'] + [
+			# Encode / Decode test
+			'niklas_1280_720_30.yuv',
+		],
+		'vp9_decoder' : libvpx_test_data_data_optional_sources['vp9_decoder'] + [
+			# BBB VP9 streams
+			'vp90-2-bbb_426x240_tile_1x1_180kbps.webm',
+			'vp90-2-bbb_640x360_tile_1x2_337kbps.webm',
+			'vp90-2-bbb_854x480_tile_1x2_651kbps.webm',
+			'vp90-2-bbb_1280x720_tile_1x4_1310kbps.webm',
+			'vp90-2-bbb_1920x1080_tile_1x1_2581kbps.webm',
+			'vp90-2-bbb_1920x1080_tile_1x4_2586kbps.webm',
+			'vp90-2-bbb_1920x1080_tile_1x4_fpm_2304kbps.webm',
+			# Sintel VP9 streams
+			'vp90-2-sintel_426x182_tile_1x1_171kbps.webm',
+			'vp90-2-sintel_640x272_tile_1x2_318kbps.webm',
+			'vp90-2-sintel_854x364_tile_1x2_621kbps.webm',
+			'vp90-2-sintel_1280x546_tile_1x4_1257kbps.webm',
+			'vp90-2-sintel_1920x818_tile_1x4_fpm_2279kbps.webm',
+			# TOS VP9 streams
+			'vp90-2-tos_426x178_tile_1x1_181kbps.webm',
+			'vp90-2-tos_640x266_tile_1x2_336kbps.webm',
+			'vp90-2-tos_854x356_tile_1x2_656kbps.webm',
+			'vp90-2-tos_854x356_tile_1x2_fpm_546kbps.webm',
+			'vp90-2-tos_1280x534_tile_1x4_1306kbps.webm',
+			'vp90-2-tos_1280x534_tile_1x4_fpm_952kbps.webm',
+			'vp90-2-tos_1920x800_tile_1x4_fpm_2335kbps.webm',
+		]
+	}
+endif
+
+if features.get('encode_perf_tests', false)
+	libvpx_test_data_data_optional_sources += {
+		'vp9_encoder' : libvpx_test_data_data_optional_sources['vp9_encoder'] + [
+			'desktop_640_360_30.yuv',
+			'kirland_640_480_30.yuv',
+			'macmarcomoving_640_480_30.yuv',
+			'macmarcostationary_640_480_30.yuv',
+			'niklas_1280_720_30.yuv',
+			'tacomanarrows_640_480_30.yuv',
+			'tacomasmallcameramovement_640_480_30.yuv',
+			'thaloundeskmtg_640_480_30.yuv',
+		]
+	}
+endif
+
+#### --- END GENERATED --- ####
+
+optional_sources = get_variable('libvpx_test_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if features.get(comp_name, false)
+		libvpx_test_sources += comp_sources
+	endif
+endforeach
+
+optional_sources = get_variable('libvpx_test_headers_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if features.get(comp_name, false)
+		libvpx_test_headers_sources += comp_sources
+	endif
+endforeach
+
+optional_sources = get_variable('rc_interface_test_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if features.get(comp_name, false)
+		rc_interface_test_sources += comp_sources
+	endif
+endforeach
+
+optional_sources = get_variable('simple_encode_test_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if features.get(comp_name, false)
+		simple_encode_test_sources += comp_sources
+	endif
+endforeach
+
+optional_sources = get_variable('libvpx_test_data_data_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if features.get(comp_name, false)
+		libvpx_test_data_data_sources += comp_sources
+	endif
+endforeach
+
+##
+## libvpx test directives
+##
+
+libvpx_test_deps = [libvpx_dep, gtest_dep]
+
+if features.get('webm_io', false)
+	libvpx_test_deps += libwebm_dep
+endif
+
+LIBVPX_TEST_BIN = executable(
+	'test_libvpx',
+	libvpx_test_sources,
+	extra_files: libvpx_test_headers_sources,
+	dependencies: libvpx_test_deps
+)
+
+libvpx_test_data_url = 'https://storage.googleapis.com/downloads.webmproject.org/test_data/libvpx/@0@'
+
+libvpx_test_data = []
+libvpx_test_data_dedup = configuration_data()
+
+foreach f : libvpx_test_data_data_sources
+	if not libvpx_test_data_dedup.get(f, false)
+		libvpx_test_data += custom_target(
+			f,
+			command: [curl_exe, '-S', '-s', '--retry', '1', '-L', '-o', '@OUTPUT@', libvpx_test_data_url.format(f)],
+			output: f
+		)
+		libvpx_test_data_dedup.set(f, true)
+	endif
+endforeach
+
+test_data_manifest = files(
+	'test-data.sha1'
+)
+
+testdata = custom_target(
+	'testdata',
+	command: [check_test_data, '@INPUT@'],
+	output: 'testdata.txt',
+	input: test_data_manifest,
+	depends: libvpx_test_data,
+	capture: true
+)
+
+if test_intra_pred_speed_sources.length() > 0
+	TEST_INTRA_PRED_SPEED_BIN = executable(
+		'test_intra_pred_speed',
+		test_intra_pred_speed_sources,
+		extra_files: test_intra_pred_speed_headers_sources,
+		dependencies: [libvpx_dep, gtest_dep]
+	)
+	test('test_intra_pred_speed', TEST_INTRA_PRED_SPEED_BIN)
+endif
+
+if features.get('encoders', false) and rc_interface_test_sources.length() > 0
+	RC_INTERFACE_TEST_BIN = executable(
+		'test_rc_interface',
+		rc_interface_test_sources,
+		extra_files: rc_interface_test_headers_sources,
+		link_with: vpxrc_lib,
+		dependencies: [libvpx_dep, gtest_dep]
+	)
+
+	test(
+		'test_rc_interface',
+		RC_INTERFACE_TEST_BIN,
+		depends: testdata,
+	)
+endif
+
+if simple_encode_test_sources.length() > 0
+	SIMPLE_ENCODE_TEST_BIN = executable(
+		'test_simple_encode',
+		simple_encode_test_sources,
+		link_with: simple_encode_lib,
+		dependencies: [libvpx_dep, gtest_dep]
+	)
+	test(
+		'test_simple_encode',
+		SIMPLE_ENCODE_TEST_BIN,
+		depends: testdata,
+	)
+endif
+
+NUM_SHARDS = 10
+
+foreach i : range(0, NUM_SHARDS)
+	test('test_shard.@0@'.format(i), LIBVPX_TEST_BIN,
+		env: {
+			'GTEST_SHARD_INDEX': '@0@'.format(i),
+			'GTEST_TOTAL_SHARDS': '@0'.format(NUM_SHARDS),
+		}
+	)
+endforeach
+
+##
+## vpxdec/vpxenc tests.
+##
+test(
+	'utiltest_vpxdec',
+	vpxdec_sh,
+	args: ['--test-data-path', meson.current_build_dir(), '--bin-path', meson.current_build_dir()],
+	depends: testdata,
+)
+test(
+	'utiltest_vpxenc',
+	vpxenc_sh,
+	args: ['--test-data-path', meson.current_build_dir(), '--bin-path', meson.current_build_dir()],
+	depends: testdata,
+)
+
+##
+## Example tests.
+##
+test(
+	'exampletest',
+	examples_sh,
+	args: ['--test-data-path', meson.current_build_dir(), '--bin-path', meson.current_build_dir()],
+	depends: testdata,
+)
diff --git a/third_party/googletest/meson.build b/third_party/googletest/meson.build
new file mode 100644
index 000000000..767c9e140
--- /dev/null
+++ b/third_party/googletest/meson.build
@@ -0,0 +1,33 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+gtest_srcs = files(
+	'src/src/gtest-all.cc',
+)
+
+gtest_includes = include_directories(
+	'src',
+	'src/include'
+)
+
+gtest_flags = []
+
+if features.get('pthread_h', false)
+	gtest_flags += ['-DGTEST_HAS_PTHREAD=0']
+endif
+
+libgtest = static_library(
+	'gtest',
+	gtest_srcs,
+	c_args: gtest_flags,
+	cpp_args: gtest_flags,
+	include_directories: gtest_includes,
+	dependencies: extra_libs,
+)
+
+gtest_dep = declare_dependency(
+	link_with: libgtest,
+	compile_args: gtest_flags,
+	dependencies: extra_libs,
+	include_directories: gtest_includes,
+)
diff --git a/third_party/libwebm/meson.build b/third_party/libwebm/meson.build
new file mode 100644
index 000000000..bd1671135
--- /dev/null
+++ b/third_party/libwebm/meson.build
@@ -0,0 +1,52 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+libwebm_common_srcs = files(
+	'common/hdr_util.cc',
+)
+
+libwebm_common_includes = files(
+	'common/hdr_util.h',
+	'common/webmids.h',
+)
+
+libwebm_muxer_srcs = files(
+	'mkvmuxer/mkvmuxer.cc',
+	'mkvmuxer/mkvmuxerutil.cc',
+	'mkvmuxer/mkvwriter.cc',
+)
+
+libwebm_muxer_headers = files(
+	'mkvmuxer/mkvmuxer.h',
+	'mkvmuxer/mkvmuxertypes.h',
+	'mkvmuxer/mkvmuxerutil.h',
+	'mkvparser/mkvparser.h',
+	'mkvmuxer/mkvwriter.h',
+)
+
+libwebm_parser_srcs = files(
+	'mkvparser/mkvparser.cc',
+	'mkvparser/mkvreader.cc',
+)
+
+libwebm_parser_headers = files(
+	'mkvparser/mkvparser.h',
+	'mkvparser/mkvreader.h',
+)
+
+libwebm = static_library(
+	'vpx_webm',
+	libwebm_common_srcs + libwebm_muxer_srcs + libwebm_parser_srcs,
+	extra_files: libwebm_common_includes + libwebm_muxer_headers + libwebm_parser_headers,
+	include_directories: include_directories('.'),
+	cpp_args: [
+		'-D__STDC_CONSTANT_MACROS',
+		'-D__STDC_FORMAT_MACROS',
+		'-D__STDC_LIMIT_MACROS'
+	]
+)
+
+libwebm_dep = declare_dependency(
+	link_with: libwebm,
+	include_directories: include_directories('.'),
+)
diff --git a/third_party/libyuv/meson.build b/third_party/libyuv/meson.build
new file mode 100644
index 000000000..0f67c4ec0
--- /dev/null
+++ b/third_party/libyuv/meson.build
@@ -0,0 +1,49 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+libyuv_includes = files(
+	'include/libyuv/convert.h',
+	'include/libyuv/convert_argb.h',
+	'include/libyuv/convert_from.h',
+	'include/libyuv/cpu_id.h',
+	'include/libyuv/planar_functions.h',
+	'include/libyuv/rotate.h',
+	'include/libyuv/row.h',
+	'include/libyuv/scale.h',
+	'include/libyuv/scale_row.h',
+)
+
+libyuv_include_directories = include_directories('include')
+
+libyuv_srcs = files(
+	'source/cpu_id.cc',
+	'source/planar_functions.cc',
+	'source/row_any.cc',
+	'source/row_common.cc',
+	'source/row_gcc.cc',
+	'source/row_msa.cc',
+	'source/row_neon.cc',
+	'source/row_neon64.cc',
+	'source/row_win.cc',
+	'source/scale.cc',
+	'source/scale_any.cc',
+	'source/scale_common.cc',
+	'source/scale_gcc.cc',
+	'source/scale_msa.cc',
+	'source/scale_neon.cc',
+	'source/scale_neon64.cc',
+	'source/scale_win.cc',
+)
+
+libyuv = static_library(
+	'vpx_yuv',
+	libyuv_srcs,
+	cpp_args: libyuv_cpp_args,
+	extra_files: libyuv_includes,
+	include_directories: libyuv_include_directories,
+)
+
+libyuv_dep = declare_dependency(
+	link_with: libyuv,
+	include_directories: libyuv_include_directories,
+)
diff --git a/third_party/meson.build b/third_party/meson.build
new file mode 100644
index 000000000..29b1a8ffe
--- /dev/null
+++ b/third_party/meson.build
@@ -0,0 +1,9 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+if features.get('unit_tests', false)
+	subdir('googletest')
+endif
+
+subdir('libwebm')
+subdir('libyuv')
diff --git a/tools/meson.build b/tools/meson.build
new file mode 100644
index 000000000..c46c8358b
--- /dev/null
+++ b/tools/meson.build
@@ -0,0 +1,67 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+doxfiles = []
+
+tiny_ssim_srcs = files(
+	'tiny_ssim.c',
+	'../y4minput.c',
+	'../vpx/src/vpx_image.c',
+	'../vpx_mem/vpx_mem.c',
+)
+
+tiny_ssim_headers = files(
+	'../vpx/vpx_integer.h',
+	'../y4minput.h',
+	'../vpx/vpx_codec.h',
+	'../vpx_mem/vpx_mem.h',
+	'../vpx_dsp/ssim.h',
+	'../vpx_scale/yv12config.h',
+	'../vpx_ports/mem.h',
+	'../vpx_mem/include/vpx_mem_intrnl.h',
+)
+
+tiny_ssim = executable(
+	'tiny_ssim',
+	tiny_ssim_srcs,
+	link_args: link_args,
+	extra_files: tiny_ssim_headers,
+	dependencies: libvpx_dep,
+	install: get_option('install_bins'),
+)
+
+tools_subpages = {
+	'tiny_ssim': 'Generate SSIM/PSNR from raw .yuv files'
+}
+
+tools_subpages_entries = []
+
+#
+# Documentation Rules
+#
+
+if features.get('install_docs', false)
+	foreach page, description: tools_subpages
+		doxfiles += configure_file(
+			command: [generate_component_dox, '--component', 'tools', '--output', '@OUTPUT@', '@INPUT@'],
+			input: get_variable('@0@_srcs'.format(page))[0],
+			output: '@0@.dox'.format(page),
+		)
+
+		tools_subpages_entries += '    - \subpage tools_@0@ @1@'.format(page, description)
+	endforeach
+
+	tools_dox = configure_file(
+		input: 'tools.dox.in',
+		output: 'tools.dox',
+		configuration: {
+			'tools_subpages': '\n'.join(tools_subpages_entries),
+		}
+	)
+
+	tools_doxy = configure_file(
+		command: [doxy_template, '--sections', 'tools', '--output', '@OUTPUT@', '@INPUT@'],
+		input: [tools_dox] + doxfiles,
+		output: 'tools.doxy',
+	)
+endif
diff --git a/tools/tools.dox.in b/tools/tools.dox.in
new file mode 100644
index 000000000..7ebe3a190
--- /dev/null
+++ b/tools/tools.dox.in
@@ -0,0 +1,5 @@
+/*!\page tools Tools
+    This SDK includes a number of tools/utilities.
+    The following tools are included: 
+@tools_subpages@
+*/
diff --git a/vp8/meson.build b/vp8/meson.build
new file mode 100644
index 000000000..9b6b977d2
--- /dev/null
+++ b/vp8/meson.build
@@ -0,0 +1,554 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+# vp8_common.mk
+
+#### --- GENERATED --- ####
+
+vp8_common_sources = files(
+	'common/alloccommon.c',
+	'common/blockd.c',
+	'common/dequantize.c',
+	'common/entropy.c',
+	'common/entropymode.c',
+	'common/entropymv.c',
+	'common/extend.c',
+	'common/filter.c',
+	'common/findnearmv.c',
+	'common/generic/systemdependent.c',
+	'common/idct_blk.c',
+	'common/idctllm.c',
+	'common/rtcd.c',
+	'common/vp8_loopfilter.c',
+	'common/loopfilter_filters.c',
+	'common/mbpitch.c',
+	'common/modecont.c',
+	'common/quant_common.c',
+	'common/reconinter.c',
+	'common/reconintra.c',
+	'common/reconintra4x4.c',
+	'common/setupintrarecon.c',
+	'common/swapyv12buffer.c',
+	'common/treecoder.c',
+)
+
+vp8_common_optional_sources = {
+	'x86': files( # MANUAL
+		'common/x86/vp8_asm_stubs.c',
+		'common/x86/loopfilter_x86.c',
+	),
+	'x86_64': files( # MANUAL
+		'common/x86/vp8_asm_stubs.c',
+		'common/x86/loopfilter_x86.c',
+	),
+	'dspr2' : files(
+		'common/mips/dspr2/idctllm_dspr2.c',
+		'common/mips/dspr2/filter_dspr2.c',
+		'common/mips/dspr2/vp8_loopfilter_filters_dspr2.c',
+		'common/mips/dspr2/reconinter_dspr2.c',
+		'common/mips/dspr2/idct_blk_dspr2.c',
+		'common/mips/dspr2/dequantize_dspr2.c'
+	),
+	'lsx' : files(
+		'common/loongarch/loopfilter_filters_lsx.c',
+		'common/loongarch/sixtap_filter_lsx.c',
+		'common/loongarch/idct_lsx.c'
+	),
+	'mmi' : files(
+		'common/mips/mmi/sixtap_filter_mmi.c',
+		'common/mips/mmi/loopfilter_filters_mmi.c',
+		'common/mips/mmi/idctllm_mmi.c',
+		'common/mips/mmi/dequantize_mmi.c',
+		'common/mips/mmi/copymem_mmi.c',
+		'common/mips/mmi/idct_blk_mmi.c'
+	),
+	'mmx' : files(
+		'common/x86/idct_blk_mmx.c'
+	),
+	'msa' : files(
+		'common/mips/msa/bilinear_filter_msa.c',
+		'common/mips/msa/copymem_msa.c',
+		'common/mips/msa/idct_msa.c',
+		'common/mips/msa/loopfilter_filters_msa.c',
+		'common/mips/msa/sixtap_filter_msa.c',
+		# 'common/mips/msa/mfqe_msa.c' # MANUAL
+	),
+	'neon' : files(
+		'common/arm/loopfilter_arm.c',
+		'common/arm/neon/bilinearpredict_neon.c',
+		'common/arm/neon/copymem_neon.c',
+		'common/arm/neon/dc_only_idct_add_neon.c',
+		'common/arm/neon/dequant_idct_neon.c',
+		'common/arm/neon/dequantizeb_neon.c',
+		'common/arm/neon/idct_blk_neon.c',
+		'common/arm/neon/iwalsh_neon.c',
+		'common/arm/neon/vp8_loopfilter_neon.c',
+		'common/arm/neon/loopfiltersimplehorizontaledge_neon.c',
+		'common/arm/neon/loopfiltersimpleverticaledge_neon.c',
+		'common/arm/neon/mbloopfilter_neon.c',
+		'common/arm/neon/shortidct4x4llm_neon.c',
+		'common/arm/neon/sixtappredict_neon.c'
+	),
+	'postproc' : files(
+		'common/mfqe.c',
+		'common/postproc.c'
+	),
+	'sse2' : files(
+		'common/x86/idct_blk_sse2.c',
+		'common/x86/bilinear_filter_sse2.c'
+	),
+}
+
+vp8_cx_sources = files(
+	'vp8_cx_iface.c',
+	'encoder/bitstream.c',
+	'encoder/boolhuff.c',
+	'encoder/copy_c.c',
+	'encoder/dct.c',
+	'encoder/encodeframe.c',
+	'encoder/encodeintra.c',
+	'encoder/encodemb.c',
+	'encoder/encodemv.c',
+	# 'encoder/firstpass.c', # MANUAL
+	'encoder/lookahead.c',
+	'encoder/mcomp.c',
+	'encoder/modecosts.c',
+	'encoder/onyx_if.c',
+	'encoder/pickinter.c',
+	'encoder/picklpf.c',
+	'encoder/vp8_quantize.c',
+	'encoder/ratectrl.c',
+	'encoder/rdopt.c',
+	'encoder/segmentation.c',
+	'common/vp8_skin_detection.c',
+	'encoder/tokenize.c',
+	'encoder/treewriter.c',
+	# 'encoder/temporal_filter.c', # MANUAL
+)
+
+vp8_cx_optional_sources = {
+	'internal_stats' : files(
+		'common/postproc.c'
+	),
+	'lsx' : files(
+		'encoder/loongarch/dct_lsx.c',
+		'encoder/loongarch/encodeopt_lsx.c',
+		'encoder/loongarch/vp8_quantize_lsx.c'
+	),
+	'mmi' : files(
+		'encoder/mips/mmi/vp8_quantize_mmi.c',
+		'encoder/mips/mmi/dct_mmi.c'
+	),
+	'msa' : files(
+		'encoder/mips/msa/dct_msa.c',
+		'encoder/mips/msa/encodeopt_msa.c',
+		'encoder/mips/msa/quantize_msa.c',
+		# 'encoder/mips/msa/temporal_filter_msa.c', # MANUAL
+		# 'encoder/mips/msa/denoising_msa.c' # MANUAL
+	),
+	'multithread' : files(
+		'encoder/ethreading.c'
+	),
+	'multi_res_encoding' : files(
+		'encoder/mr_dissim.c'
+	),
+	'neon' : files(
+		'encoder/arm/neon/denoising_neon.c',
+		'encoder/arm/neon/fastquantizeb_neon.c',
+		'encoder/arm/neon/shortfdct_neon.c',
+		'encoder/arm/neon/vp8_shortwalsh4x4_neon.c'
+	),
+	'sse2' : files(
+		'encoder/x86/vp8_quantize_sse2.c',
+		# 'encoder/x86/denoising_sse2.c', # MANUAL
+		'encoder/x86/vp8_enc_stubs_sse2.c'
+	),
+	'sse4_1' : files(
+		'encoder/x86/quantize_sse4.c'
+	),
+	'ssse3' : files(
+		'encoder/x86/vp8_quantize_ssse3.c'
+	),
+	'temporal_denoising' : files(
+		'encoder/denoising.c'
+	),
+}
+
+if not features.get('realtime_only', false)
+	vp8_cx_sources += files(
+		'encoder/firstpass.c',
+		'encoder/temporal_filter.c',
+	)
+	vp8_cx_optional_sources += {
+		'msa': vp8_cx_optional_sources['msa'] + files(
+			'encoder/mips/msa/temporal_filter_msa.c',
+		)
+	}
+endif
+
+if features.get('temporal_denoising', true)
+	vp8_cx_optional_sources += {
+		'sse2': vp8_cx_optional_sources['sse2'] + files(
+			'encoder/x86/denoising_sse2.c'
+		)
+	}
+	vp8_cx_optional_sources += {
+		'msa': vp8_cx_optional_sources['msa'] + files(
+			'encoder/mips/msa/denoising_msa.c'
+		)
+	}
+endif
+
+vp8_dx_sources = files(
+	'vp8_dx_iface.c',
+	'decoder/dboolhuff.c',
+	'decoder/decodemv.c',
+	'decoder/decodeframe.c',
+	'decoder/detokenize.c',
+	'decoder/onyxd_if.c',
+)
+
+vp8_dx_optional_sources = {
+	'error_concealment' : files(
+		'decoder/error_concealment.c'
+	),
+	'multithread' : files(
+		'decoder/threading.c'
+	),
+}
+
+vp8_common_headers_sources = files(
+	'common/ppflags.h',
+	'common/onyx.h',
+	'common/onyxd.h',
+	'common/coefupdateprobs.h',
+	'common/default_coef_probs.h',
+	'common/filter.h',
+	'common/alloccommon.h',
+	'common/blockd.h',
+	'common/common.h',
+	'common/entropy.h',
+	'common/entropymode.h',
+	'common/entropymv.h',
+	'common/extend.h',
+	'common/findnearmv.h',
+	'common/header.h',
+	'common/invtrans.h',
+	'common/loopfilter.h',
+	'common/modecont.h',
+	'common/mv.h',
+	'common/onyxc_int.h',
+	'common/quant_common.h',
+	'common/reconinter.h',
+	'common/reconintra.h',
+	'common/reconintra4x4.h',
+	'common/setupintrarecon.h',
+	'common/swapyv12buffer.h',
+	'common/systemdependent.h',
+	'common/threading.h',
+	'common/treecoder.h',
+	'common/vp8_entropymodedata.h',
+)
+
+vp8_common_headers_optional_sources = {
+	'msa' : files(
+		'common/mips/msa/vp8_macros_msa.h'
+	),
+	'neon' : files(
+		'common/arm/loopfilter_arm.h'
+	),
+	'postproc' : files(
+		'common/postproc.h'
+	),
+}
+
+vp8_cx_headers_sources = files(
+	'encoder/defaultcoefcounts.h',
+	'encoder/encodeframe.h',
+	'encoder/block.h',
+	'encoder/boolhuff.h',
+	'encoder/bitstream.h',
+	'encoder/encodeintra.h',
+	'encoder/encodemb.h',
+	'encoder/encodemv.h',
+	'encoder/firstpass.h',
+	'encoder/lookahead.h',
+	'encoder/mcomp.h',
+	'encoder/modecosts.h',
+	'encoder/onyx_int.h',
+	'encoder/pickinter.h',
+	'encoder/quantize.h',
+	'encoder/ratectrl.h',
+	'encoder/rdopt.h',
+	'encoder/tokenize.h',
+	'encoder/treewriter.h',
+	'encoder/picklpf.h',
+	'encoder/segmentation.h',
+	'common/vp8_skin_detection.h',
+	'encoder/dct_value_cost.h',
+	'encoder/dct_value_tokens.h',
+	# 'encoder/temporal_filter.h', # MANUAL
+)
+
+vp8_cx_headers_optional_sources = {
+	'internal_stats' : files(
+		'common/postproc.h'
+	),
+	'multithread' : files(
+		'encoder/ethreading.h'
+	),
+	'multi_res_encoding' : files(
+		'encoder/mr_dissim.h'
+	),
+	'temporal_denoising' : files(
+		'encoder/denoising.h'
+	),
+}
+
+if not features.get('realtime_only', false)
+	vp8_cx_headers_sources += files(
+		'encoder/temporal_filter.h',
+	)
+endif
+
+vp8_dx_headers_sources = files(
+	'decoder/dboolhuff.h',
+	'decoder/decodemv.h',
+	'decoder/decoderthreading.h',
+	'decoder/detokenize.h',
+	'decoder/onyxd_int.h',
+	'decoder/treereader.h',
+)
+
+vp8_dx_headers_optional_sources = {
+	'error_concealment' : files(
+		'decoder/ec_types.h',
+		'decoder/error_concealment.h'
+	),
+}
+
+vp8_common_asm_optional_sources = {
+	'mmx' : files(
+		'common/x86/dequantize_mmx.asm',
+		'common/x86/idctllm_mmx.asm',
+		'common/x86/recon_mmx.asm',
+		'common/x86/subpixel_mmx.asm'
+	),
+	'sse2' : files(
+		'common/x86/idctllm_sse2.asm',
+		'common/x86/recon_sse2.asm',
+		'common/x86/subpixel_sse2.asm',
+		'common/x86/loopfilter_sse2.asm',
+		'common/x86/iwalsh_sse2.asm',
+		# 'common/x86/mfqe_sse2.asm', # MANUAL
+		# 'common/x86/loopfilter_block_sse2_x86_64.asm', # MANUAL
+	),
+	'ssse3' : files(
+		'common/x86/subpixel_ssse3.asm'
+	),
+}
+
+if features.get('postproc', false) # MANUAL
+	vp8_common_asm_optional_sources += {
+		'sse2': vp8_common_asm_optional_sources['sse2'] + files(
+			'common/x86/mfqe_sse2.asm',
+		),
+	}
+	vp8_common_optional_sources += {
+		'msa': vp8_common_optional_sources['msa'] + files(
+			'common/mips/msa/mfqe_msa.c',
+		)
+	}
+endif
+
+if features.get('x86_64', false) # MANUAL
+	vp8_common_asm_optional_sources += {
+		'sse2': vp8_common_asm_optional_sources['sse2'] + files(
+			'common/x86/loopfilter_block_sse2_x86_64.asm',
+		),
+	}
+endif
+
+vp8_cx_asm_optional_sources = {
+	'sse2' : files(
+		'encoder/x86/copy_sse2.asm',
+		'encoder/x86/copy_sse3.asm',
+		'encoder/x86/dct_sse2.asm',
+		'encoder/x86/fwalsh_sse2.asm',
+		'encoder/x86/block_error_sse2.asm',
+		# 'encoder/x86/temporal_filter_apply_sse2.asm' # MANUAL
+	),
+}
+
+if not features.get('realtime_only', false)
+	vp8_common_asm_optional_sources += {
+		'sse2': vp8_common_asm_optional_sources['sse2'] + files(
+			'encoder/x86/temporal_filter_apply_sse2.asm',
+		),
+	}
+endif
+
+#### --- END GENERATED --- ####
+
+codec_srcs += vp8_common_sources
+optional_sources = get_variable('vp8_common_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		codec_arch_srcs += {
+			comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+		}
+	else
+		codec_srcs += comp_sources
+	endif
+endforeach
+
+optional_sources = get_variable('vp8_common_asm_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		transformed_sources = comp_sources
+		if asm_conversion_exe.found()
+			transformed_sources = asm_transformer.process(comp_sources)
+		endif
+		codec_arch_srcs += {
+			comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+		}
+	else
+		codec_srcs += comp_sources
+	endif
+endforeach
+
+codec_headers += vp8_common_headers_sources
+optional_sources = get_variable('vp8_common_headers_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		codec_arch_headers += {
+			comp_name: codec_arch_headers.get(comp_name, []) + comp_sources
+		}
+	else
+		codec_headers += comp_sources
+	endif
+endforeach
+
+if features.get('vp8_encoder', false)
+	codec_srcs += vp8_cx_sources
+	codec_headers += vp8_cx_headers_sources
+
+	optional_sources = get_variable('vp8_cx_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+			}
+		else
+			codec_srcs += comp_sources
+		endif
+	endforeach
+
+	optional_sources = get_variable('vp8_cx_asm_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			transformed_sources = comp_sources
+			if asm_conversion_exe.found()
+				transformed_sources = asm_transformer.process(comp_sources)
+			endif
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+			}
+		else
+			codec_srcs += comp_sources
+		endif
+	endforeach
+
+	optional_sources = get_variable('vp8_cx_headers_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			codec_arch_headers += {
+				comp_name: codec_arch_headers.get(comp_name, []) + comp_sources
+			}
+		else
+			codec_headers += comp_sources
+		endif
+	endforeach
+endif
+
+if features.get('vp8_encoder', false)
+	codec_srcs += vp8_dx_sources
+	codec_headers += vp8_dx_headers_sources
+
+	optional_sources = get_variable('vp8_dx_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+			}
+		else
+			codec_srcs += comp_sources
+		endif
+	endforeach
+
+	optional_sources = get_variable('vp8_dx_asm_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			transformed_sources = comp_sources
+			if asm_conversion_exe.found()
+				transformed_sources = asm_transformer.process(comp_sources)
+			endif
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+			}
+		else
+			codec_srcs += comp_sources
+		endif
+	endforeach
+
+	optional_sources = get_variable('vp8_dx_headers_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			codec_arch_headers += {
+				comp_name: codec_arch_headers.get(comp_name, []) + comp_sources
+			}
+		else
+			codec_headers += comp_sources
+		endif
+	endforeach
+endif
+
+vp8_rtcd_defs = files(
+	'common/rtcd_defs.pl',
+)
+
+codec_rtcds += {
+	'vp8_rtcd': vp8_rtcd_defs[0]
+}
+
+codec_headers += vp8_rtcd_defs
+
+if features.get('vp8_encoder', false)
+	codec_exports += files(
+		'exports_enc',
+	)
+endif
+
+if features.get('vp8_decoder', false)
+	codec_exports += files(
+		'exports_dec',
+	)
+endif
diff --git a/vp9/meson.build b/vp9/meson.build
new file mode 100644
index 000000000..b27740684
--- /dev/null
+++ b/vp9/meson.build
@@ -0,0 +1,595 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+# vp9_common.mk
+
+#### --- GENERATED --- ####
+
+vp9_common_sources = files(
+	'vp9_iface_common.c',
+	'common/vp9_alloccommon.c',
+	'common/vp9_blockd.c',
+	'common/vp9_entropy.c',
+	'common/vp9_entropymode.c',
+	'common/vp9_entropymv.c',
+	'common/vp9_frame_buffers.c',
+	'common/vp9_idct.c',
+	'common/vp9_filter.c',
+	'common/vp9_pred_common.c',
+	'common/vp9_rtcd.c',
+	'common/vp9_scale.c',
+	'common/vp9_seg_common.c',
+	'common/vp9_tile_common.c',
+	'common/vp9_loopfilter.c',
+	'common/vp9_thread_common.c',
+	'common/vp9_mvref_common.c',
+	'common/vp9_quant_common.c',
+	'common/vp9_reconinter.c',
+	'common/vp9_reconintra.c',
+	'common/vp9_common_data.c',
+	'common/vp9_scan.c',
+)
+
+vp9_common_optional_sources = {
+	'dspr2' : files(
+		# 'common/mips/dspr2/vp9_itrans4_dspr2.c', # MANUAL
+		# 'common/mips/dspr2/vp9_itrans8_dspr2.c', # MANUAL
+		# 'common/mips/dspr2/vp9_itrans16_dspr2.c' # MANUAL
+	),
+	'msa' : files(
+		# 'common/mips/msa/vp9_idct4x4_msa.c', # MANUAL
+		# 'common/mips/msa/vp9_idct8x8_msa.c', # MANUAL
+		# 'common/mips/msa/vp9_idct16x16_msa.c', # MANUAL
+		# 'common/mips/msa/vp9_mfqe_msa.c' # MANUAL
+	),
+	'neon' : files(
+		'common/arm/neon/vp9_iht4x4_add_neon.c',
+		'common/arm/neon/vp9_iht8x8_add_neon.c',
+		'common/arm/neon/vp9_iht16x16_add_neon.c',
+		# 'common/arm/neon/vp9_highbd_iht4x4_add_neon.c', # MANUAL
+		# 'common/arm/neon/vp9_highbd_iht8x8_add_neon.c', # MANUAL
+		# 'common/arm/neon/vp9_highbd_iht16x16_add_neon.c' # MANUAL
+	),
+	'sse2' : files(
+		'common/x86/vp9_idct_intrin_sse2.c'
+	),
+	'sse4_1' : files(
+		# 'common/x86/vp9_highbd_iht4x4_add_sse4.c', # MANUAL
+		# 'common/x86/vp9_highbd_iht8x8_add_sse4.c', # MANUAL
+		# 'common/x86/vp9_highbd_iht16x16_add_sse4.c' # MANUAL
+	),
+	'vp9_postproc' : files(
+		'common/vp9_postproc.c',
+		'common/vp9_mfqe.c'
+	),
+	'vsx' : files(
+		'common/ppc/vp9_idct_vsx.c'
+	),
+}
+
+if not features.get('vp9_highbitdepth', false) # MANUAL
+	vp9_common_optional_sources += {
+		'msa': vp9_common_optional_sources['msa'] + files(
+			'common/mips/msa/vp9_idct4x4_msa.c',
+			'common/mips/msa/vp9_idct8x8_msa.c',
+			'common/mips/msa/vp9_idct16x16_msa.c',
+		),
+		'dspr2': vp9_common_optional_sources['dspr2'] + files(
+			'common/mips/dspr2/vp9_itrans4_dspr2.c',
+			'common/mips/dspr2/vp9_itrans8_dspr2.c',
+			'common/mips/dspr2/vp9_itrans16_dspr2.c'
+		)
+	}
+else
+	vp9_common_optional_sources += {
+		'neon': vp9_common_optional_sources['neon'] + files(
+			'common/arm/neon/vp9_highbd_iht4x4_add_neon.c',
+			'common/arm/neon/vp9_highbd_iht8x8_add_neon.c',
+			'common/arm/neon/vp9_highbd_iht16x16_add_neon.c'
+		),
+		'sse4_1': vp9_common_optional_sources['sse4_1'] + files(
+			'common/x86/vp9_highbd_iht4x4_add_sse4.c',
+			'common/x86/vp9_highbd_iht8x8_add_sse4.c',
+			'common/x86/vp9_highbd_iht16x16_add_sse4.c'
+		)
+	}
+endif
+
+if features.get('vp9_postproc', false) # MANUAL
+	vp9_common_optional_sources += {
+		'msa': vp9_common_optional_sources['msa'] + files(
+			'common/mips/msa/vp9_mfqe_msa.c'
+		)
+	}
+endif
+
+vp9_cx_sources = files(
+	'vp9_cx_iface.c',
+	'encoder/vp9_bitstream.c',
+	'encoder/vp9_context_tree.c',
+	'encoder/vp9_cost.c',
+	'encoder/vp9_dct.c',
+	'encoder/vp9_encodeframe.c',
+	'encoder/vp9_encodemb.c',
+	'encoder/vp9_encodemv.c',
+	'encoder/vp9_ethread.c',
+	'encoder/vp9_extend.c',
+	# 'encoder/vp9_firstpass.c', # MANUAL
+	'encoder/vp9_frame_scale.c',
+	'encoder/vp9_lookahead.c',
+	'encoder/vp9_multi_thread.c',
+	'encoder/vp9_mcomp.c',
+	'encoder/vp9_encoder.c',
+	'encoder/vp9_picklpf.c',
+	'encoder/vp9_quantize.c',
+	'encoder/vp9_ratectrl.c',
+	'encoder/vp9_rd.c',
+	'encoder/vp9_rdopt.c',
+	'encoder/vp9_pickmode.c',
+	'encoder/vp9_segmentation.c',
+	'encoder/vp9_speed_features.c',
+	'encoder/vp9_subexp.c',
+	'encoder/vp9_svc_layercontext.c',
+	'encoder/vp9_resize.c',
+	'encoder/vp9_tokenize.c',
+	'encoder/vp9_treewriter.c',
+	# 'encoder/vp9_aq_variance.c', # MANUAL
+	# 'encoder/vp9_aq_360.c', # MANUAL
+	'encoder/vp9_aq_cyclicrefresh.c',
+	# 'encoder/vp9_aq_complexity.c', # MANUAL
+	# 'encoder/vp9_alt_ref_aq.c', # MANUAL
+	'encoder/vp9_skin_detection.c',
+	'encoder/vp9_noise_estimate.c',
+	'encoder/vp9_ext_ratectrl.c',
+	# 'encoder/vp9_temporal_filter.c', # MANUAL
+	# 'encoder/vp9_mbgraph.c', # MANUAL
+)
+
+vp9_cx_optional_sources = {
+	'avx' : files(
+		'encoder/x86/vp9_diamond_search_sad_avx.c'
+	),
+	'avx2' : files(
+		'encoder/x86/vp9_quantize_avx2.c',
+		'encoder/x86/vp9_error_avx2.c'
+	),
+	'internal_stats' : files(
+		'encoder/vp9_blockiness.c',
+		'common/vp9_postproc.c'
+	),
+	'msa' : files(
+		'encoder/mips/msa/vp9_error_msa.c',
+		# 'encoder/mips/msa/vp9_fdct4x4_msa.c', # MANUAL
+		# 'encoder/mips/msa/vp9_fdct8x8_msa.c', # MANUAL
+		# 'encoder/mips/msa/vp9_fdct16x16_msa.c' # MANUAL
+	),
+	'neon' : files(
+		'encoder/arm/neon/vp9_diamond_search_sad_neon.c',
+		'encoder/arm/neon/vp9_dct_neon.c',
+		# 'encoder/arm/neon/vp9_denoiser_neon.c', # MANUAL
+		# 'encoder/arm/neon/vp9_error_neon.c', # MANUAL
+		'encoder/arm/neon/vp9_frame_scale_neon.c',
+		'encoder/arm/neon/vp9_quantize_neon.c'
+	),
+	'non_greedy_mv' : files(
+		'encoder/vp9_non_greedy_mv.c'
+	),
+	'sse2' : files(
+		'encoder/x86/vp9_quantize_sse2.c',
+		# 'encoder/x86/vp9_highbd_block_error_intrin_sse2.c', # MANUAL
+		'encoder/x86/vp9_dct_intrin_sse2.c',
+		# 'encoder/x86/vp9_denoiser_sse2.c' # MANUAL
+	),
+	'sse4_1' : files(
+		# 'encoder/x86/temporal_filter_sse4.c', # MANUAL
+		# 'encoder/x86/highbd_temporal_filter_sse4.c', # MANUAL
+	),
+	'ssse3' : files(
+		'encoder/x86/vp9_quantize_ssse3.c',
+		'encoder/x86/vp9_frame_scale_ssse3.c'
+	),
+	'vp9_temporal_denoising' : files(
+		'encoder/vp9_denoiser.c'
+	),
+	'vsx' : files(
+		'encoder/ppc/vp9_quantize_vsx.c'
+	),
+}
+
+vp9_dx_sources = files(
+	'vp9_dx_iface.c',
+	'decoder/vp9_decodemv.c',
+	'decoder/vp9_decodeframe.c',
+	'decoder/vp9_detokenize.c',
+	'decoder/vp9_decoder.c',
+	'decoder/vp9_dsubexp.c',
+	'decoder/vp9_job_queue.c',
+)
+
+vp9_dx_optional_sources = {
+}
+
+vp9_common_headers_sources = files(
+	'vp9_iface_common.h',
+	'common/vp9_ppflags.h',
+	'common/vp9_frame_buffers.h',
+	'common/vp9_alloccommon.h',
+	'common/vp9_blockd.h',
+	'common/vp9_common.h',
+	'common/vp9_entropy.h',
+	'common/vp9_entropymode.h',
+	'common/vp9_entropymv.h',
+	'common/vp9_enums.h',
+	'common/vp9_filter.h',
+	'common/vp9_idct.h',
+	'common/vp9_loopfilter.h',
+	'common/vp9_thread_common.h',
+	'common/vp9_mv.h',
+	'common/vp9_onyxc_int.h',
+	'common/vp9_pred_common.h',
+	'common/vp9_quant_common.h',
+	'common/vp9_reconinter.h',
+	'common/vp9_reconintra.h',
+	'common/vp9_scale.h',
+	'common/vp9_seg_common.h',
+	'common/vp9_tile_common.h',
+	'common/vp9_mvref_common.h',
+	'common/vp9_common_data.h',
+	'common/vp9_scan.h',
+)
+
+vp9_common_headers_optional_sources = {
+	'neon' : files(
+		'common/arm/neon/vp9_iht_neon.h'
+	),
+	'vp9_postproc' : files(
+		'common/vp9_postproc.h',
+		'common/vp9_mfqe.h'
+	),
+}
+
+vp9_cx_headers_sources = files(
+	'vp9_cx_iface.h',
+	'encoder/vp9_context_tree.h',
+	'encoder/vp9_cost.h',
+	'encoder/vp9_encodeframe.h',
+	'encoder/vp9_ethread.h',
+	'encoder/vp9_block.h',
+	'encoder/vp9_bitstream.h',
+	'encoder/vp9_encodemb.h',
+	'encoder/vp9_encodemv.h',
+	'encoder/vp9_extend.h',
+	'encoder/vp9_firstpass.h',
+	'encoder/vp9_job_queue.h',
+	'encoder/vp9_lookahead.h',
+	'encoder/vp9_mcomp.h',
+	'encoder/vp9_multi_thread.h',
+	'encoder/vp9_encoder.h',
+	'encoder/vp9_quantize.h',
+	'encoder/vp9_ratectrl.h',
+	'encoder/vp9_rd.h',
+	'encoder/vp9_rdopt.h',
+	'encoder/vp9_pickmode.h',
+	'encoder/vp9_svc_layercontext.h',
+	'encoder/vp9_tokenize.h',
+	'encoder/vp9_treewriter.h',
+	'encoder/vp9_picklpf.h',
+	'encoder/vp9_partition_models.h',
+	'encoder/vp9_segmentation.h',
+	'encoder/vp9_speed_features.h',
+	'encoder/vp9_subexp.h',
+	'encoder/vp9_resize.h',
+	# 'encoder/vp9_aq_variance.h', # MANUAL
+	# 'encoder/vp9_aq_360.h', # MANUAL
+	'encoder/vp9_aq_cyclicrefresh.h', # MANUAL
+	# 'encoder/vp9_aq_complexity.h', # MANUAL
+	# 'encoder/vp9_alt_ref_aq.h', # MANUAL
+	'encoder/vp9_skin_detection.h',
+	'encoder/vp9_noise_estimate.h',
+	'encoder/vp9_ext_ratectrl.h',
+	'encoder/vp9_temporal_filter.h',
+	'encoder/vp9_mbgraph.h',
+)
+
+vp9_cx_headers_optional_sources = {
+	'internal_stats' : files(
+		'encoder/vp9_blockiness.h',
+		'common/vp9_postproc.h'
+	),
+	'msa' : files(
+		# 'encoder/mips/msa/vp9_fdct_msa.h' # MANUAL
+	),
+	'non_greedy_mv' : files(
+		'encoder/vp9_non_greedy_mv.h'
+	),
+	'sse4_1' : files(
+		# 'encoder/x86/temporal_filter_constants.h' # MANUAL
+	),
+	'vp9_temporal_denoising' : files(
+		'encoder/vp9_denoiser.h'
+	),
+}
+
+vp9_cx_remove_headers_optional_sources = {
+	'realtime_only' : files(
+		'encoder/x86/temporal_filter_constants.h',
+		'encoder/vp9_alt_ref_aq.h',
+		'encoder/vp9_aq_variance.h',
+		'encoder/vp9_aq_360.h',
+		'encoder/vp9_aq_complexity.h'
+	),
+}
+
+vp9_dx_headers_sources = files(
+	'vp9_dx_iface.h',
+	'decoder/vp9_decodeframe.h',
+	'decoder/vp9_decodemv.h',
+	'decoder/vp9_detokenize.h',
+	'decoder/vp9_decoder.h',
+	'decoder/vp9_dsubexp.h',
+	'decoder/vp9_job_queue.h',
+)
+
+vp9_dx_headers_optional_sources = {
+}
+
+vp9_common_asm_optional_sources = {
+	'sse2' : files(
+		# 'common/x86/vp9_mfqe_sse2.asm' # MANUAL
+	),
+}
+
+if features.get('vp9_postproc', false) # MANUAL
+	vp9_common_optional_sources += {
+		'sse2': vp9_common_asm_optional_sources['sse2'] + files(
+			'common/x86/vp9_mfqe_sse2.asm'
+		)
+	}
+endif
+
+vp9_cx_asm_optional_sources = {
+	'sse2' : files(
+		'encoder/x86/vp9_dct_sse2.asm',
+		'encoder/x86/vp9_error_sse2.asm'
+	),
+}
+
+if features.get('vp9_temporal_denoising', false)
+	vp9_cx_optional_sources += {
+		'sse2' : vp9_cx_optional_sources['sse2'] + files(
+			'encoder/x86/vp9_denoiser_sse2.c',
+		),
+		'neon' : vp9_cx_optional_sources['neon'] + files(
+			'encoder/arm/neon/vp9_denoiser_neon.c',
+		),
+	}
+endif
+
+if features.get('vp9_highbitdepth', false)
+	vp9_cx_optional_sources += {
+		'sse2' : vp9_cx_optional_sources['sse2'] + files(
+			'encoder/x86/vp9_highbd_block_error_intrin_sse2.c',
+		),
+	}
+else
+	vp9_cx_optional_sources += {
+		'neon' : vp9_cx_optional_sources['neon'] + files(
+			'encoder/arm/neon/vp9_error_neon.c',
+		),
+		'msa' : vp9_cx_optional_sources['msa'] + files(
+			'encoder/mips/msa/vp9_fdct4x4_msa.c',
+			'encoder/mips/msa/vp9_fdct8x8_msa.c',
+			'encoder/mips/msa/vp9_fdct16x16_msa.c'
+		),
+	}
+
+	vp9_cx_headers_optional_sources += {
+		'msa' : vp9_cx_headers_optional_sources['msa'] + files(
+			'encoder/mips/msa/vp9_fdct_msa.h'
+		),
+	}
+endif
+
+if not features.get('realtime_only', false)
+	vp9_cx_sources += files(
+		'encoder/vp9_firstpass.c',
+		'encoder/vp9_mbgraph.c',
+		'encoder/vp9_temporal_filter.c',
+		'encoder/vp9_alt_ref_aq.c',
+		'encoder/vp9_aq_variance.c',
+		'encoder/vp9_aq_360.c',
+		'encoder/vp9_aq_complexity.c'
+	)
+
+	vp9_cx_headers_sources += files(
+		'encoder/vp9_alt_ref_aq.h',
+		'encoder/vp9_aq_variance.h',
+		'encoder/vp9_aq_360.h',
+		'encoder/vp9_aq_complexity.h'
+	)
+
+	vp9_cx_optional_sources += {
+		'sse4_1' : vp9_cx_optional_sources['sse4_1'] + files(
+			'encoder/x86/temporal_filter_sse4.c',
+		),
+	}
+
+	vp9_cx_headers_optional_sources += {
+		'sse4_1' : vp9_cx_headers_optional_sources['sse4_1'] + files(
+			'encoder/x86/temporal_filter_constants.h'
+		),
+	}
+
+	if not features.get('vp9_highbitdepth', true)
+		vp9_cx_optional_sources += {
+			'sse4_1' : vp9_cx_optional_sources['sse4_1'] + files(
+				'encoder/x86/highbd_temporal_filter_sse4.c',
+			),
+		}
+	endif
+endif
+
+#### --- END GENERATED --- ####
+
+codec_srcs += vp9_common_sources
+optional_sources = get_variable('vp9_common_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		codec_arch_srcs += {
+			comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+		}
+	else
+		codec_srcs += comp_sources
+	endif
+endforeach
+
+
+optional_sources = get_variable('vp9_common_asm_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		transformed_sources = comp_sources
+		if asm_conversion_exe.found()
+			transformed_sources = asm_transformer.process(comp_sources)
+		endif
+		codec_arch_srcs += {
+			comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+		}
+	else
+		codec_srcs += comp_sources
+	endif
+endforeach
+
+codec_headers += vp9_common_headers_sources
+optional_sources = get_variable('vp9_common_headers_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		codec_arch_headers += {
+			comp_name: codec_arch_headers.get(comp_name, []) + comp_sources
+		}
+	else
+		codec_headers += comp_sources
+	endif
+endforeach
+
+if features.get('vp9_encoder', false)
+	codec_srcs += vp9_cx_sources
+	codec_headers += vp9_cx_headers_sources
+
+	optional_sources = get_variable('vp9_cx_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+			}
+		else
+			codec_srcs += comp_sources
+		endif
+	endforeach
+
+	optional_sources = get_variable('vp9_cx_asm_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			transformed_sources = comp_sources
+			if asm_conversion_exe.found()
+				transformed_sources = asm_transformer.process(comp_sources)
+			endif
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+			}
+		else
+			codec_srcs += comp_sources
+		endif
+	endforeach
+
+	optional_sources = get_variable('vp9_cx_headers_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			codec_arch_headers += {
+				comp_name: codec_arch_headers.get(comp_name, []) + comp_sources
+			}
+		else
+			codec_headers += comp_sources
+		endif
+	endforeach
+endif
+
+if features.get('vp9_encoder', false)
+	codec_srcs += vp9_dx_sources
+	codec_headers += vp9_dx_headers_sources
+
+	optional_sources = get_variable('vp9_dx_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+			}
+		else
+			codec_srcs += comp_sources
+		endif
+	endforeach
+
+	optional_sources = get_variable('vp9_dx_asm_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			transformed_sources = comp_sources
+			if asm_conversion_exe.found()
+				transformed_sources = asm_transformer.process(comp_sources)
+			endif
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+			}
+		else
+			codec_srcs += comp_sources
+		endif
+	endforeach
+
+	optional_sources = get_variable('vp9_dx_headers_optional_sources', {})
+	foreach comp_name, comp_sources : optional_sources
+		if not features.get(comp_name, false)
+			continue
+		elif ARCH_EXT_LIST.contains(comp_name)
+			codec_arch_headers += {
+				comp_name: codec_arch_headers.get(comp_name, []) + comp_sources
+			}
+		else
+			codec_headers += comp_sources
+		endif
+	endforeach
+endif
+
+vp9_rtcd_defs = files(
+	'common/vp9_rtcd_defs.pl',
+)
+codec_rtcds += {
+	'vp9_rtcd': vp9_rtcd_defs[0]
+}
+
+codec_headers += vp9_rtcd_defs
+
+if features.get('vp9_encoder', false)
+	codec_exports += files(
+		'exports_enc',
+	)
+endif
+
+if features.get('vp9_decoder', false)
+	codec_exports += files(
+		'exports_dec',
+	)
+endif
diff --git a/vpx/meson.build b/vpx/meson.build
new file mode 100644
index 000000000..08f178d14
--- /dev/null
+++ b/vpx/meson.build
@@ -0,0 +1,136 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+# vpx_codec.mk
+
+#### --- GENERATED --- ####
+
+api_sources = files(
+	'src/vpx_decoder.c',
+	'src/vpx_encoder.c',
+	'src/vpx_codec.c',
+	'src/vpx_image.c',
+)
+
+api_optional_sources = {
+}
+
+api_headers_sources = files(
+	'vpx_decoder.h',
+	'vpx_encoder.h',
+	'internal/vpx_codec_internal.h',
+	'internal/vpx_ratectrl_rtc.h',
+	'vpx_codec.h',
+	'vpx_frame_buffer.h',
+	'vpx_image.h',
+	'vpx_integer.h',
+	'vpx_ext_ratectrl.h',
+)
+
+api_headers_optional_sources = {
+	'vp8_decoder' : files(
+		'vp8.h',
+		'vp8dx.h'
+	),
+	'vp8_encoder' : files(
+		'vp8.h',
+		'vp8cx.h'
+	),
+}
+
+api_doc_headers_sources = files(
+	'vpx_codec.h',
+	'vpx_decoder.h',
+	'vpx_encoder.h',
+	'vpx_ext_ratectrl.h',
+	'vpx_frame_buffer.h',
+	'vpx_image.h',
+)
+
+api_doc_headers_optional_sources = {
+	'vp8_decoder' : files(
+		'vp8.h',
+		'vp8dx.h'
+	),
+	'vp8_encoder' : files(
+		'vp8.h',
+		'vp8cx.h'
+	),
+}
+
+#### --- END GENERATED --- ####
+
+codec_srcs += api_sources
+optional_sources = get_variable('api_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		codec_arch_srcs += {
+			comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+		}
+	else
+		codec_srcs += comp_sources
+	endif
+endforeach
+
+codec_headers += api_headers_sources
+optional_sources = get_variable('api_headers_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		codec_arch_headers += {
+			comp_name: codec_arch_headers.get(comp_name, []) + comp_sources
+		}
+	else
+		api_headers_sources += comp_sources
+	endif
+endforeach
+
+codec_doc_srcs += api_doc_headers_sources
+optional_sources = get_variable('api_doc_headers_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if features.get(comp_name, false)
+		codec_doc_srcs += comp_sources
+	endif
+endforeach
+
+if features.get('vp9_encoder', false)
+	codec_doc_srcs += files(
+		'vp8.h',
+		'vp8cx.h',
+		'vpx_ext_ratectrl.h'
+	)
+
+	codec_doc_sections += ['vp9', 'vp9_encoder']
+endif
+
+if features.get('vp9_decoder', false)
+	codec_doc_srcs += files(
+		'vp8.h',
+		'vp8dx.h',
+	)
+
+	codec_doc_sections += ['vp9', 'vp9_decoder']
+endif
+
+codec_exports += files(
+	'exports_com'
+)
+
+if features.get('encoders', false)
+	codec_exports += files(
+		'exports_enc',
+	)
+
+	codec_doc_sections += ['encoder']
+endif
+
+if features.get('decoders', false)
+	codec_exports += files(
+		'exports_dec',
+	)
+
+	codec_doc_sections += ['decoder']
+endif
diff --git a/vpx_dsp/arm/meson.build b/vpx_dsp/arm/meson.build
new file mode 100644
index 000000000..31572e54c
--- /dev/null
+++ b/vpx_dsp/arm/meson.build
@@ -0,0 +1,12 @@
+#### --- MANUAL --- ####
+
+# inverse transform
+if features.get('vp9', true) # MANUAL
+	if features.get('neon_asm', false)
+		dsp_sources += configure_file(
+			command: [stdinout_wrapper_exe, '--input', '@INPUT@', '--output', '@OUTPUT@', asm_conversion_exe.full_path()] + asm_conversion_cmd,
+			input: 'idct_neon.asm',
+			output: 'idct_neon.asm.S'
+		)
+	endif
+endif
diff --git a/vpx_dsp/meson.build b/vpx_dsp/meson.build
new file mode 100644
index 000000000..6369dde50
--- /dev/null
+++ b/vpx_dsp/meson.build
@@ -0,0 +1,1206 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+# vpx_dsp.mk
+
+#### --- GENERATED --- ####
+
+dsp_sources = files(
+	'prob.c',
+	# 'bitwriter.c', # MANUAL
+	# 'bitwriter_buffer.c', # MANUAL
+	# 'psnr.c', # MANUAL
+	# 'bitreader.c', # MANUAL
+	# 'bitreader_buffer.c', # MANUAL
+	'intrapred.c',
+	# 'add_noise.c', # MANUAL
+	# 'deblock.c', # MANUAL
+	# 'vpx_convolve.c', # MANUAL
+	# 'arm/vpx_convolve_copy_neon_asm.asm', # MANUAL
+	# 'arm/vpx_convolve8_horiz_filter_type2_neon.asm', # MANUAL
+	# 'arm/vpx_convolve8_vert_filter_type2_neon.asm', # MANUAL
+	# 'arm/vpx_convolve8_horiz_filter_type1_neon.asm', # MANUAL
+	# 'arm/vpx_convolve8_vert_filter_type1_neon.asm', # MANUAL
+	# 'arm/vpx_convolve8_avg_horiz_filter_type2_neon.asm', # MANUAL
+	# 'arm/vpx_convolve8_avg_vert_filter_type2_neon.asm', # MANUAL
+	# 'arm/vpx_convolve8_avg_horiz_filter_type1_neon.asm', # MANUAL
+	# 'arm/vpx_convolve8_avg_vert_filter_type1_neon.asm', # MANUAL
+	# 'arm/vpx_convolve_avg_neon_asm.asm', # MANUAL
+	# 'arm/vpx_convolve8_neon_asm.c', # MANUAL
+	# 'arm/vpx_convolve_neon.c', # MANUAL
+	# 'arm/vpx_convolve_copy_neon.c', # MANUAL
+	# 'arm/vpx_convolve8_neon.c', # MANUAL
+	# 'arm/vpx_convolve_avg_neon.c', # MANUAL
+	# 'arm/vpx_convolve_neon.c', # MANUAL
+	# 'loopfilter.c', # MANUAL
+	# 'arm/loopfilter_16_neon.asm', # MANUAL
+	# 'arm/loopfilter_8_neon.asm', # MANUAL
+	# 'arm/loopfilter_4_neon.asm', # MANUAL
+	# 'fwd_txfm.c', # MANUAL
+	# 'inv_txfm.c', # MANUAL
+	# 'arm/idct_neon.asm', # MANUAL
+	# 'arm/idct4x4_1_add_neon.asm', # MANUAL
+	# 'arm/idct4x4_add_neon.asm', # MANUAL
+	# 'quantize.c', # MANUAL
+	# 'avg.c', # MANUAL
+	'skin_detection.c',
+	# 'sad.c', # MANUAL
+	# 'subtract.c', # MANUAL
+	# 'sum_squares.c', # MANUAL
+	# 'variance.c', # MANUAL
+	'vpx_dsp_rtcd.c',
+)
+
+dsp_optional_sources = {
+	'avx' : files(
+		# 'x86/quantize_avx.c' # MANUAL
+	),
+	'avx2' : files(
+		# 'x86/vpx_subpixel_8t_intrin_avx2.c', # MANUAL
+		# 'x86/highbd_convolve_avx2.c', # MANUAL
+		# 'x86/loopfilter_avx2.c', # MANUAL
+		# 'x86/fwd_txfm_avx2.c', # MANUAL
+		# 'x86/quantize_avx2.c', # MANUAL
+		# 'x86/highbd_quantize_intrin_avx2.c', # MANUAL
+		# 'x86/avg_intrin_avx2.c', # MANUAL
+		# 'x86/sad4d_avx2.c', # MANUAL
+		# 'x86/sad_avx2.c', # MANUAL
+		# 'x86/subtract_avx2.c', # MANUAL
+		# 'x86/highbd_sad4d_avx2.c', # MANUAL
+		# 'x86/highbd_sad_avx2.c', # MANUAL
+		# 'x86/variance_avx2.c' # MANUAl
+	),
+	'avx512' : files(
+		# 'x86/sad4d_avx512.c' # MANUAL
+	),
+	'dspr2' : files(
+		'mips/intrapred4_dspr2.c',
+		'mips/intrapred8_dspr2.c',
+		'mips/intrapred16_dspr2.c',
+		'mips/common_dspr2.c',
+		# 'mips/convolve2_avg_dspr2.c', # MANUAL
+		# 'mips/convolve2_avg_horiz_dspr2.c', # MANUAL
+		# 'mips/convolve2_dspr2.c', # MANUAL
+		# 'mips/convolve2_horiz_dspr2.c', # MANUAL
+		# 'mips/convolve2_vert_dspr2.c', # MANUAL
+		# 'mips/convolve8_avg_dspr2.c', # MANUAL
+		# 'mips/convolve8_avg_horiz_dspr2.c', # MANUAL
+		# 'mips/convolve8_dspr2.c', # MANUAL
+		# 'mips/convolve8_horiz_dspr2.c', # MANUAL
+		# 'mips/convolve8_vert_dspr2.c', # MANUAL
+		# 'mips/loopfilter_filters_dspr2.c', # MANUAL
+		# 'mips/loopfilter_mb_dspr2.c', # MANUAL
+		# 'mips/loopfilter_mb_horiz_dspr2.c', # MANUAL
+		# 'mips/loopfilter_mb_vert_dspr2.c', # MANUAL
+		# 'mips/itrans4_dspr2.c', # MANUAL
+		# 'mips/itrans8_dspr2.c', # MANUAL
+		# 'mips/itrans16_dspr2.c', # MANUAL
+		# 'mips/itrans32_dspr2.c', # MANUAL
+		# 'mips/itrans32_cols_dspr2.c' # MANUAL
+	),
+	'internal_stats' : files(
+		# 'ssim.c', # MANUAL
+		# 'psnrhvs.c', # MANUAL
+		# 'fastssim.c' # MANUAL
+	),
+	'lsx' : files(
+		'loongarch/intrapred_lsx.c',
+		# 'loongarch/vpx_convolve8_avg_horiz_lsx.c', # MANUAL
+		# 'loongarch/vpx_convolve8_avg_vert_lsx.c', # MANUAL
+		# 'loongarch/vpx_convolve8_horiz_lsx.c', # MANUAL
+		# 'loongarch/vpx_convolve8_vert_lsx.c', # MANUAL
+		# 'loongarch/vpx_convolve8_lsx.c', # MANUAL
+		# 'loongarch/vpx_convolve8_avg_lsx.c', # MANUAL
+		# 'loongarch/vpx_convolve_avg_lsx.c', # MANUAL
+		# 'loongarch/vpx_convolve_copy_lsx.c', # MANUAL
+		# 'loongarch/loopfilter_16_lsx.c', # MANUAL
+		# 'loongarch/loopfilter_8_lsx.c', # MANUAL
+		# 'loongarch/loopfilter_4_lsx.c', # MANUAL
+		# 'loongarch/fwd_txfm_lsx.c', # MANUAL
+		# 'loongarch/fwd_dct32x32_lsx.c', # MANUAL
+		# 'loongarch/idct32x32_lsx.c', # MANUAL
+		# 'loongarch/quantize_lsx.c', # MANUAL
+		# 'loongarch/avg_lsx.c', # MANUAL
+		# 'loongarch/sad_lsx.c', # MANUAL
+		# 'loongarch/subtract_lsx.c', # MANUAL
+		# 'loongarch/variance_lsx.c', # MANUAL
+		# 'loongarch/sub_pixel_variance_lsx.c', # MANUAL
+		# 'loongarch/avg_pred_lsx.c' # MANUAl
+	),
+	'mmi' : files(
+		# 'mips/vpx_convolve8_mmi.c', # MANUAL
+		# 'mips/sad_mmi.c', # MANUAL
+		# 'mips/subtract_mmi.c', # MANUAL
+		# 'mips/variance_mmi.c' # MANUAl
+	),
+	'msa' : files(
+		# 'mips/add_noise_msa.c', # MANUAL
+		# 'mips/deblock_msa.c', # MANUAL
+		'mips/intrapred_msa.c',
+		# 'mips/vpx_convolve8_avg_horiz_msa.c', # MANUAL
+		# 'mips/vpx_convolve8_avg_msa.c', # MANUAL
+		# 'mips/vpx_convolve8_avg_vert_msa.c', # MANUAL
+		# 'mips/vpx_convolve8_horiz_msa.c', # MANUAL
+		# 'mips/vpx_convolve8_msa.c', # MANUAL
+		# 'mips/vpx_convolve8_vert_msa.c', # MANUAL
+		# 'mips/vpx_convolve_avg_msa.c', # MANUAL
+		# 'mips/vpx_convolve_copy_msa.c', # MANUAL
+		# 'mips/loopfilter_16_msa.c', # MANUAL
+		# 'mips/loopfilter_8_msa.c', # MANUAL
+		# 'mips/loopfilter_4_msa.c', # MANUAL
+		# 'mips/fwd_txfm_msa.c', # MANUAL
+		# 'mips/fwd_dct32x32_msa.c', # MANUAL
+		# 'mips/idct4x4_msa.c', # MANUAL
+		# 'mips/idct8x8_msa.c', # MANUAL
+		# 'mips/idct16x16_msa.c', # MANUAL
+		# 'mips/idct32x32_msa.c', # MANUAL
+		# 'mips/avg_msa.c', # MANUAL
+		# 'mips/sum_squares_msa.c', # MANUAL
+		# 'mips/sad_msa.c', # MANUAL
+		# 'mips/subtract_msa.c', # MANUAL
+		# 'mips/variance_msa.c', # MANUAL
+		# 'mips/sub_pixel_variance_msa.c' # MANUAL
+	),
+	'neon' : files(
+		# 'arm/highbd_intrapred_neon.c', # MANUAL
+		# 'arm/deblock_neon.c', # MANUAL
+		'arm/intrapred_neon.c',
+		# 'arm/highbd_vpx_convolve_copy_neon.c', # MANUAL
+		# 'arm/highbd_vpx_convolve_avg_neon.c', # MANUAL
+		# 'arm/highbd_vpx_convolve8_neon.c', # MANUAL
+		# 'arm/highbd_vpx_convolve_neon.c', # MANUAL
+		# 'arm/vpx_scaled_convolve8_neon.c', # MANUAL
+		# 'arm/loopfilter_neon.c', # MANUAL
+		# 'arm/highbd_loopfilter_neon.c', # MANUAL
+		# 'arm/fdct4x4_neon.c', # MANUAL
+		# 'arm/fdct8x8_neon.c', # MANUAL
+		# 'arm/fdct16x16_neon.c', # MANUAL
+		# 'arm/fdct32x32_neon.c', # MANUAL
+		# 'arm/fdct_partial_neon.c', # MANUAL
+		# 'arm/highbd_idct4x4_add_neon.c', # MANUAL
+		# 'arm/highbd_idct8x8_add_neon.c', # MANUAL
+		# 'arm/highbd_idct16x16_add_neon.c', # MANUAL
+		# 'arm/highbd_idct32x32_add_neon.c', # MANUAL
+		# 'arm/highbd_idct32x32_34_add_neon.c', # MANUAL
+		# 'arm/highbd_idct32x32_135_add_neon.c', # MANUAL
+		# 'arm/highbd_idct32x32_1024_add_neon.c', # MANUAL
+		# 'arm/idct4x4_1_add_neon.c', # MANUAL
+		# 'arm/idct4x4_add_neon.c', # MANUAL
+		# 'arm/idct8x8_1_add_neon.c', # MANUAL
+		# 'arm/idct8x8_add_neon.c', # MANUAL
+		# 'arm/idct16x16_1_add_neon.c', # MANUAL
+		# 'arm/idct16x16_add_neon.c', # MANUAL
+		# 'arm/idct32x32_1_add_neon.c', # MANUAL
+		# 'arm/idct32x32_34_add_neon.c', # MANUAL
+		# 'arm/idct32x32_135_add_neon.c', # MANUAL
+		# 'arm/idct32x32_add_neon.c', # MANUAL
+		# 'arm/quantize_neon.c', # MANUAL
+		# 'arm/highbd_quantize_neon.c', # MANUAL
+		# 'arm/avg_neon.c', # MANUAL
+		# 'arm/hadamard_neon.c', # MANUAL
+		# 'arm/sum_squares_neon.c', # MANUAL
+		# 'arm/sad4d_neon.c', # MANUAL
+		# 'arm/sad_neon.c', # MANUAL
+		# 'arm/subtract_neon.c', # MANUAL
+		# 'arm/highbd_sad_neon.c', # MANUAL
+		# 'arm/avg_pred_neon.c', # MANUAL
+		# 'arm/subpel_variance_neon.c', # MANUAL
+		# 'arm/variance_neon.c', # MANUAL
+		# 'arm/highbd_variance_neon.c' # MANUAL
+	),
+	'neon_asm' : files(
+		# 'arm/intrapred_neon_asm.asm', # MANUAL
+		# 'arm/save_reg_neon.asm' # MANUAL
+	),
+	'sse2' : files(
+		# 'x86/highbd_intrapred_intrin_sse2.c', # MANUAL
+		# 'x86/post_proc_sse2.c', # MANUAL
+		# 'x86/vpx_subpixel_4t_intrin_sse2.c', # MANUAL
+		# 'x86/loopfilter_sse2.c', # MANUAL
+		# 'x86/highbd_loopfilter_sse2.c', # MANUAL
+		# 'x86/fwd_txfm_sse2.c', # MANUAL
+		# 'x86/inv_txfm_sse2.c', # MANUAL
+		# 'x86/highbd_idct4x4_add_sse2.c', # MANUAL
+		# 'x86/highbd_idct8x8_add_sse2.c', # MANUAL
+		# 'x86/highbd_idct16x16_add_sse2.c', # MANUAL
+		# 'x86/highbd_idct32x32_add_sse2.c', # MANUAL
+		# 'x86/quantize_sse2.c', # MANUAL
+		# 'x86/highbd_quantize_intrin_sse2.c', # MANUAL
+		# 'x86/avg_intrin_sse2.c', # MANUAL
+		# 'x86/sum_squares_sse2.c', # MANUAL
+		# 'x86/avg_pred_sse2.c', # MANUAL
+		# 'x86/variance_sse2.c', # MANUAL
+		# 'x86/highbd_variance_sse2.c' # MANUAL
+	),
+	'sse4_1' : files(
+		# 'x86/highbd_idct4x4_add_sse4.c', # MANUAL
+		# 'x86/highbd_idct8x8_add_sse4.c', # MANUAL
+		# 'x86/highbd_idct16x16_add_sse4.c', # MANUAL
+		# 'x86/highbd_idct32x32_add_sse4.c' # MANUAL
+	),
+	'ssse3' : files(
+		# 'x86/highbd_intrapred_intrin_ssse3.c', # MANUAL
+		# 'x86/vpx_subpixel_8t_intrin_ssse3.c', # MANUAL
+		# 'x86/inv_txfm_ssse3.c', # MANUAL
+		# 'x86/quantize_ssse3.c' # MANUAL
+	),
+	'vsx' : files(
+		'ppc/intrapred_vsx.c',
+		# 'ppc/deblock_vsx.c', # MANUAL
+		# 'ppc/vpx_convolve_vsx.c', # MANUAL
+		# 'ppc/fdct32x32_vsx.c', # MANUAL
+		# 'ppc/inv_txfm_vsx.c', # MANUAL
+		# 'ppc/quantize_vsx.c', # MANUAL
+		# 'ppc/hadamard_vsx.c', # MANUAL
+		# 'ppc/sad_vsx.c', # MANUAL
+		# 'ppc/subtract_vsx.c', # MANUAl
+		# 'ppc/variance_vsx.c' # MANUAl
+	),
+}
+
+dsp_headers_sources = files(
+	'vpx_dsp_common.h',
+	'prob.h',
+	# 'bitwriter.h', # MANUAL
+	# 'bitwriter_buffer.h', # MANUAL
+	# 'psnr.h', # MANUAL
+	# 'bitreader.h', # MANUAL
+	# 'bitreader_buffer.h', # MANUAL
+	# 'postproc.h', # MANUAL
+	'vpx_filter.h',
+	# 'vpx_convolve.h', # MANUAL
+	# 'arm/vpx_convolve8_neon_asm.h', # MANUAL
+	'txfm_common.h',
+	# 'fwd_txfm.h', # MANUAL
+	# 'inv_txfm.h', # MANUAL
+	# 'quantize.h', # MANUAL
+	'skin_detection.h',
+	# 'variance.h', # MANUAL
+)
+
+dsp_headers_optional_sources = {
+	'avx2' : files(
+		'x86/bitdepth_conversion_avx2.h',
+		# 'x86/convolve_avx2.h', # MANUAL
+		# 'x86/fwd_dct32x32_impl_avx2.h' # MANUAL
+	),
+	'dspr2' : files(
+		'mips/common_dspr2.h',
+		# 'mips/convolve_common_dspr2.h', # MANUAL
+		# 'mips/loopfilter_filters_dspr2.h', # MANUAL
+		# 'mips/loopfilter_macros_dspr2.h', # MANUAL
+		# 'mips/loopfilter_masks_dspr2.h', # MANUAL
+		# 'mips/inv_txfm_dspr2.h' # MANUAL
+	),
+	'internal_stats' : files(
+		# 'ssim.h' # MANUAL
+	),
+	'lsx' : files(
+		# 'loongarch/vpx_convolve_lsx.h', # MANUAL
+		# 'loongarch/loopfilter_lsx.h', # MANUAL
+		'loongarch/txfm_macros_lsx.h',
+		# 'loongarch/fwd_txfm_lsx.h', # MANUAL
+		# 'loongarch/variance_lsx.h', # MANUAL
+		'loongarch/bitdepth_conversion_lsx.h'
+	),
+	'msa' : files(
+		'mips/macros_msa.h',
+		# 'mips/vpx_convolve_msa.h', # MANUAL
+		# 'mips/loopfilter_msa.h', # MANUAL
+		'mips/txfm_macros_msa.h',
+		# 'mips/fwd_txfm_msa.h', # MANUAL
+		# 'mips/inv_txfm_msa.h' # MANUAL
+	),
+	'neon' : files(
+		# 'arm/highbd_idct_neon.h', # MANUAL
+		'arm/idct_neon.h',
+		'arm/mem_neon.h',
+		'arm/sum_neon.h',
+		'arm/transpose_neon.h',
+		'arm/vpx_convolve8_neon.h'
+	),
+	'sse2' : files(
+		'x86/bitdepth_conversion_sse2.h',
+		# 'x86/convolve_sse2.h', # MANUAL
+		'x86/txfm_common_sse2.h',
+		# 'x86/fwd_txfm_sse2.h', # MANUAL
+		# 'x86/fwd_txfm_impl_sse2.h', # MANUAL
+		# 'x86/fwd_dct32x32_impl_sse2.h', # MANUAL
+		# 'x86/inv_txfm_sse2.h', # MANUAL
+		# 'x86/highbd_inv_txfm_sse2.h', # MANUAL
+		# 'x86/quantize_sse2.h', # MANUAL
+		'x86/mem_sse2.h',
+		'x86/transpose_sse2.h'
+	),
+	'sse4_1' : files(
+		# 'x86/highbd_inv_txfm_sse4.h' # MANUAL
+	),
+	'ssse3' : files(
+		# 'x86/convolve_ssse3.h', # MANUAL
+		# 'x86/inv_txfm_ssse3.h', # MANUAL
+		# 'x86/quantize_ssse3.h' # MANUAL
+	),
+	'vsx' : files(
+		'ppc/types_vsx.h',
+		'ppc/txfm_common_vsx.h',
+		'ppc/transpose_vsx.h',
+		'ppc/bitdepth_conversion_vsx.h'
+	),
+}
+
+dsp_asm_optional_sources = {
+	'sse2' : files(
+		'x86/intrapred_sse2.asm',
+		# 'x86/highbd_intrapred_sse2.asm', # MANUAL
+		# 'x86/add_noise_sse2.asm', # MANUAL
+		# 'x86/deblock_sse2.asm', # MANUAL
+		# 'x86/vpx_subpixel_8t_sse2.asm', # MANUAL
+		# 'x86/vpx_subpixel_bilinear_sse2.asm', # MANUAL
+		# 'x86/vpx_high_subpixel_8t_sse2.asm', # MANUAL
+		# 'x86/vpx_high_subpixel_bilinear_sse2.asm', # MANUAL
+		# 'x86/vpx_convolve_copy_sse2.asm', # MANUAL
+		# 'x86/inv_wht_sse2.asm', # MANUAL
+		# 'x86/sad4d_sse2.asm', # MANUAL
+		# 'x86/sad_sse2.asm', # MANUAL
+		# 'x86/subtract_sse2.asm', # MANUAL
+		# 'x86/highbd_sad4d_sse2.asm', # MANUAL
+		# 'x86/highbd_sad_sse2.asm', # MANUAL
+		# 'x86/ssim_opt_x86_64.asm', # MANUAL
+		# 'x86/subpel_variance_sse2.asm', # MANUAL
+		# 'x86/highbd_variance_impl_sse2.asm', # MANUAL
+		# 'x86/highbd_subpel_variance_impl_sse2.asm' # MANUAL
+	),
+	'ssse3' : files(
+		'x86/intrapred_ssse3.asm',
+		# 'x86/vpx_subpixel_8t_ssse3.asm', # MANUAL
+		# 'x86/vpx_subpixel_bilinear_ssse3.asm', # MANUAL
+		# 'x86/fwd_txfm_ssse3_x86_64.asm', # MANUAL
+		# 'x86/avg_ssse3_x86_64.asm' # MANUAL
+	),
+}
+
+
+if features.get('encoders', false) # MANUAL
+	dsp_sources += files(
+		'bitwriter.c',
+		'bitwriter_buffer.c',
+		'psnr.c',
+	)
+
+	dsp_headers_sources += files(
+		'bitwriter.h',
+		'bitwriter_buffer.h',
+		'psnr.h',
+	)
+
+	dsp_optional_sources += {
+		'internal_stats' : dsp_optional_sources['internal_stats'] + files(
+			'ssim.c',
+			'psnrhvs.c',
+			'fastssim.c'
+		),
+	}
+
+	dsp_headers_optional_sources += {
+		'internal_stats' : dsp_headers_optional_sources['internal_stats'] + files(
+			'ssim.h'
+		),
+	}
+endif
+
+if features.get('encoders', false) # MANUAL
+	dsp_sources += files(
+		'bitreader.c',
+		'bitreader_buffer.c',
+	)
+
+	dsp_headers_sources += files(
+		'bitreader.h',
+		'bitreader_buffer.h',
+	)
+endif
+
+# intra predictions
+if features.get('vp9_highbitdepth', false) # MANUAL
+	dsp_asm_optional_sources += {
+		'sse2' : dsp_asm_optional_sources['sse2'] + files(
+			'x86/highbd_intrapred_sse2.asm',
+		)
+	}
+
+	dsp_optional_sources += {
+		'sse2' : dsp_optional_sources['sse2'] + files(
+			'x86/highbd_intrapred_intrin_sse2.c',
+		),
+		'ssse3' : dsp_optional_sources['ssse3'] + files(
+			'x86/highbd_intrapred_intrin_ssse3.c',
+		),
+		'neon' : dsp_optional_sources['ssse3'] + files(
+			'arm/highbd_intrapred_neon.c',
+		),
+	}
+endif
+
+# intra predictions
+if not features.get('postproc', false) or not features.get('vp9_postproc', false) # MANUAL
+	dsp_sources += files(
+		'add_noise.c',
+		'deblock.c',
+	)
+
+	dsp_headers_sources += files(
+		'postproc.h',
+	)
+
+	dsp_optional_sources += {
+		'msa' : dsp_optional_sources['msa'] + files(
+			'mips/add_noise_msa.c',
+			'mips/deblock_msa.c',
+		),
+		'neon' : dsp_optional_sources['neon'] + files(
+			'arm/deblock_neon.c',
+		),
+		'sse2' : dsp_optional_sources['sse2'] + files(
+			'x86/post_proc_sse2.c',
+		),
+		'vsx' : dsp_optional_sources['vsx'] + files(
+			'ppc/deblock_vsx.c',
+		),
+	}
+
+	dsp_asm_optional_sources += {
+		'sse2' : dsp_asm_optional_sources['sse2'] + files(
+			'x86/add_noise_sse2.asm',
+			'x86/deblock_sse2.asm',
+		),
+		'ssse3' : dsp_asm_optional_sources['ssse3'] + files(
+			'x86/vpx_subpixel_8t_ssse3.asm',
+			'x86/vpx_subpixel_bilinear_ssse3.asm',
+		)
+	}
+endif
+
+if features.get('neon_asm', false) # MANUAL
+	dsp_sources += asm_transformer.process(
+		files(
+			'arm/intrapred_neon_asm.asm',
+		)
+	)
+endif
+
+if features.get('vp9', false) # MANUAL
+	# interpolation filters
+
+	dsp_sources += files(
+		'vpx_convolve.c',
+		# loop filters
+		'loopfilter.c',
+	)
+
+	dsp_headers_sources += files(
+		'vpx_convolve.h',
+	)
+
+	dsp_headers_optional_sources += {
+		'x86' : files(
+			'x86/convolve.h',
+		),
+		'x86_64' : files(
+			'x86/convolve.h',
+		),
+		'sse2' : dsp_headers_optional_sources['sse2'] + files(
+			'x86/convolve_sse2.h',
+		),
+		'ssse3' : dsp_headers_optional_sources['ssse3'] + files(
+			'x86/convolve_ssse3.h',
+		),
+		'avx2' : dsp_headers_optional_sources['avx2'] + files(
+			'x86/convolve_avx2.h',
+		),
+		'msa' : dsp_headers_optional_sources['msa'] + files(
+			# common (msa)
+			'mips/vpx_convolve_msa.h',
+			# loop filters
+			'mips/loopfilter_msa.h',
+		),
+		'dspr2' : dsp_headers_optional_sources['dspr2'] + files(
+			# common (dspr2)
+			'mips/convolve_common_dspr2.h',
+			# loop filters
+			'mips/loopfilter_filters_dspr2.h',
+			'mips/loopfilter_macros_dspr2.h',
+			'mips/loopfilter_masks_dspr2.h',
+		),
+		'lsx' : dsp_headers_optional_sources['lsx'] + files(
+			# common (lsx)
+			'loongarch/vpx_convolve_lsx.h',
+			# loop filters
+			'loongarch/loopfilter_lsx.h',
+		)
+	}
+
+	dsp_asm_optional_sources += {
+		'sse2' : dsp_asm_optional_sources['sse2'] + files(
+			'x86/vpx_subpixel_8t_sse2.asm',
+			'x86/vpx_subpixel_bilinear_sse2.asm',
+			'x86/vpx_convolve_copy_sse2.asm',
+		)
+	}
+
+	dsp_optional_sources += {
+		'sse2' : dsp_optional_sources['sse2'] + files(
+			'x86/vpx_subpixel_4t_intrin_sse2.c',
+			# loop filters
+			'x86/loopfilter_sse2.c',
+		),
+		'avx2' : dsp_optional_sources['avx2'] + files(
+			'x86/vpx_subpixel_8t_intrin_avx2.c',
+			# loop filters
+			'x86/loopfilter_avx2.c',
+		),
+		'ssse3' : dsp_optional_sources['ssse3'] + files(
+			'x86/vpx_subpixel_8t_intrin_ssse3.c',
+		),
+		'neon' : dsp_optional_sources['neon'] + files(
+			'arm/vpx_scaled_convolve8_neon.c',
+		),
+		'msa' : dsp_optional_sources['msa'] + files(
+			# common (msa)
+			'mips/vpx_convolve8_avg_horiz_msa.c',
+			'mips/vpx_convolve8_avg_msa.c',
+			'mips/vpx_convolve8_avg_vert_msa.c',
+			'mips/vpx_convolve8_horiz_msa.c',
+			'mips/vpx_convolve8_msa.c',
+			'mips/vpx_convolve8_vert_msa.c',
+			'mips/vpx_convolve_avg_msa.c',
+			'mips/vpx_convolve_copy_msa.c',
+			# loop filters
+			'mips/loopfilter_16_msa.c',
+			'mips/loopfilter_8_msa.c',
+			'mips/loopfilter_4_msa.c',
+		),
+		'mmi' : dsp_optional_sources['mmi'] + files(
+			'mips/vpx_convolve8_mmi.c',
+		),
+		'dspr2' : dsp_optional_sources['dspr2'] + files(
+			# common (dspr2)
+			'mips/convolve2_avg_dspr2.c',
+			'mips/convolve2_avg_horiz_dspr2.c',
+			'mips/convolve2_dspr2.c',
+			'mips/convolve2_horiz_dspr2.c',
+			'mips/convolve2_vert_dspr2.c',
+			'mips/convolve8_avg_dspr2.c',
+			'mips/convolve8_avg_horiz_dspr2.c',
+			'mips/convolve8_dspr2.c',
+			'mips/convolve8_horiz_dspr2.c',
+			'mips/convolve8_vert_dspr2.c',
+			# loop filters
+			'mips/loopfilter_filters_dspr2.c',
+			'mips/loopfilter_mb_dspr2.c',
+			'mips/loopfilter_mb_horiz_dspr2.c',
+			'mips/loopfilter_mb_vert_dspr2.c',
+		),
+		'vsx' : dsp_optional_sources['vsx'] + files(
+			'ppc/vpx_convolve_vsx.c',
+		),
+		'lsx' : dsp_optional_sources['lsx'] + files(
+			# common (lsx)
+			'loongarch/vpx_convolve8_avg_horiz_lsx.c',
+			'loongarch/vpx_convolve8_avg_vert_lsx.c',
+			'loongarch/vpx_convolve8_horiz_lsx.c',
+			'loongarch/vpx_convolve8_vert_lsx.c',
+			'loongarch/vpx_convolve8_lsx.c',
+			'loongarch/vpx_convolve8_avg_lsx.c',
+			'loongarch/vpx_convolve_avg_lsx.c',
+			'loongarch/vpx_convolve_copy_lsx.c',
+			# loop filters
+			'loongarch/loopfilter_16_lsx.c',
+			'loongarch/loopfilter_8_lsx.c',
+			'loongarch/loopfilter_4_lsx.c',
+		)
+	}
+
+	if features.get('vp9_highbitdepth', false)
+		dsp_asm_optional_sources += {
+			'sse2' : dsp_asm_optional_sources['sse2'] + files(
+				'x86/vpx_high_subpixel_8t_sse2.asm',
+				'x86/vpx_high_subpixel_bilinear_sse2.asm',
+			)
+		}
+
+		dsp_optional_sources += {
+			'avx2' : dsp_optional_sources['avx2'] + files(
+				'x86/highbd_convolve_avx2.c'
+			),
+			'sse2' : dsp_optional_sources['sse2'] + files(
+				# loop filters
+				'x86/highbd_loopfilter_sse2.c'
+			),
+			'neon' : dsp_optional_sources['neon'] + files(
+				'arm/highbd_vpx_convolve_copy_neon.c',
+				'arm/highbd_vpx_convolve_avg_neon.c',
+				'arm/highbd_vpx_convolve8_neon.c',
+				'arm/highbd_vpx_convolve_neon.c',
+				# loop filters
+				'arm/highbd_loopfilter_neon.c',
+			)
+		}
+	endif
+
+	if features.get('neon_asm', false)
+		dsp_sources += asm_transformer.process(
+			files(
+				'arm/vpx_convolve_copy_neon_asm.asm',
+				'arm/vpx_convolve8_horiz_filter_type2_neon.asm',
+				'arm/vpx_convolve8_vert_filter_type2_neon.asm',
+				'arm/vpx_convolve8_horiz_filter_type1_neon.asm',
+				'arm/vpx_convolve8_vert_filter_type1_neon.asm',
+				'arm/vpx_convolve8_avg_horiz_filter_type2_neon.asm',
+				'arm/vpx_convolve8_avg_vert_filter_type2_neon.asm',
+				'arm/vpx_convolve8_avg_horiz_filter_type1_neon.asm',
+				'arm/vpx_convolve8_avg_vert_filter_type1_neon.asm',
+				'arm/vpx_convolve_avg_neon_asm.asm',
+				# loop filters
+				'arm/loopfilter_16_neon.asm',
+				'arm/loopfilter_8_neon.asm',
+				'arm/loopfilter_4_neon.asm',
+			)
+		)
+
+		dsp_sources += files(
+			'arm/vpx_convolve8_neon_asm.c',
+			'arm/vpx_convolve_neon.c',
+		)
+
+		dsp_headers_sources += files(
+			'arm/vpx_convolve8_neon_asm.h',
+		)
+	elif features.get('neon', false)
+		dsp_sources += files(
+			'arm/vpx_convolve_copy_neon.c',
+			'arm/vpx_convolve8_neon.c',
+			'arm/vpx_convolve_avg_neon.c',
+			'arm/vpx_convolve_neon.c',
+			# loop filters
+			'arm/loopfilter_neon.c',
+		)
+	endif
+endif
+
+# forward transform
+if features.get('vp9_encoder', false)
+	dsp_sources += files(
+		'fwd_txfm.c',
+	)
+
+	dsp_headers_sources += files(
+		'fwd_txfm.h',
+	)
+
+	dsp_headers_optional_sources += {
+		'sse2' : dsp_headers_optional_sources['sse2'] + files(
+			'x86/fwd_txfm_sse2.h',
+			'x86/fwd_txfm_impl_sse2.h',
+			'x86/fwd_dct32x32_impl_sse2.h',
+		),
+		'avx2' : dsp_headers_optional_sources['avx2'] + files(
+			'x86/fwd_dct32x32_impl_avx2.h'
+		),
+		'msa' : dsp_headers_optional_sources['msa'] + files(
+			'mips/fwd_txfm_msa.h'
+		),
+		'lsx' : dsp_headers_optional_sources['lsx'] + files(
+			'loongarch/fwd_txfm_lsx.h'
+		)
+	}
+
+	dsp_optional_sources += {
+		'sse2' : dsp_optional_sources['sse2'] + files(
+			'x86/fwd_txfm_sse2.c',
+		),
+		'neon': dsp_optional_sources['neon'] + files(
+			'arm/fdct4x4_neon.c',
+			'arm/fdct8x8_neon.c',
+			'arm/fdct16x16_neon.c',
+			'arm/fdct32x32_neon.c',
+			'arm/fdct_partial_neon.c',
+		),
+		'msa' : dsp_headers_optional_sources['msa'] + files(
+			'mips/fwd_txfm_msa.c',
+		),
+		'lsx' : dsp_headers_optional_sources['lsx'] + files(
+			'loongarch/fwd_txfm_lsx.c',
+		),
+		'vsx' : dsp_headers_optional_sources['vsx'] + files(
+			'ppc/fdct32x32_vsx.c',
+		),
+	}
+
+	if features.get('x86_64', false)
+		dsp_asm_optional_sources += {
+			'ssse3' : dsp_asm_optional_sources['ssse3'] + files(
+				'x86/fwd_txfm_ssse3_x86_64.asm',
+			)
+		}
+	endif
+
+	if not features.get('vp9_highbitdepth', false)
+		dsp_optional_sources += {
+			'avx2' : dsp_optional_sources['avx2'] + files(
+				'x86/fwd_txfm_avx2.c'
+			),
+			'msa' : dsp_optional_sources['msa'] + files(
+				# loop filters
+				'mips/fwd_dct32x32_msa.c'
+			),
+			'lsx' : dsp_optional_sources['lsx'] + files(
+				# loop filters
+				'loongarch/fwd_dct32x32_lsx.c',
+			)
+		}
+	endif
+endif
+
+# inverse transform
+if features.get('vp9', true) # MANUAL
+	dsp_sources += files(
+		'inv_txfm.c',
+	)
+
+	dsp_headers_sources += files(
+		'inv_txfm.h',
+	)
+
+	dsp_headers_optional_sources += {
+		'sse2' : dsp_headers_optional_sources['sse2'] + files(
+			'x86/inv_txfm_sse2.h',
+		),
+		'ssse3' : dsp_headers_optional_sources['ssse3'] + files(
+			'x86/inv_txfm_ssse3.h',
+		),
+	}
+
+	dsp_optional_sources += {
+		'sse2' : dsp_optional_sources['sse2'] + files(
+			'x86/inv_txfm_sse2.c',
+		),
+		'ssse3' : dsp_optional_sources['ssse3'] + files(
+			'x86/inv_txfm_ssse3.c',
+		),
+		'neon' : dsp_optional_sources['neon'] + files(
+			'arm/fdct4x4_neon.c',
+			'arm/fdct8x8_neon.c',
+			'arm/fdct16x16_neon.c',
+			'arm/fdct32x32_neon.c',
+			'arm/fdct_partial_neon.c',
+		),
+		'vsx' : dsp_optional_sources['vsx'] + files(
+			'ppc/inv_txfm_vsx.c',
+		)
+	}
+
+	dsp_asm_optional_sources += {
+		'sse2' : dsp_asm_optional_sources['sse2'] + files(
+			'x86/inv_wht_sse2.asm',
+		),
+	}
+
+	if features.get('neon_asm', false)
+		dsp_sources += asm_transformer.process(
+			files(
+				'arm/save_reg_neon.asm',
+			)
+		)
+	endif
+
+	if not features.get('vp9_highbitdepth', false)
+		dsp_headers_optional_sources += {
+			'msa' : dsp_headers_optional_sources['msa'] + files(
+				'mips/inv_txfm_msa.h',
+			),
+			'dspr2' : dsp_headers_optional_sources['dspr2'] + files(
+				'mips/inv_txfm_dspr2.h',
+			)
+		}
+
+		dsp_optional_sources += {
+			'msa' : dsp_optional_sources['msa'] + files(
+				'mips/idct4x4_msa.c',
+				'mips/idct8x8_msa.c',
+				'mips/idct16x16_msa.c',
+				'mips/idct32x32_msa.c',
+			),
+			'dspr2' : dsp_optional_sources['dspr2'] + files(
+				'mips/itrans4_dspr2.c',
+				'mips/itrans8_dspr2.c',
+				'mips/itrans16_dspr2.c',
+				'mips/itrans32_dspr2.c',
+				'mips/itrans32_cols_dspr2.c',
+			),
+			'lsx' : dsp_optional_sources['lsx'] + files(
+				'loongarch/idct32x32_lsx.c',
+			)
+		}
+	else
+		dsp_headers_optional_sources += {
+			'neon' : dsp_headers_optional_sources['neon'] + files(
+				'arm/highbd_idct_neon.h',
+			),
+			'sse2' : dsp_headers_optional_sources['sse2'] + files(
+				'x86/highbd_inv_txfm_sse2.h',
+			),
+			'sse4_1' : dsp_headers_optional_sources['sse4_1'] + files(
+				'x86/highbd_inv_txfm_sse4.h',
+			)
+		}
+
+		dsp_optional_sources += {
+			'neon' : dsp_optional_sources['neon'] + files(
+				'arm/highbd_idct4x4_add_neon.c',
+				'arm/highbd_idct8x8_add_neon.c',
+				'arm/highbd_idct16x16_add_neon.c',
+				'arm/highbd_idct32x32_add_neon.c',
+				'arm/highbd_idct32x32_34_add_neon.c',
+				'arm/highbd_idct32x32_135_add_neon.c',
+				'arm/highbd_idct32x32_1024_add_neon.c',
+			),
+			'sse2' : dsp_optional_sources['sse2'] + files(
+				'x86/highbd_idct4x4_add_sse2.c',
+				'x86/highbd_idct8x8_add_sse2.c',
+				'x86/highbd_idct16x16_add_sse2.c',
+				'x86/highbd_idct32x32_add_sse2.c',
+			),
+			'lsx' : dsp_optional_sources['lsx'] + files(
+				'x86/highbd_idct4x4_add_sse4.c',
+				'x86/highbd_idct8x8_add_sse4.c',
+				'x86/highbd_idct16x16_add_sse4.c',
+				'x86/highbd_idct32x32_add_sse4.c',
+			)
+		}
+	endif
+
+	if features.get('neon_asm', false)
+		dsp_sources += asm_transformer.process(
+			files(
+				'arm/idct4x4_1_add_neon.asm',
+				'arm/idct4x4_add_neon.asm',
+			)
+		)
+	else
+		dsp_optional_sources += {
+			'neon' : dsp_optional_sources['neon'] + files(
+				'arm/idct4x4_1_add_neon.c',
+				'arm/idct4x4_add_neon.c',
+			)
+		}
+	endif
+
+	dsp_optional_sources += {
+		'neon' : dsp_optional_sources['neon'] + files(
+			'arm/idct8x8_1_add_neon.c',
+			'arm/idct8x8_add_neon.c',
+			'arm/idct16x16_1_add_neon.c',
+			'arm/idct16x16_add_neon.c',
+			'arm/idct32x32_1_add_neon.c',
+			'arm/idct32x32_34_add_neon.c',
+			'arm/idct32x32_135_add_neon.c',
+			'arm/idct32x32_add_neon.c',
+		)
+	}
+endif
+
+# quantization
+if features.get('vp9_encoder', false) # MANUAL
+	dsp_sources += files(
+		'quantize.c',
+		# avg
+		'avg.c',
+	)
+
+	dsp_headers_sources += files(
+		'quantize.h',
+	)
+
+	dsp_optional_sources += {
+		'sse2' : dsp_optional_sources['sse2'] + files(
+			'x86/quantize_sse2.c',
+			# avg
+			'x86/avg_intrin_sse2.c',
+		),
+		'ssse3' : dsp_optional_sources['ssse3'] + files(
+			'x86/quantize_ssse3.c',
+		),
+		'avx' : dsp_optional_sources['avx'] + files(
+			'x86/quantize_avx.c',
+		),
+		'avx2' : dsp_optional_sources['avx2'] + files(
+			'x86/quantize_avx2.c',
+			# avg
+			'x86/avg_intrin_avx2.c',
+		),
+		'neon' : dsp_optional_sources['neon'] + files(
+			'arm/quantize_neon.c',
+			# avg
+			'arm/avg_neon.c',
+			'arm/hadamard_neon.c',
+		),
+		'vsx' : dsp_optional_sources['vsx'] + files(
+			'ppc/quantize_vsx.c',
+			# avg
+			'ppc/hadamard_vsx.c',
+		),
+		'lsx' : dsp_optional_sources['lsx'] + files(
+			'loongarch/quantize_lsx.c',
+			# avg
+			'loongarch/avg_lsx.c',
+		),
+		'msa' : dsp_optional_sources['msa'] + files(
+			# avg
+			'mips/avg_msa.c',
+		),
+	}
+
+	dsp_headers_optional_sources += {
+		'sse2' : dsp_headers_optional_sources['sse2'] + files(
+			'x86/quantize_sse2.h',
+		),
+		'ssse3' : dsp_headers_optional_sources['ssse3'] + files(
+			'x86/quantize_ssse3.h',
+		)
+	}
+
+	if features.get('vp9_highbitdepth', false)
+		dsp_optional_sources += {
+			'sse2' : dsp_optional_sources['sse2'] + files(
+				'x86/highbd_quantize_intrin_sse2.c',
+			),
+			'avx2' : dsp_optional_sources['avx'] + files(
+				'x86/highbd_quantize_intrin_avx2.c',
+			),
+			'neon' : dsp_optional_sources['neon'] + files(
+				'arm/highbd_quantize_neon.c',
+			),
+		}
+	endif
+
+	# avg
+	if features.get('x86_64', false)
+		dsp_asm_optional_sources += {
+			'ssse3' : dsp_asm_optional_sources['ssse3'] + files(
+				'x86/avg_ssse3_x86_64.asm',
+			)
+		}
+	endif
+endif
+
+if features.get('encoders', false) # MANUAL
+	dsp_sources += files(
+		'sad.c',
+		'subtract.c',
+		'sum_squares.c',
+	)
+
+	dsp_optional_sources += {
+		'neon' : dsp_optional_sources['neon'] + files(
+			'arm/sum_squares_neon.c',
+			'arm/sad4d_neon.c',
+			'arm/sad_neon.c',
+			'arm/subtract_neon.c',
+		),
+		'sse2' : dsp_optional_sources['sse2'] + files(
+			'x86/sum_squares_sse2.c',
+		),
+		'msa' : dsp_optional_sources['msa'] + files(
+			'mips/sum_squares_msa.c',
+			'mips/sad_msa.c',
+			'mips/subtract_msa.c',
+		),
+		'lsx' : dsp_optional_sources['lsx'] + files(
+			'loongarch/sad_lsx.c',
+			'loongarch/subtract_lsx.c',
+		),
+		'mmi' : dsp_optional_sources['mmi'] + files(
+			'mips/sad_mmi.c',
+			'mips/subtract_mmi.c',
+		),
+		'avx2' : dsp_optional_sources['avx2'] + files(
+			'x86/sad4d_avx2.c',
+			'x86/sad_avx2.c',
+			'x86/subtract_avx2.c',
+		),
+		'avx512' : dsp_optional_sources['avx512'] + files(
+			'x86/sad4d_avx512.c',
+		),
+		'vsx' : dsp_optional_sources['vsx'] + files(
+			'ppc/sad_vsx.c',
+			'ppc/subtract_vsx.c',
+		),
+	}
+
+	dsp_asm_optional_sources += {
+		'sse2' : dsp_asm_optional_sources['sse2'] + files(
+			'x86/sad4d_sse2.asm',
+			'x86/sad_sse2.asm',
+			'x86/subtract_sse2.asm',
+		)
+	}
+
+	if features.get('vp9_highbitdepth', false)
+		dsp_asm_optional_sources += {
+			'sse2' : dsp_asm_optional_sources['sse2'] + files(
+				'x86/highbd_sad4d_sse2.asm',
+				'x86/highbd_sad_sse2.asm',
+			)
+		}
+
+		dsp_optional_sources += {
+			'avx2' : dsp_optional_sources['avx2'] + files(
+				'x86/highbd_sad4d_avx2.c',
+				'x86/highbd_sad_avx2.c',
+			),
+			'neon' : dsp_optional_sources['neon'] + files(
+				'arm/highbd_sad_neon.c',
+			)
+		}
+	endif
+endif
+
+
+if not features.get('encoders', false) or not features.get('postproc', false) or not features.get('vp9_postproc', false) # MANUAL
+	dsp_sources += files(
+		'variance.c',
+	)
+
+	dsp_headers_sources += files(
+		'variance.h',
+	)
+
+	dsp_optional_sources += {
+		'neon' : dsp_optional_sources['neon'] + files(
+			'arm/avg_pred_neon.c',
+			'arm/subpel_variance_neon.c',
+			'arm/variance_neon.c',
+		),
+		'msa' : dsp_optional_sources['msa'] + files(
+			'mips/variance_msa.c',
+			'mips/sub_pixel_variance_msa.c',
+		),
+		'lsx' : dsp_optional_sources['lsx'] + files(
+			'loongarch/variance_lsx.c',
+			'loongarch/sub_pixel_variance_lsx.c',
+			'loongarch/avg_pred_lsx.c',
+		),
+		'mmi' : dsp_optional_sources['mmi'] + files(
+			'mips/variance_mmi.c',
+		),
+		'sse2' : dsp_optional_sources['sse2'] + files(
+			'x86/avg_pred_sse2.c',
+			'x86/variance_sse2.c', # Contains SSE2 and SSSE3
+		),
+		'avx2' : dsp_optional_sources['avx2'] + files(
+			'x86/variance_avx2.c',
+		),
+		'vsx' : dsp_optional_sources['vsx'] + files(
+			'ppc/variance_vsx.c',
+		),
+
+	}
+
+	dsp_headers_optional_sources += {
+		'lsx' : dsp_headers_optional_sources['lsx'] + files(
+			'loongarch/variance_lsx.h',
+		)
+	}
+
+	if features.get('x86_64', false)
+		dsp_asm_optional_sources += {
+			'sse2' : dsp_asm_optional_sources['sse2'] + files(
+				'x86/ssim_opt_x86_64.asm',
+			),
+		}
+	endif
+
+	# Contains SSE2 and SSSE3
+	dsp_asm_optional_sources += {
+		'sse2' : dsp_asm_optional_sources['sse2'] + files(
+			'x86/subpel_variance_sse2.asm',
+		)
+	}
+
+	if features.get('vp9_highbitdepth', false)
+		dsp_asm_optional_sources += {
+			'sse2' : dsp_asm_optional_sources['sse2'] + files(
+				'x86/highbd_variance_impl_sse2.asm',
+				'x86/highbd_subpel_variance_impl_sse2.asm',
+			)
+		}
+
+		dsp_optional_sources += {
+			'sse2' : dsp_optional_sources['sse2'] + files(
+				'x86/highbd_variance_sse2.c',
+			),
+			'neon' : dsp_optional_sources['neon'] + files(
+				'arm/highbd_variance_neon.c',
+			)
+		}
+	endif
+endif
+
+#### --- END GENERATED --- ####
+
+subdir('arm')
+
+codec_srcs += dsp_sources
+optional_sources = get_variable('dsp_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		codec_arch_srcs += {
+			comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+		}
+	else
+		codec_srcs += comp_sources
+	endif
+endforeach
+
+optional_sources = get_variable('dsp_asm_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		transformed_sources = comp_sources
+		if asm_conversion_exe.found()
+			transformed_sources = asm_transformer.process(comp_sources)
+		endif
+		codec_arch_srcs += {
+			comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+		}
+	else
+		codec_srcs += comp_sources
+	endif
+endforeach
+
+codec_headers += dsp_headers_sources
+optional_sources = get_variable('dsp_headers_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		codec_arch_srcs += {
+			comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+		}
+	else
+		codec_headers += comp_sources
+	endif
+endforeach
+
+vpx_dsp_rtcd_defs = files(
+	'vpx_dsp_rtcd_defs.pl',
+)
+
+codec_rtcds += {
+	'vpx_dsp_rtcd': vpx_dsp_rtcd_defs[0]
+}
+
+codec_headers += vpx_dsp_rtcd_defs
diff --git a/vpx_mem/meson.build b/vpx_mem/meson.build
new file mode 100644
index 000000000..be3013d8e
--- /dev/null
+++ b/vpx_mem/meson.build
@@ -0,0 +1,41 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+# vp8_common.mk
+
+#### --- GENERATED --- ####
+
+mem_sources = files(
+	'vpx_mem.c',
+)
+
+mem_optional_sources = {
+}
+
+mem_headers_sources = files(
+	'vpx_mem.h',
+	'include/vpx_mem_intrnl.h',
+)
+
+mem_headers_optional_sources = {
+}
+
+#### --- END GENERATED --- ####
+
+optional_sources = get_variable('mem_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if features.get(comp_name, false)
+		mem_sources += comp_sources
+	endif
+endforeach
+
+codec_srcs += mem_sources
+
+optional_sources = get_variable('mem_headers_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if features.get(comp_name, false)
+		mem_headers_sources += comp_sources
+	endif
+endforeach
+
+codec_headers += mem_headers_sources
diff --git a/vpx_ports/meson.build b/vpx_ports/meson.build
new file mode 100644
index 000000000..febfda80c
--- /dev/null
+++ b/vpx_ports/meson.build
@@ -0,0 +1,157 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+# vpx_ports.mk
+
+#### --- GENERATED --- ####
+
+ports_sources = files(
+)
+
+ports_optional_sources = {
+	'mmx' : files(
+		# 'emms_mmx.c' # MANUAL
+	),
+	'arm' : files(
+		'arm_cpudetect.c',
+	),
+	'ppc' : files(
+		'ppc_cpudetect.c',
+	),
+	'mips' : files(
+		'mips_cpudetect.c',
+	),
+	'loongarch' : files(
+		'loongarch_cpudetect.c',
+	),
+}
+
+ports_headers_sources = files(
+	'bitops.h',
+	'compiler_attributes.h',
+	'mem.h',
+	'msvc.h',
+	'static_assert.h',
+	'system_state.h',
+	'vpx_timer.h',
+	# 'x86.h', # MANUAL
+	# 'asmdefs_mmi.h', # MANUAL
+)
+
+ports_headers_optional_sources = {
+	'arm' : files(
+		'arm.h',
+	),
+	'ppc' : files(
+		'ppc.h',
+	),
+	'mips' : files(
+		'mips.h',
+	),
+	'loongarch' : files(
+		'loongarch.h',
+	),
+}
+
+ports_asm_sources = files(
+	# 'x86_abi_support.asm', # MANUAL
+)
+
+ports_asm_optional_sources = {
+	'mmx' : files(
+		# 'emms_mmx.asm' # MANUAL
+	),
+	'msvs' : files(
+		# 'float_control_word.asm' # MANUAL
+	),
+}
+
+ports_headers_sources += files( # MANUAL
+	'emmintrin_compat.h',
+	'mem_ops.h',
+	'mem_ops_aligned.h',
+	'vpx_once.h',
+)
+
+if features.get('x86', false) # MANUAL
+	ports_optional_sources += {
+		'mmx' : ports_optional_sources['mmx'] + files(
+			'emms_mmx.c'
+		),
+	}
+endif
+
+if features.get('x86_64', false) # MANUAL
+	# Visual Studio x64 does not support the _mm_empty() intrinsic.
+	ports_asm_optional_sources += {
+		'mmx' : ports_asm_optional_sources['mmx'] + files(
+			'emms_mmx.asm'
+		),
+	}
+
+	ports_asm_optional_sources += {
+		'msvs' : ports_asm_optional_sources['msvs'] +files(
+			'float_control_word.asm'
+		),
+	}
+endif
+
+# Do NOT compile these ASM files with MSVC! It will cause a linker deadlock
+# because the PDBs are empty:
+# https://developercommunity.visualstudio.com/t/MSVC-deadlockscrashes-when-linking-a-Me/10336032
+# The original configure script doesn't fail because they're ignored
+# in the ASM_INCLUDES variable.
+ports_headers_optional_sources += { # MANUAL
+	'x86': files(
+		'x86.h',
+		'x86_abi_support.asm',
+	),
+	'x86_64': files(
+		'x86.h',
+		'x86_abi_support.asm',
+	),
+	'mips': files(
+		'asmdefs_mmi.h'
+	)
+}
+
+#### --- END GENERATED --- ####
+
+codec_srcs += ports_sources
+optional_sources = get_variable('ports_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		codec_arch_srcs += {
+			comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+		}
+	else
+		codec_srcs += comp_sources
+	endif
+endforeach
+
+optional_sources = get_variable('ports_asm_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		transformed_sources = comp_sources
+		if asm_conversion_exe.found()
+			transformed_sources = asm_transformer.process(comp_sources)
+		endif
+		codec_arch_srcs += {
+			comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+		}
+	else
+		codec_srcs += comp_sources
+	endif
+endforeach
+
+codec_headers += ports_headers_sources
+optional_sources = get_variable('ports_headers_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if features.get(comp_name, false)
+		codec_headers += comp_sources
+	endif
+endforeach
diff --git a/vpx_scale/meson.build b/vpx_scale/meson.build
new file mode 100644
index 000000000..c35d8830e
--- /dev/null
+++ b/vpx_scale/meson.build
@@ -0,0 +1,71 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+# vp8_common.mk
+
+#### --- GENERATED --- ####
+
+scale_sources = files(
+	'generic/yv12config.c',
+	'generic/yv12extend.c',
+	'vpx_scale_rtcd.c',
+)
+
+scale_optional_sources = {
+	'dspr2' : files(
+		'mips/dspr2/yv12extend_dspr2.c'
+	),
+	'spatial_resampling' : files(
+		'generic/vpx_scale.c',
+		'generic/gen_scalers.c'
+	),
+}
+
+scale_headers_sources = files(
+	'yv12config.h',
+)
+
+scale_headers_optional_sources = {
+	'spatial_resampling' : files(
+		'vpx_scale.h'
+	),
+}
+
+#### --- END GENERATED --- ####
+
+codec_srcs += scale_sources
+optional_sources = get_variable('scale_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		codec_arch_srcs += {
+			comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+		}
+	else
+		codec_srcs += comp_sources
+	endif
+endforeach
+
+codec_headers += scale_headers_sources
+optional_sources = get_variable('scale_headers_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if not features.get(comp_name, false)
+		continue
+	elif ARCH_EXT_LIST.contains(comp_name)
+		codec_arch_headers += {
+			comp_name: codec_arch_headers.get(comp_name, []) + comp_sources
+		}
+	else
+		codec_headers += comp_sources
+	endif
+endforeach
+
+vpx_scale_rtcd_defs = files(
+	'vpx_scale_rtcd.pl',
+)
+
+codec_rtcds += {
+	'vpx_scale_rtcd': vpx_scale_rtcd_defs[0]
+}
+codec_headers += vpx_scale_rtcd_defs
diff --git a/vpx_util/meson.build b/vpx_util/meson.build
new file mode 100644
index 000000000..e39384421
--- /dev/null
+++ b/vpx_util/meson.build
@@ -0,0 +1,61 @@
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+# vpx_util.mk
+
+#### --- GENERATED --- ####
+
+util_sources = files(
+	'vpx_thread.c',
+	'vpx_write_yuv_frame.c',
+)
+
+util_optional_sources = {
+	'mismatch_debug' : files(
+		# 'vpx_debug_util.c' # MANUAL
+	),
+}
+
+util_headers_sources = files(
+	'vpx_atomics.h',
+	'vpx_thread.h',
+	'endian_inl.h',
+	'vpx_write_yuv_frame.h',
+	'vpx_timestamp.h',
+)
+
+util_headers_optional_sources = {
+	'mismatch_debug' : files(
+		# 'vpx_debug_util.h' # MANUAL
+	),
+}
+
+if features.get('bitstream_debug', false) or features.get('mismatch_debug', false)
+	util_sources += files(
+		'vpx_debug_util.c'
+	)
+
+	util_headers_sources += files(
+		'vpx_debug_util.h'
+	)
+endif
+
+#### --- END GENERATED --- ####
+
+optional_sources = get_variable('util_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if features.get(comp_name, false)
+		util_sources += comp_sources
+	endif
+endforeach
+
+codec_srcs += util_sources
+
+optional_sources = get_variable('util_headers_optional_sources', {})
+foreach comp_name, comp_sources : optional_sources
+	if features.get(comp_name, false)
+		util_headers_sources += comp_sources
+	endif
+endforeach
+
+codec_headers += util_headers_sources
-- 
2.44.0.windows.1


From 5d2c1a67d071bf14eab072219713a5e8942607b6 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@amyspark.me>
Date: Tue, 18 Apr 2023 22:59:00 -0300
Subject: [PATCH] Add GitLab CI


diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
new file mode 100644
index 000000000..251278731
--- /dev/null
+++ b/.gitlab-ci.yml
@@ -0,0 +1,335 @@
+# SPDX-FileNotice: This file is based on the FFmpeg Meson build version
+# SPDX-FileCopyrightText: 2019-2023 Tim-Philipp Müller <tim@centricular.com>
+# SPDX-FileCopyrightText: 2022 Nirbheek Chauhan <nirbheek@centricular.com>
+# SPDX-FileCopyrightText: 2022 Jordan Petridis <jordan@centricular.com>
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+include:
+  - project: 'freedesktop/ci-templates'
+    ref: 'master'
+    file: '/templates/debian.yml'
+
+default:
+  interruptible: true
+
+stages:
+  - 'image-build'
+  - 'build'
+
+.container.debian@common:
+  variables:
+    FDO_DISTRIBUTION_VERSION: "bookworm-slim"
+    FDO_UPSTREAM_REPO: "gstreamer/meson-ports/libvpx"
+    FDO_DISTRIBUTION_PACKAGES: >-
+      meson
+      python3-setuptools
+      ninja-build
+      build-essential
+      yasm
+      perl
+      git
+
+.container.debian@common.minimum:
+  extends: '.container.debian@common'
+  variables:
+    FDO_DISTRIBUTION_TAG: "2023-04-18.1-meson-v1.13.0-minimum"
+
+# The original (meson-ports/ffmpeg) relies on Debian's build-dep.
+# However, libvpx tarballs are ready-made and thus do not need perl
+# nor doxygen. Perl's installed by default, so we add Doxygen by hand.
+.container.debian@common.full:
+  extends: '.container.debian@common'
+  variables:
+    FDO_DISTRIBUTION_TAG: "2023-04-18.1-meson-v1.13.0-full"
+    FDO_DISTRIBUTION_EXEC: >-
+      echo "deb-src http://deb.debian.org/debian bookworm main" >> /etc/apt/sources.list &&
+      apt-get update &&
+      apt-get install -y doxygen graphviz
+
+debian-container-build@x86_64@minimum:
+  extends:
+    - '.fdo.container-build@debian@x86_64'
+    - '.container.debian@common.minimum'
+  stage: 'image-build'
+
+debian-container-build@x86_64@full:
+  extends:
+    - '.fdo.container-build@debian@x86_64'
+    - '.container.debian@common.full'
+  stage: 'image-build'
+
+.build:
+  stage: 'build'
+  script:
+    - meson setup mesonbuild ${MESON_OPTIONS}
+    - meson compile -C mesonbuild
+    - meson test -C mesonbuild
+    - meson install -C mesonbuild
+  artifacts:
+    paths:
+      - mesonbuild/meson-logs/
+
+.build nodeps:
+  extends:
+    - '.build'
+    - '.container.debian@common.minimum'
+    - '.fdo.distribution-image@debian'
+
+.build withdeps:
+  extends:
+    - '.build'
+    - '.container.debian@common.full'
+    - '.fdo.distribution-image@debian'
+
+.build withdepsandnasm:
+  extends: '.build withdeps'
+  before_script:
+    - apt-get remove --yes yasm
+    - apt-get update
+    - apt-get install --yes nasm
+
+# no external deps:
+#   extends: '.build nodeps'
+
+# with deps:
+#   extends: '.build withdeps'
+
+with deps nasm:
+  extends: '.build withdepsandnasm'
+
+.build@i386.common:
+  image: 'i386/debian:bookworm'
+  variables:
+    DEPENDENCIES: >-
+      meson
+      python3-setuptools
+      ninja-build
+      build-essential
+      yasm
+      perl
+      git
+
+# UNCOMMENT when the following is fixed:
+# https://github.com/mesonbuild/meson/issues/11726
+# no external@i386:
+#   extends:
+#     - '.build nodeps'
+#     - '.build@i386.common'
+#   before_script:
+#     - apt-get update
+#     - apt-get install --yes ${DEPENDENCIES}
+
+# with deps@i386:
+#   extends:
+#     - '.build withdeps'
+#     - '.build@i386.common'
+#   before_script:
+#     - echo "deb-src http://deb.debian.org/debian bookworm main" >> /etc/apt/sources.list
+#     - apt-get update
+#     - apt-get install --yes ${DEPENDENCIES}
+
+.build windows:
+  image: 'registry.freedesktop.org/gstreamer/gstreamer/amd64/windows:2022-09-23.0-main'
+  stage: 'build'
+  tags:
+    - 'docker'
+    - 'windows'
+    - '2022'
+  artifacts:
+    name: "${CI_JOB_NAME}_${CI_COMMIT_SHA}"
+    expire_in: '5 days'
+    when: 'always'
+    paths:
+      - "mesonbuild/meson-logs/*txt"
+  cache:
+    paths:
+      - subprojects/packagecache
+    key:
+      files:
+        - subprojects/nasm-win.wrap
+        - subprojects/perl-win.wrap
+      prefix: $CI_JOB_NAME
+  variables:
+    # Make sure any failure in PowerShell scripts is fatal
+    ErrorActionPreference: 'Stop'
+    WarningPreference: 'Stop'
+    # Uncomment the following key if need to pass custom args, as well with the
+    # $env:MESON_ARGS line in the `script:` blocks
+    # MESON_ARGS: >-
+    #   -Dfoo=enabled
+    #   -Dbar=disabled
+  before_script:
+    # Make sure meson is up to date, so we don't need to rebuild the image with each release
+    - pip3 install -U meson
+  script:
+    # HACK to sneak Nasm and Perl under Meson's nose.
+    - $env:PATH="$(pwd)\subprojects\nasm-2.16.01;$(pwd)\subprojects\strawberry-perl-5.32.1.1-32bit-portable\perl\bin;$env:PATH"
+    # For some reason, options are separated by newline instead of space, so we
+    # have to replace them first.
+    # - $env:MESON_ARGS = $env:MESON_ARGS.replace("`n"," ")
+    # Gitlab executes PowerShell in docker, but VsDevCmd.bat is a batch script.
+    # Environment variables substitutions is done by PowerShell before calling
+    # cmd.exe, that's why we use $env:FOO instead of %FOO%
+    - cmd.exe /C "C:\BuildTools\Common7\Tools\VsDevCmd.bat -host_arch=amd64 -arch=$env:ARCH &&
+        meson setup mesonbuild $env:MESON_ARGS &&
+        meson compile -C mesonbuild"
+
+vs2019:
+  extends: '.build windows'
+  variables:
+    ARCH: 'amd64'
+
+vs2019 no-optimization debug:
+  extends: '.build windows'
+  variables:
+    ARCH: 'amd64'
+    MESON_ARGS: '--optimization=0 --debug'
+
+vs2019 x86:
+  extends: '.build windows'
+  stage: 'build'
+  variables:
+    ARCH: 'x86'
+
+vs2019 arm64 cross:
+  extends: '.build windows'
+  stage: 'build'
+  variables:
+    ARCH: 'arm64'
+    MESON_ARGS: '--cross-file ci/vs-arm64-cross-file.txt'
+
+.build darwin:
+  stage: 'build'
+  artifacts:
+    name: "${CI_JOB_NAME}_${CI_COMMIT_SHA}"
+    expire_in: '5 days'
+    when: 'always'
+    paths:
+      - "mesonbuild/meson-logs/*txt"
+  cache:
+    paths:
+      - subprojects/packagecache
+    key:
+      files:
+        - subprojects/nasm-mac.wrap
+      prefix: $CI_JOB_NAME
+  before_script:
+    - pip3 install --upgrade pip
+    # Make sure meson is up to date
+    - pip3 install -U meson
+    # Need to install certificates for python
+    - pip3 install --upgrade certifi
+    # Another way to install certificates
+    - open /Applications/Python\ 3.8/Install\ Certificates.command
+    # Get ninja
+    - pip3 install -U ninja
+  script:
+    # HACK to sneak Nasm and Perl under Meson's nose.
+    - export PATH="$(pwd)/subprojects/nasm-2.16.01:$PATH"
+    - CERT_PATH=$(python3 -m certifi) && export SSL_CERT_FILE=${CERT_PATH} && export REQUESTS_CA_BUNDLE=${CERT_PATH} && meson setup mesonbuild
+    - meson compile -C mesonbuild
+    - meson test -C mesonbuild
+
+macOS x86_64:
+  extends: '.build darwin'
+  stage: 'build'
+  tags:
+    - gst-macos-12.3
+
+iOS arm64 cross:
+  extends: '.build darwin'
+  stage: 'build'
+  tags:
+    - gst-ios-15.4
+  script:
+    - |
+      cat > ios-cross-file.txt <<EOF
+      [host_machine]
+      system = 'darwin'
+      cpu_family = 'aarch64'
+      cpu = 'aarch64'
+      endian = 'little'
+
+      [properties]
+      c_args =      ['-arch', 'arm64', '--sysroot=$(xcrun --sdk iphoneos --show-sdk-path)', '-miphoneos-version-min=11.0']
+      c_link_args = ['-arch', 'arm64', '--sysroot=$(xcrun --sdk iphoneos --show-sdk-path)', '-miphoneos-version-min=11.0']
+      cpp_args =      ['-arch', 'arm64', '--sysroot=$(xcrun --sdk iphoneos --show-sdk-path)', '-miphoneos-version-min=11.0']
+      cpp_link_args = ['-arch', 'arm64', '--sysroot=$(xcrun --sdk iphoneos --show-sdk-path)', '-miphoneos-version-min=11.0']
+
+      [binaries]
+      ar        = '$(xcrun --find --sdk iphoneos ar)'
+      c         = '$(xcrun --find --sdk iphoneos clang)'
+      cpp       = '$(xcrun --find --sdk iphoneos clang++)'
+      ranlib    = '$(xcrun --find --sdk iphoneos ranlib)'
+      strip     = '$(xcrun --find --sdk iphoneos strip)'
+      pkgconfig = 'false'
+      EOF
+    - CERT_PATH=$(python3 -m certifi) && export SSL_CERT_FILE=${CERT_PATH} && export REQUESTS_CA_BUNDLE=${CERT_PATH} && meson setup mesonbuild --cross-file=ios-cross-file.txt
+    - meson compile -C mesonbuild
+    - meson test -C mesonbuild
+
+.build android:
+  image: 'registry.freedesktop.org/gstreamer/cerbero/android:2022-09-22.0'
+  stage: 'build'
+  artifacts:
+    name: "${CI_JOB_NAME}_${CI_COMMIT_SHA}"
+    expire_in: '5 days'
+    when: 'always'
+    paths:
+      - "mesonbuild/meson-logs/*txt"
+  variables:
+    ANDROID_SDK: '/android/sdk'
+    ANDROID_NDK: '/android/ndk'
+    ANDROID_API: '21'
+    TOOLCHAIN: "$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64"
+    NASM: "/usr/bin/nasm"
+  before_script:
+    - dnf install -y python3-pip binutils nasm gcc ninja-build perl-core
+    - pip3 install -U meson
+  script:
+    - |
+      cat > android-cross-file.txt <<EOF
+      [host_machine]
+      system = 'android'
+      cpu_family = '$ARCH'
+      cpu = '$ARCH'
+      endian = 'little'
+
+      [constants]
+      toolchain = '$TOOLCHAIN'
+      clang_arch = '$CLANG_ARCH'
+      arch = '$ARCH'
+      android_host = '$ANDROID_HOST'
+      android_api = '$ANDROID_API'
+
+      [properties]
+      sys_root = '$ANDROID_NDK/sysroot'
+
+      [binaries]
+      ar        = toolchain + '/bin/' + arch + '-linux-' + android_host + '-ar'
+      c         = toolchain + '/bin/' + clang_arch + '-linux-' + android_host + android_api + '-clang'
+      cpp       = toolchain + '/bin/' + clang_arch + '-linux-' + android_host + android_api + '-clang++'
+      ranlib    = toolchain + '/bin/' + arch + '-linux-' + android_host + '-ranlib'
+      strip     = toolchain + '/bin/' + arch + '-linux-' + android_host + '-strip'
+      nasm      = '$NASM'
+      pkgconfig = 'false'
+      EOF
+    - meson setup mesonbuild --cross-file android-cross-file.txt
+    - meson compile -C mesonbuild
+
+android arm64 cross:
+  extends: '.build android'
+  stage: 'build'
+  variables:
+    ARCH: 'aarch64'
+    CLANG_ARCH: 'aarch64'
+    ANDROID_HOST: 'android'
+
+android armv7 cross:
+  extends: '.build android'
+  stage: 'build'
+  variables:
+    ARCH: 'arm'
+    CLANG_ARCH: 'armv7a'
+    ANDROID_HOST: 'androideabi'
diff --git a/ci/vs-arm64-cross-file.txt b/ci/vs-arm64-cross-file.txt
new file mode 100644
index 000000000..acfc9b5ad
--- /dev/null
+++ b/ci/vs-arm64-cross-file.txt
@@ -0,0 +1,14 @@
+[host_machine]
+system = 'windows'
+cpu_family = 'aarch64'
+cpu = 'aarch64'
+endian = 'little'
+
+[properties]
+needs_exe_wrapper = true
+
+[binaries]
+ar        = 'lib'
+c         = 'cl'
+cpp       = 'cl'
+pkgconfig = 'false'
-- 
2.44.0.windows.1


From 9d995f84e5baafe7070af3439fb172ab2751327b Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@amyspark.me>
Date: Wed, 17 May 2023 20:08:48 -0300
Subject: [PATCH] meson: Protect build system handled features with combo
 choices


diff --git a/meson.build b/meson.build
index 78578a1f5..a2eeacf17 100644
--- a/meson.build
+++ b/meson.build
@@ -309,18 +309,11 @@ MESON_OPTIONS = [
 	'install_docs',
 	'install_bins',
 	'install_libs',
-	'libs',
-	'examples',
-	'tools',
-	'docs',
-	'unit_tests',
 	'decode_perf_tests',
 	'encode_perf_tests',
 	'codec_srcs',
 	'vp9_highbitdepth',
 	'better_hw_compatibility',
-	'vp8',
-	'vp9',
 	'internal_stats',
 	'postproc',
 	'vp9_postproc',
@@ -337,6 +330,16 @@ MESON_OPTIONS = [
 	'vp9_temporal_denoising',
 	'webm_io',
 	'libyuv',
+]
+
+MESON_FEATURES = [
+	'libs',
+	'examples',
+	'tools',
+	'docs',
+	'unit_tests',
+	'vp8',
+	'vp9',
 	'vp8_encoder',
 	'vp8_decoder',
 	'vp9_encoder',
@@ -348,16 +351,6 @@ VAR_LIST = []
 
 # process #
 
-if not get_option('auto_features').auto()
-	error('''
-		libvpx relies on feature options to enable components conditionally.
-		If you need to disable features manually, please use:
-		- the individual toggles,
-		- the enable_features and disable_features string options, for conditional setting
-		- the force_enable_features and force_enable_features string options, for forcing a value irrespective of the architecture configuration.
-	''')
-endif
-
 ## process_cmdline ##
 
 features.set('extra_warnings', not ['0', '1'].contains(get_option('warning_level')))
@@ -372,11 +365,16 @@ tune_cpu = ''
 foreach flag: CMDLINE_SELECT
 	if IGNORE_MESON_BUILTINS.contains(flag)
 		continue
-	elif MESON_OPTIONS.contains(flag)
+	elif MESON_FEATURES.contains(flag)
 		value = get_option(flag)
 		if not value.auto()
 			features.set(flag, value.enabled())
 		endif
+	elif MESON_OPTIONS.contains(flag)
+		value = get_option(flag)
+		if value != 'auto'
+			features.set(flag, value == 'enabled')
+		endif
 	elif flag == 'size_limit'
 		size_limit_value = get_option('size_limit')
 		if size_limit_value == ''
diff --git a/meson/parse_options.py b/meson/parse_options.py
index 825b5eeac..a729313da 100644
--- a/meson/parse_options.py
+++ b/meson/parse_options.py
@@ -94,6 +94,20 @@ MESON_HANDLED_OPTIONS = [
 	'install_srcs',
 ]
 
+FEATURES = [
+	'vp8',
+	'vp9',
+	'vp8_encoder',
+	'vp8_decoder',
+	'vp9_encoder',
+	'vp9_decoder',
+	'libs',
+	'examples',
+	'tools',
+	'docs',
+	'unit_tests',
+]
+
 def filter_meson_handled_options(pair) -> bool:
 	k, _v = pair
 	return k not in MESON_HANDLED_OPTIONS
@@ -117,7 +131,10 @@ def update_meson_options(options: dict):
 							value = f"value: '{kv['value']}', "
 						else:
 							value = ''
-						lines.append(f"option('{key}', type: 'feature', {value}description: '{kv['description']}')\n")
+						if key in FEATURES:
+							lines.append(f"option('{key}', type: 'feature', {value}description: '{kv['description']}')\n")
+						else:
+							lines.append(f"option('{key}', type: 'combo', choices: ['auto', 'enabled', 'disabled'], {value}description: '{kv['description']}')\n")
 					else:
 						if kv.get('value') and len(kv['value']) != 0:
 							value = f"value: '{kv['value']}', "
@@ -136,7 +153,8 @@ def update_meson_options(options: dict):
 def update_meson_build(options: dict):
 	has_generated = False
 	lines = []
-	booleans = [i for i in options.keys() if options.get(i)['type'] == 'boolean']
+	features = [i for i in options.keys() if options.get(i)['type'] == 'boolean' and i in FEATURES]
+	booleans = [i for i in options.keys() if options.get(i)['type'] == 'boolean' and i not in FEATURES]
 	with open('meson.build', 'r', encoding='utf-8') as meson_file:
 		opening = '#### --- GENERATED EXTERN OPTIONS --- ####\n'
 		closing = opening.replace('GENERATED', 'END GENERATED')
@@ -151,7 +169,12 @@ def update_meson_build(options: dict):
 				lines.append('\n')
 				lines.append('MESON_OPTIONS = [\n')
 				for i in booleans:
-					lines.append(f"\t'{i}',\n")
+					lines.append(f"\t'{i}',\n") 
+				lines.append(']\n')
+				lines.append('\n')
+				lines.append('MESON_FEATURES = [\n')
+				for i in features:
+					lines.append(f"\t'{i}',\n") 
 				lines.append(']\n')
 			elif l == closing:
 				lines.append(l)
diff --git a/meson_options.txt b/meson_options.txt
index 7dc06dea5..c94df9ccf 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -7,41 +7,41 @@ option('force_enable_features', type: 'array', description: 'Forcibly set these
 option('force_disable_features', type: 'array', description: 'Forcibly set these (possibly undocumented) configuration entries as disabled')
 #### --- GENERATED EXTERN OPTIONS --- ####
 option('cpu', type: 'string', description: 'tune for the specified CPU (ARM: cortex-a8, X86: sse3)')
-option('gprof', type: 'feature', description: 'enable/disable gprof profiling instrumentation')
-option('thumb', type: 'feature', description: 'enable/disable building arm assembly in thumb mode')
-option('install_docs', type: 'feature', description: 'control whether docs are installed')
-option('install_bins', type: 'feature', value: 'enabled', description: 'control whether binaries are installed')
-option('install_libs', type: 'feature', value: 'enabled', description: 'control whether libraries are installed')
+option('gprof', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'enable/disable gprof profiling instrumentation')
+option('thumb', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'enable/disable building arm assembly in thumb mode')
+option('install_docs', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'control whether docs are installed')
+option('install_bins', type: 'combo', choices: ['auto', 'enabled', 'disabled'], value: 'enabled', description: 'control whether binaries are installed')
+option('install_libs', type: 'combo', choices: ['auto', 'enabled', 'disabled'], value: 'enabled', description: 'control whether libraries are installed')
 option('libs', type: 'feature', value: 'enabled', description: 'libraries')
 option('examples', type: 'feature', value: 'enabled', description: 'examples')
 option('tools', type: 'feature', value: 'enabled', description: 'tools')
 option('docs', type: 'feature', value: 'enabled', description: 'documentation')
 #### MANUAL
 option('unit_tests', type: 'feature', value: 'disabled', description: 'unit tests')
-option('decode_perf_tests', type: 'feature', description: 'build decoder perf tests with unit tests')
-option('encode_perf_tests', type: 'feature', description: 'build encoder perf tests with unit tests')
+option('decode_perf_tests', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'build decoder perf tests with unit tests')
+option('encode_perf_tests', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'build encoder perf tests with unit tests')
 option('size_limit', type: 'string', description: 'max size to allow in the decoder')
-option('codec_srcs', type: 'feature', description: 'in/exclude codec library source code')
-option('vp9_highbitdepth', type: 'feature', description: 'use VP9 high bit depth (10/12) profiles')
-option('better_hw_compatibility', type: 'feature', description: 'enable encoder to produce streams with better hardware decoder compatibility')
+option('codec_srcs', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'in/exclude codec library source code')
+option('vp9_highbitdepth', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'use VP9 high bit depth (10/12) profiles')
+option('better_hw_compatibility', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'enable encoder to produce streams with better hardware decoder compatibility')
 option('vp8', type: 'feature', description: 'Enable the VP8 codec')
 option('vp9', type: 'feature', description: 'Enable the VP9 codec')
-option('internal_stats', type: 'feature', description: 'output of encoder internal stats for debug, if supported (encoders)')
-option('postproc', type: 'feature', description: 'postprocessing')
-option('vp9_postproc', type: 'feature', description: 'vp9 specific postprocessing')
-option('multithread', type: 'feature', value: 'enabled', description: 'multithreaded encoding and decoding')
-option('spatial_resampling', type: 'feature', value: 'enabled', description: 'spatial sampling (scaling) support')
-option('realtime_only', type: 'feature', description: 'enable this option while building for real-time encoding')
-option('onthefly_bitpacking', type: 'feature', description: 'enable on-the-fly bitpacking in real-time encoding')
-option('error_concealment', type: 'feature', description: 'enable this option to get a decoder which is able to conceal losses')
-option('coefficient_range_checking', type: 'feature', description: 'enable decoder to check if intermediate transform coefficients are in valid range')
-option('runtime_cpu_detect', type: 'feature', description: 'runtime cpu detection')
-option('postproc_visualizer', type: 'feature', description: 'macro block / block level visualizers')
-option('multi_res_encoding', type: 'feature', description: 'enable multiple-resolution encoding')
-option('temporal_denoising', type: 'feature', value: 'enabled', description: 'enable temporal denoising and disable the spatial denoiser')
-option('vp9_temporal_denoising', type: 'feature', description: 'enable vp9 temporal denoising')
-option('webm_io', type: 'feature', description: 'enable input from and output to WebM container')
-option('libyuv', type: 'feature', description: 'enable libyuv')
+option('internal_stats', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'output of encoder internal stats for debug, if supported (encoders)')
+option('postproc', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'postprocessing')
+option('vp9_postproc', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'vp9 specific postprocessing')
+option('multithread', type: 'combo', choices: ['auto', 'enabled', 'disabled'], value: 'enabled', description: 'multithreaded encoding and decoding')
+option('spatial_resampling', type: 'combo', choices: ['auto', 'enabled', 'disabled'], value: 'enabled', description: 'spatial sampling (scaling) support')
+option('realtime_only', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'enable this option while building for real-time encoding')
+option('onthefly_bitpacking', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'enable on-the-fly bitpacking in real-time encoding')
+option('error_concealment', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'enable this option to get a decoder which is able to conceal losses')
+option('coefficient_range_checking', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'enable decoder to check if intermediate transform coefficients are in valid range')
+option('runtime_cpu_detect', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'runtime cpu detection')
+option('postproc_visualizer', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'macro block / block level visualizers')
+option('multi_res_encoding', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'enable multiple-resolution encoding')
+option('temporal_denoising', type: 'combo', choices: ['auto', 'enabled', 'disabled'], value: 'enabled', description: 'enable temporal denoising and disable the spatial denoiser')
+option('vp9_temporal_denoising', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'enable vp9 temporal denoising')
+option('webm_io', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'enable input from and output to WebM container')
+option('libyuv', type: 'combo', choices: ['auto', 'enabled', 'disabled'], description: 'enable libyuv')
 option('vp8_encoder', type: 'feature', description: 'Enable the VP8 encoder only')
 option('vp8_decoder', type: 'feature', description: 'Enable the VP8 decoder only')
 option('vp9_encoder', type: 'feature', description: 'Enable the VP9 encoder only')
-- 
2.44.0.windows.1


From d6ed8fb620902f415871cd40f76b5788d40a9f82 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Tue, 4 Jul 2023 22:05:03 -0300
Subject: [PATCH] meson: Fix dependency override's library name

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/4>

diff --git a/meson.build b/meson.build
index a2eeacf17..29a14dc86 100644
--- a/meson.build
+++ b/meson.build
@@ -1761,7 +1761,7 @@ libvpx_dep = declare_dependency(
 	include_directories: include_directories('.'),
 )
 
-meson.override_dependency('libvpx', libvpx_dep)
+meson.override_dependency('vpx', libvpx_dep)
 
 pkg = import('pkgconfig')
 
-- 
2.44.0.windows.1


From 53674ba858612470cb63e23a88b0cbfa0ba44523 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Wed, 5 Jul 2023 14:16:50 -0300
Subject: [PATCH] meson: Port thumb to Python

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/5>

diff --git a/build/make/thumb.py b/build/make/thumb.py
new file mode 100755
index 000000000..7b2c0c329
--- /dev/null
+++ b/build/make/thumb.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+# SPDX-FileCopyrightText: 2013 The WebM Authors
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@centricular.com>
+# SPDX-License-Identifier: BSD-3-Clause
+
+import re
+
+def FixThumbInstructions(l: str) -> str:
+    # Write additions with shifts, such as "add r10, r11, lsl #8",
+    # in three operand form, "add r10, r10, r11, lsl #8".
+    l = re.sub(r'(add\s+)(r\d+),\s*(r\d+),\s*(lsl #\d+)', r'\1\2, \2, \3, \4', l)
+
+    # Convert additions with a non-constant shift into a sequence
+    # with left shift, addition and a right shift (to restore the
+    # register to the original value). Currently the right shift
+    # isn't necessary in the code base since the values in these
+    # registers aren't used, but doing the shift for consistency.
+    # This converts instructions such as "add r12, r12, r5, lsl r4"
+    # into the sequence "lsl r5, r4", "add r12, r12, r5", "lsr r5, r4".
+    l = re.sub(r'^(\s*)(add)(\s+)(r\d+),\s*(r\d+),\s*(r\d+),\s*lsl (r\d+)', r'\1lsl\3\6, \7\n\1\2\3\4, \5, \6\n\1lsr\3\6, \7', l)
+
+    # Convert loads with right shifts in the indexing into a
+    # sequence of an add, load and sub. This converts
+    # "ldrb r4, [r9, lr, asr #1]" into "add r9, r9, lr, asr #1",
+    # "ldrb r9, [r9]", "sub r9, r9, lr, asr #1".
+    l = re.sub(r'^(\s*)(ldrb)(\s+)(r\d+),\s*\[(\w+),\s*(\w+),\s*(asr #\d+)\]', r'\1add \3\5, \5, \6, \7\n\1\2\3\4, [\5]\n\1sub \3\5, \5, \6, \7', l)
+
+    # Convert register indexing with writeback into a separate add
+    # instruction. This converts "ldrb r12, [r1, r2]!" into
+    # "ldrb r12, [r1, r2]", "add r1, r1, r2".
+    l = re.sub(r'^(\s*)(ldrb)(\s+)(r\d+),\s*\[(\w+),\s*(\w+)\]!', r'\1\2\3\4, [\5, \6]\n\1add \3\5, \6', l)
+
+    # Convert negative register indexing into separate sub/add instructions.
+    # This converts "ldrne r4, [src, -pstep, lsl #1]" into
+    # "subne src, src, pstep, lsl #1", "ldrne r4, [src]",
+    # "addne src, src, pstep, lsl #1". In a couple of cases where
+    # this is used, it's used for two subsequent load instructions,
+    # where a hand-written version of it could merge two subsequent
+    # add and sub instructions.
+    l = re.sub(r'^(\s*)((ldr|str|pld)(ne)?)(\s+)(r\d+,\s*)?\[(\w+), -([^\]]+)\]', r'\1sub\4\5\7, \7, \8\n\1\2\5\6\[\7\]\n\1add\4\5\7, \7, \8', l)
+
+    # Convert register post indexing to a separate add instruction.
+    # This converts "ldrneb r9, [r0], r2" into "ldrneb r9, [r0]",
+    # "addne r0, r0, r2".
+    l = re.sub(r'^(\s*)((ldr|str)(ne)?[bhd]?)(\s+)(\w+),(\s*\w+,)?\s*\[(\w+)\],\s*(\w+)', r'\1\2\5\6,\7 [\8]\n\1add\4\5\8, \8, \9', l)
+
+    # Convert "mov pc, lr" into "bx lr", since the former only works
+    # for switching from arm to thumb (and only in armv7), but not
+    # from thumb to arm.
+    l = re.sub(r'mov(\s*)pc\s*,\s*lr', r'bx\1lr', l)
+
+    return l
-- 
2.44.0.windows.1


From f0590267f41f70a780e5bf584d4f389e26ddbfa8 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Wed, 5 Jul 2023 14:15:44 -0300
Subject: [PATCH] meson: Port ads2armasm_ms to Python

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/5>

diff --git a/build/make/ads2armasm_ms.py b/build/make/ads2armasm_ms.py
new file mode 100755
index 000000000..b4b54e229
--- /dev/null
+++ b/build/make/ads2armasm_ms.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+# SPDX-FileCopyrightText: 2013 The WebM Authors
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@centricular.com>
+# SPDX-License-Identifier: BSD-3-Clause
+
+import re
+import sys
+import thumb
+
+if __name__ == '__main__':
+    print('; This file was created from a .asm file')
+    print('; using the ads2armasm_ms.py script.')
+
+    f = sys.stdin.readlines()
+    for line in f:
+        # Python edit to make sure we don't duplicate newlines
+        l = line.rstrip()
+
+        l = l.replace(r'REQUIRE8', 'r') \
+            .replace(r'PRESERVE8', r'')
+        l = re.sub(r'^\s*ARM\s*$', r'', l)
+
+        l = re.sub(r'AREA\s+\|\|(.*)\|\|', r'AREA |\1|', l)
+        l = l.replace(r'qsubaddx', r'qsax')
+        l = l.replace(r'qaddsubx', r'qasx')
+
+        l = thumb.FixThumbInstructions(l)
+
+        l = l.replace(r'ldrneb', r'ldrbne') \
+            .replace(r'ldrneh', r'ldrhne')
+        l = re.sub(r'^(\s*)ENDP.*', r'\g<0>\n\1ALIGN 4', l)
+
+        print(l)
diff --git a/meson.build b/meson.build
index 29a14dc86..18c05df82 100644
--- a/meson.build
+++ b/meson.build
@@ -697,7 +697,7 @@ if tgt_isa.startswith('arm')
 		# and so can be selected as 'win32'.
 
 		if tgt_isa == 'armv7'
-			asm_conversion_exe = find_program('build/make/ads2armasm_ms.pl', required: true)
+			asm_conversion_exe = find_program('build/make/ads2armasm_ms.py', required: true)
 			asm_conversion_cmd = []
 			as_sfx = '.masm'
 			features.set('multithread', false)
-- 
2.44.0.windows.1


From 9036099d143d9ee6867b7ea720b6b77aa186beba Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Wed, 5 Jul 2023 14:15:55 -0300
Subject: [PATCH] meson: Port ads2gas_apple to Python

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/5>

diff --git a/build/make/ads2gas_apple.py b/build/make/ads2gas_apple.py
new file mode 100755
index 000000000..9c25a747b
--- /dev/null
+++ b/build/make/ads2gas_apple.py
@@ -0,0 +1,98 @@
+#!/usr/bin/env python3
+# SPDX-FileCopyrightText: 2013 The WebM Authors
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@centricular.com>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from argparse import ArgumentParser
+import re
+import sys
+
+if __name__ == '__main__':
+    parser = ArgumentParser(description='Convert ARM Developer Suite 1.0.1 syntax assembly source to GNU as format')
+
+    parser.parse_args()
+
+    print('@ This file was created from a .asm file')
+    print('@  using the ads2gas_apple.py script.\n')
+    print('.syntax unified')
+
+    f = iter(sys.stdin.readlines())
+    for line in f:
+        # Python edit to make sure we don't duplicate newlines
+        l = line.rstrip()
+
+        # Load and store alignment
+        l = re.sub(r'@', r',:', l)
+
+        # Comment character
+        l = re.sub(r';', r'@', l)
+
+        # Convert ELSE to .else
+        l = re.sub(r'\bELSE\b', r'.else', l)
+
+        # Convert ENDIF to .endif
+        l = re.sub(r'\bENDIF\b', r'.else', l)
+
+        # Convert IF to .if
+        if re.search(r'\bIF\b', l):
+            l = re.sub(r'\bIF\b', r'.if', l)
+            l = l.replace('=+', '==')
+
+        # Convert INCLUDE to .INCLUDE "file"
+        l = re.sub(r'INCLUDE\s?(.*)$', r'.include "\1"', l)
+
+        # No AREA required
+        # But ALIGNs in AREA must be obeyed
+        l = re.sub(r'^(\s*)\bAREA\b.*ALIGN=([0-9])$', r'\1.text\n\1.p2align \2', l)
+        # If no ALIGN, strip the AREA and align to 4 bytes
+        l = re.sub(r'^(\s*)\bAREA\b.*$', r'\1.text\n\1.p2align 2', l)
+
+        # Make function visible to linker.
+        l = re.sub(r'EXPORT\s+\|([\$\w]*)\|', r'.globl _\1', l)
+
+        # No vertical bars on function names
+        l = re.sub(r'^\|(\$?\w+)\|', r'\1', l)
+
+        # Labels and functions need a leading underscore and trailing colon
+        if not re.search(r'EQU', l):
+            print(l)
+            l = re.sub(r'^([a-zA-Z_0-9\$]+)', r'_\1:', l)
+
+        # Branches need to call the correct, underscored, function
+        if not re.search('EQU', l):
+            l = re.sub(r'^(\s+b[egln]?[teq]?\s+)([a-zA-Z_0-9\$]+)', r'\1 _\2', l)
+
+        # ALIGN directive
+        l = re.sub(r'\bALIGN\b', r'.balign', l)
+
+        # Strip ARM
+        l = re.sub(r'\s+ARM', '', l)
+
+        # Strip REQUIRE8
+        l = re.sub(r'\s+REQUIRE8', r'', l)
+
+        # Strip PRESERVE8
+        l = re.sub(r'\s+PRESERVE8', r'', l)
+
+        # Strip PROC and ENDPROC
+        l = re.sub(r'\bPROC\b', r'', l)
+        l = re.sub(r'\bENDP\b', r'', l)
+
+        # EQU directive
+        l = re.sub(r'(\S+\s+)EQU(\s+\S+)', r'.equ \1, \2', l)
+
+        # Begin macro definition
+        if re.search(r'\bMACRO\b', l):
+            # Process next line down, which will be the macro definition
+            l = next(f)
+            l = l.replace(r'^', r'.macro')
+            l = l.replace(r'$', r'')             # Remove $ from the variables in the declaration
+
+        l = l.replace(r'$', r'\\')               # Use \ to reference formal parameters
+        # End macro definition
+
+        l = re.sub(r'\bMEND\b', r'.endm', l)       # No need to tell it where to stop assembling
+        if re.search(r'^\s*END\s*$', l):
+            continue
+        l = re.sub(r'[ \t]+$', '', l)
+        print(l)
diff --git a/meson.build b/meson.build
index 18c05df82..375740507 100644
--- a/meson.build
+++ b/meson.build
@@ -770,7 +770,7 @@ if tgt_isa.startswith('arm')
 		endif
 
 		# Darwin toolchain and embed-bitcode options are Meson handled.
-		asm_conversion_exe = find_program('build/make/ads2gas_apple.pl', required: true)
+		asm_conversion_exe = find_program('build/make/ads2gas_apple.py', required: true)
 		asm_conversion_cmd = []
 	elif tgt_os == 'linux'
 		features.set('linux', true)
-- 
2.44.0.windows.1


From 08600713dff2b4e9651e2e12c0b97bd28c04e931 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Wed, 5 Jul 2023 14:16:44 -0300
Subject: [PATCH] meson: Port ads2gas to Python

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/5>

diff --git a/build/make/ads2gas.py b/build/make/ads2gas.py
new file mode 100755
index 000000000..c8025a971
--- /dev/null
+++ b/build/make/ads2gas.py
@@ -0,0 +1,140 @@
+#!/usr/bin/env python3
+# SPDX-FileCopyrightText: 2010 The WebM Authors
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@centricular.com>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from argparse import ArgumentParser
+import re
+import sys
+import thumb
+
+if __name__ == '__main__':
+    parser = ArgumentParser(description='Convert ARM Developer Suite 1.0.1 syntax assembly source to GNU as format')
+    parser.add_argument('-thumb', action='store_true')
+    parser.add_argument('-noelf', dest='elf', action='store_false')
+
+    args = parser.parse_args()
+
+    print('@ This file was created from a .asm file')
+    print('@  using the ads2gas.pl script.')
+    print('.syntax unified')
+
+    if args.thumb:
+        print('\t.thumb')
+
+    # Stack of procedure names.
+    proc_stack: list[str] = []
+
+    f = iter(sys.stdin.readlines())
+    for line in f:
+        # Python edit to make sure we don't duplicate newlines
+        l = line.rstrip()
+
+        # Load and store alignment
+        l = re.sub(r'@', ',:', l)
+
+        # Comment character
+        l = re.sub(r';', r'@', l)
+
+        # Convert ELSE to .else
+        l = re.sub(r'\bELSE\b', r'.else', l)
+
+        # Convert ENDIF to .endif
+        l = re.sub(r'\bENDIF\b', r'.endif', l)
+
+        # Convert IF to .if
+        if re.search(r'\bIF\b', l):
+            l = re.sub(r'\bIF\b', r'.if', l)
+            l = l.replace('=+', '==')
+
+        # Convert INCLUDE to .INCLUDE "file"
+        l = re.sub(r'INCLUDE\s?(.*)$', r'.include "\1"', l)
+
+        # No AREA required
+        # But ALIGNs in AREA must be obeyed
+        l = re.sub(r'^(\s*)\bAREA\b.*ALIGN=([0-9])$', r'\1.text\n\1.p2align \2', l)
+        # If no ALIGN, strip the AREA and align to 4 bytes
+        l = re.sub(r'^(\s*)\bAREA\b.*$', r'\1.text\n\1.p2align 2', l)
+
+        # Make function visible to linker.
+        if args.elf:
+            l = re.sub(r'(\s*)EXPORT\s+\|([\$\w]*)\|', r'\1.global \2\n\1.type \2, function', l)
+        else:
+            l = re.sub(r'(\s*)EXPORT\s+\|([\$\w]*)\|', r'\1.global \2', l)
+
+        # No vertical bars on function names
+        l = re.sub(r'^\|(\$?\w+)\|', r'\1', l)
+
+        # Labels need trailing colon
+        if not re.search('EQU', l):
+            l = re.sub(r'^([a-zA-Z_0-9\$]+)', r'\1:', l)
+
+        # ALIGN directive
+        l = re.sub(r'\bALIGN\b', r'.balign', l)
+
+        if args.thumb:
+            # ARM code - we force everything to thumb with the declaration in the
+            # header
+            l = re.sub(r'\bARM\b', r'', l)
+        else:
+            # ARM code
+            l = re.sub(r'\bARM\b', r'.arm', l)
+
+        # push/pop
+        l = re.sub(r'(push\s+)(r\d+)', r'stmdb sp!, {\2}', l)
+        l = re.sub(r'(pop\s+)(r\d+)', r'ldmia sp!, {\2}', l)
+
+        if args.thumb:
+            l = thumb.FixThumbInstructions(l)
+
+        # eabi_attributes numerical equivalents can be found in the
+        # "ARM IHI 0045C" document.
+
+        if args.elf:
+            # REQUIRE8 Stack is required to be 8-byte aligned
+            l = re.sub(r'\bREQUIRE8\b', r'.eabi_attribute 24, 1 @Tag_ABI_align_needed', l)
+
+            # PRESERVE8 Stack 8-byte align is preserved
+            l = re.sub(r'\bPRESERVE8\b', r'.eabi_attribute 25, 1 @Tag_ABI_align_preserved', l)
+        else:
+            l = re.sub(r'\bREQUIRE8\b', r'', l)
+            l = re.sub(r'\bPRESERVE8\b', r'', l)
+
+        # Use PROC and ENDP to give the symbols a .size directive.
+        # This makes them show up properly in debugging tools like gdb and valgrind.
+        if re.search(r'\bPROC\b', l):
+            # Match the function name so it can be stored in $proc
+            proc = re.search(r'^([\.0-9A-Z_a-z]\w+)\b', l)
+            if proc:
+                proc_stack.append(proc.group(1))
+            l = re.sub(r'\bPROC\b', r'@ \g<0>', l)
+
+        if re.search(r'\bENDP\b', l):
+            l = re.sub(r'\bENDP\b', r'@ \g<0>', l)
+            proc = None if len(proc_stack) == 0 else proc_stack.pop()
+            if proc and args.elf:
+                l = f'.size {proc}, .-{proc}{l}'
+
+        # EQU directive
+        l = re.sub(r'(\S+\s+)EQU(\s+\S+)', r'.equ \1, \2', l)
+
+        # Begin macro definition
+        if re.search(r'\bMACRO\b', l):
+            # Process next line down, which will be the macro definition
+            l = next(f)
+            l = re.sub(r'^', r'.macro', l)
+            l = l.replace(r'$', r'')             # Remove $ from the variables in the declaration
+
+        l = l.replace(r'$', '\\')               # Use \ to reference formal parameters
+        # End macro definition
+
+        l = re.sub(r'\bMEND\b', r'.endm', l)       # No need to tell it where to stop assembling
+        if re.search(r'^\s*END\s*$', l):
+            continue
+
+        l = re.sub(r'[ \t]+$', '', l)
+        print(l)
+
+    # Mark that this object doesn't need an executable stack.
+    if args.elf:
+        print(r'    .section .note.GNU-stack,"",%progbits')
diff --git a/meson.build b/meson.build
index 375740507..4ab8451b8 100644
--- a/meson.build
+++ b/meson.build
@@ -676,7 +676,7 @@ if tgt_isa.startswith('arm')
 			endif
 		endif
 
-		asm_conversion_exe = find_program('build/make/ads2gas.pl', required: true)
+		asm_conversion_exe = find_program('build/make/ads2gas.py', required: true)
 		asm_conversion_cmd = []
 		as_sfx = '.S'
 
-- 
2.44.0.windows.1


From 631ed2cbd07ae7af6288d5875960ed5b0c86931a Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Fri, 7 Jul 2023 22:10:48 -0300
Subject: [PATCH] meson: Port rtcd.pl to Python

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/5>

diff --git a/build/make/rtcd.py b/build/make/rtcd.py
new file mode 100755
index 000000000..3d4121c57
--- /dev/null
+++ b/build/make/rtcd.py
@@ -0,0 +1,436 @@
+#!/usr/bin/env python3
+# SPDX-FileCopyrightText: 2017 The WebM Authors
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@centricular.com>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from argparse import ArgumentParser
+import re
+from pathlib import Path
+from typing import Any, Dict, List
+
+ALL_FUNCS: Dict[str, List[str]] = {}
+ALL_ARCHS: List[str] = []
+ALL_FORWARD_DECLS: List[str] = []
+REQUIRES: List[str] = []
+
+opts: Dict[str, Any] = {}
+disabled: List[str] = []
+required: List[str] = []
+
+config: Dict[str, str] = {}
+
+def qw(s: str) -> List[str]:
+    return s.split()
+
+#
+# Routines for the RTCD DSL to call
+#
+def vpx_config(s: str) -> str:
+    return config[s] if s in config else ''
+
+def specialize(*args: str):
+    fn = args[0]
+    for opt in args[1:]:
+        exec(f"{fn}_{opt}='{fn}_{opt}'", globals())
+
+def add_proto(*args: str):
+    _args = list(args)
+    fn = _args.pop(-2)
+    ALL_FUNCS[fn] = _args
+    specialize(fn, "c")
+
+def require(*args: str):
+    for fn in ALL_FUNCS.keys():
+        for opt in args:
+            try:
+                ofn = eval(f"{fn}_{opt}")
+            except NameError:
+                continue
+
+            # if we already have a default, then we can disable it, as we know
+            # we can do better.
+            try:
+                best = eval(f"{fn}_default")
+                best_ofn = eval(f"{best}")
+                if best_ofn != ofn:
+                    exec(f"{best}_link = False", globals())
+            except NameError:
+                pass
+
+            exec(f"{fn}_default='{fn}_{opt}'", globals())
+            exec(f"{fn}_{opt}_link=True", globals())
+
+def forward_decls(*args: str):
+    ALL_FORWARD_DECLS.extend(args)
+
+#
+# Process the directives according to the command line
+#
+def process_forward_decls():
+  for f in ALL_FORWARD_DECLS:
+    exec(f'{f}()', globals())
+
+def determine_indirection(*params: str):
+    if vpx_config("CONFIG_RUNTIME_CPU_DETECT") != "yes":
+        require(*ALL_ARCHS)
+    for fn in ALL_FUNCS.keys():
+        n = ""
+        val = list(ALL_FUNCS[fn])
+        args = val.pop()
+        rtyp = ' '.join(val)
+        dfn = eval(f"{fn}_default")
+        dfn = eval(f"{dfn}")
+        for opt in params:
+            try:
+                ofn = eval(f"{fn}_{opt}")
+            except:
+                continue
+            try:
+                link = eval(f"{fn}_{opt}_link")
+                if link == False:
+                    continue
+            except:
+                pass
+            n += "x"
+        exec(f'{fn}_indirect = {n != "x"}', globals())
+
+def declare_function_pointers(*params: str):
+    for fn in sorted(ALL_FUNCS.keys()):
+        val = list(ALL_FUNCS[fn])
+        args = val.pop()
+        rtyp = ' '.join(val)
+        dfn = eval(f"{fn}_default")
+        dfn = eval(f"{dfn}")
+        for opt in params:
+            try:
+                ofn = eval(f"{fn}_{opt}")
+            except:
+                continue
+            print(f"{rtyp} {ofn}({args});")
+        if not eval(f"{fn}_indirect"):
+            print(f"#define {fn} {dfn}")
+        else:
+            print(f"RTCD_EXTERN {rtyp} (*{fn})({args});")
+        print("")
+
+def set_function_pointers(*params: str):
+    for fn in sorted(ALL_FUNCS.keys()):
+        val = list(ALL_FUNCS[fn])
+        args = val.pop()
+        rtyp = ' '.join(val)
+        dfn = eval(f"{fn}_default")
+        dfn = eval(f"{dfn}")
+        if eval(f"{fn}_indirect"):
+            print(f"    {fn} = {dfn};")
+            for opt in params:
+                try:
+                    ofn = eval(f"{fn}_{opt}")
+                except:
+                    continue
+                if ofn == dfn:
+                    continue
+                try:
+                    link = eval(f"{fn}_{opt}_link")
+                    if link == False:
+                        continue
+                except:
+                    pass
+                cond = eval(f"have_{opt}")
+                print(f"    if ({cond}) {fn} = {ofn};")
+
+def filter(*args: str) -> List[str]:
+    filtered = []
+    for arg in args:
+        if not arg in disabled:
+            filtered.append(arg)
+    return filtered
+
+#
+# Helper functions for generating the arch specific RTCD files
+#
+def common_top():
+    include_guard = str(opts['sym']).upper() + "_H_"
+    print(f'''// This file is generated. Do not edit.
+#ifndef {include_guard}
+#define {include_guard}
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+''')
+
+    process_forward_decls()
+    print('''#ifdef __cplusplus
+extern "C" {
+#endif
+''')
+    declare_function_pointers("c", *ALL_ARCHS)
+
+    print(f'''void {opts['sym']}(void);
+''')
+
+def common_bottom():
+  print('''
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif''')
+
+def x86():
+    determine_indirection("c", *ALL_ARCHS)
+
+    # Assign the helper variable for each enabled extension
+    for opt in ALL_ARCHS:
+        opt_uc = opt.upper()
+        exec(f"have_{opt}=\"flags & HAS_{opt_uc}\"", globals())
+
+    common_top()
+    print('''#ifdef RTCD_C
+#include "vpx_ports/x86.h"
+static void setup_rtcd_internal(void)
+{
+    int flags = x86_simd_caps();
+
+    (void)flags;
+''')
+
+    set_function_pointers("c", *ALL_ARCHS)
+
+    print('''}
+#endif''')
+    common_bottom()
+
+def arm():
+    determine_indirection("c", *ALL_ARCHS)
+
+    # Assign the helper variable for each enabled extension
+    for opt in ALL_ARCHS:
+        opt_uc = opt.upper()
+        # Enable neon assembly based on HAVE_NEON logic instead of adding new
+        # HAVE_NEON_ASM logic
+        if opt == 'neon_asm': opt_uc = 'NEON'
+        exec(f"have_{opt}=\"flags & HAS_{opt_uc}\"", globals())
+
+    common_top()
+    print('''#include "vpx_config.h"
+
+#ifdef RTCD_C
+#include "vpx_ports/arm.h"
+static void setup_rtcd_internal(void)
+{
+    int flags = arm_cpu_caps();
+
+    (void)flags;
+''')
+
+    set_function_pointers("c", *ALL_ARCHS)
+
+    print('''}
+#endif''')
+    common_bottom()
+
+def mips():
+    determine_indirection("c", *ALL_ARCHS)
+
+    # Assign the helper variable for each enabled extension
+    for opt in ALL_ARCHS:
+        opt_uc = opt.upper()
+        exec(f"have_{opt}=\"flags & HAS_{opt_uc}\"", globals())
+
+    common_top()
+
+    print('''#include "vpx_config.h"
+
+#ifdef RTCD_C
+#include "vpx_ports/mips.h"
+static void setup_rtcd_internal(void)
+{
+    int flags = mips_cpu_caps();
+
+    (void)flags;
+''')
+
+    set_function_pointers("c", *ALL_ARCHS)
+
+    print('''
+#if HAVE_DSPR2
+void vpx_dsputil_static_init();
+#if CONFIG_VP8
+void dsputil_static_init();
+#endif
+
+vpx_dsputil_static_init();
+#if CONFIG_VP8
+dsputil_static_init();
+#endif
+#endif
+}
+#endif''')
+    common_bottom()
+
+def ppc():
+    determine_indirection("c", *ALL_ARCHS)
+
+    # Assign the helper variable for each enabled extension
+    for opt in ALL_ARCHS:
+        opt_uc = opt.upper()
+        exec(f"have_{opt}=\"flags & HAS_{opt_uc}\"", globals())
+
+    common_top()
+    print('''#include "vpx_config.h"
+
+#ifdef RTCD_C
+#include "vpx_ports/ppc.h"
+static void setup_rtcd_internal(void)
+{
+    int flags = ppc_simd_caps();
+    (void)flags;
+''')
+
+    set_function_pointers("c", *ALL_ARCHS)
+
+    print('''}
+#endif''')
+    common_bottom()
+
+def loongarch():
+    determine_indirection("c", *ALL_ARCHS)
+
+    # Assign the helper variable for each enabled extension
+    for opt in ALL_ARCHS:
+        opt_uc = opt.upper()
+        exec(f"have_{opt}=\"flags & HAS_{opt_uc}\"", globals())
+
+    common_top()
+    print('''#include "vpx_config.h"
+
+#ifdef RTCD_C
+#include "vpx_ports/loongarch.h"
+static void setup_rtcd_internal(void)
+{
+    int flags = loongarch_cpu_caps();
+
+    (void)flags;
+''')
+
+    set_function_pointers("c", *ALL_ARCHS)
+
+    print('''}
+#endif''')
+    common_bottom()
+
+def unoptimized():
+    determine_indirection("c")
+    common_top()
+    print('''#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void)
+{
+''')
+
+    set_function_pointers("c")
+
+    print('''}
+#endif''')
+    common_bottom()
+
+#
+# Main Driver
+#
+
+if __name__ == '__main__':
+    parser = ArgumentParser(description='Reads the Run Time CPU Detections definitions from FILE and generates a C header file on stdout.')
+    parser.add_argument('--arch', help='Architecture to generate defs for', required=True)
+    parser.add_argument('--disable', metavar='EXT', action='append', default=[], help='Disable support for EXT extension')
+    parser.add_argument('--require', metavar='EXT', action='append', default=[], help='Require support for EXT extension')
+    parser.add_argument('--sym', metavar='SYMBOL', help='Unique symbol to use for RTCD initialization function')
+    parser.add_argument('--config', metavar='FILE', type=Path, help='File with CONFIG_FOO=yes lines to parse', required=True)
+    parser.add_argument('file', metavar='FILE', nargs='+', type=Path)
+
+    args = parser.parse_known_args()
+
+    opts = vars(args[0])
+
+    for ext in opts['disable']:
+        disabled.append(ext)
+    for ext in opts['require']:
+        required.append(ext)
+    for ext in args[1]:
+        match = re.match('--disable-(.+)', ext)
+        if match:
+            disabled.append(match.group(1))
+            continue
+        match = re.match('--enable-(.+)', ext)
+        if match:
+            required.append(match.group(1))
+            continue
+
+    with Path(opts['config']).open('r', encoding='utf-8') as f:
+        for line in f:
+            if not re.search(r'^(?:CONFIG_|HAVE_)', line):
+                continue
+            pair = line.strip().split('=')
+            config[pair[0]] = pair[1]
+
+    #
+    # Include the user's directives
+    #
+    for file in args[0].file:
+        with file.open('r', encoding='utf-8') as f:
+            try:
+                exec(f.read(), globals())
+            except BaseException as e:
+                raise RuntimeWarning(f'exec failed: {e}')
+
+
+    require(*qw("c"))
+    require(*required)
+    if opts['arch'] == 'x86':
+        ALL_ARCHS = filter(*qw('mmx sse sse2 sse3 ssse3 sse4_1 avx avx2 avx512'))
+        x86()
+    elif opts['arch'] == 'x86_64':
+        ALL_ARCHS = filter(*qw('mmx sse sse2 sse3 ssse3 sse4_1 avx avx2 avx512'))
+        REQUIRES = filter(*qw('mmx sse sse2'))
+        require(*REQUIRES)
+        x86()
+    elif opts['arch'] == 'mips32' or opts['arch'] == 'mips64':
+        have_dspr2 = False
+        have_msa = False
+        have_mmi = False
+        ALL_ARCHS = filter(*opts["arch"])
+        CONFIG_FILE: Path = opts['config']
+        for line in CONFIG_FILE.open('r', encoding='utf-8'):
+            have_dspr2 = re.search(r'HAVE_DSPR2=yes', line) is not None
+            have_msa = re.search(r'HAVE_MSA=yes', line) is not None
+            have_mmi = re.search(r'HAVE_MMI=yes', line) is not None
+        if have_dspr2:
+            ALL_ARCHS = filter(*opts['arch'], *qw('dspr2'))
+        elif have_msa and have_mmi:
+            ALL_ARCHS = filter(*opts['arch'], *qw('mmi msa'))
+        elif have_msa:
+            ALL_ARCHS = filter(*opts['arch'], *qw('msa'))
+        elif have_mmi:
+            ALL_ARCHS = filter(*opts['arch'], *qw('mmi'))
+        else:
+            unoptimized()
+        mips()
+    elif re.search(r'armv7\w?', opts['arch']):
+        ALL_ARCHS = filter(*qw('neon_asm neon'))
+        arm()
+    elif opts['arch'] == 'armv8' or opts['arch'] == 'arm64':
+        ALL_ARCHS = filter(*qw('neon'))
+        REQUIRES = filter(*qw('neon'))
+        require(*REQUIRES)
+        arm()
+    elif re.search(r'^ppc', opts['arch']):
+        ALL_ARCHS = filter(*qw('vsx'))
+        ppc()
+    elif re.search(r'loongarch', opts['arch']):
+        ALL_ARCHS = filter(*qw('lsx lasx'))
+        loongarch()
+    else:
+        unoptimized()
diff --git a/meson.build b/meson.build
index 4ab8451b8..016528a03 100644
--- a/meson.build
+++ b/meson.build
@@ -461,7 +461,7 @@ foreach feature: disable_features
 			features.set('@0@_decoder'.format(feature), false)
 		endif
 	elif ARCH_EXT_LIST.contains(feature)
-		rtcd_options += ['--disable-@0@'.format(feature)]
+		rtcd_options += ['--disable', feature]
 	elif features.get(feature, true) # action == disable and not disabled
 		if not CMDLINE_SELECT.contains(feature)
 			error('Unknown option @0@'.format(feature))
@@ -857,7 +857,7 @@ elif tgt_isa == 'ppc64' and target_machine.endian() == 'little'
 	# Do not enable vsx by default.
 	# https://bugs.chromium.org/p/webm/issues/detail?id=1522
 	if not features.get('vsx', false)
-		rtcd_options += ['--disable-vsx']
+		rtcd_options += ['--disable', 'vsx']
 	endif
 
 	if tune_cpu.startswith('power')
@@ -922,7 +922,7 @@ elif tgt_isa.startswith('x86')
 		# See https://chromium-review.googlesource.com/c/webm/libvpx/+/751863
 		if c.version().version_compare('< 19.20.27508')
 			warning('This version of Visual Studio does not support avx512, disabling.....')
-			rtcd_options += ['--disable-avx512']
+			rtcd_options += ['--disable', 'avx512']
 			feature = 'avx512'
 			if not features.get(feature, false) # ! enabled
 				if not features.has(feature) # disabled
@@ -952,7 +952,7 @@ elif tgt_isa.startswith('x86')
 		# disable higher order extensions to simplify asm dependencies
 		if disable_exts
 			if features.get(ext, true)
-				rtcd_options += ['--disable-@0@'.format(ext)]
+				rtcd_options += ['--disable', ext]
 				message('\tdisabling @0@'.format(ext))
 				features.set(ext, false)
 			endif
@@ -963,7 +963,7 @@ elif tgt_isa.startswith('x86')
 				exts = ['avx512f', 'avx512cd', 'avx512bw', 'avx512dq', 'avx512vl']
 				foreach feature : exts
 					if features.get('gcc', false) and features.get(ext, true) and not c.has_argument('-m@0@'.format(feature))
-						rtcd_options += ['--disable-@0@'.format(ext)]
+						rtcd_options += ['--disable', ext]
 					else
 						if features.get(ext, true) # soft_enabled
 							if not features.has(ext)
@@ -985,7 +985,7 @@ elif tgt_isa.startswith('x86')
 				)
 					warning('disabling avx512: not supported by compiler')
 					features.set('avx512', false)
-					rtcd_options += ['--disable-avx512']
+					rtcd_options += ['--disable', 'avx512']
 				endif
 			else
 				# use the shortened version for the flag: sse4_1 -> sse4
@@ -998,7 +998,7 @@ elif tgt_isa.startswith('x86')
 				opt = ext
 				foreach feature : exts
 					if features.get('gcc', false) and features.get(opt, true) and not c.has_argument('-m@0@'.format(feature))
-						rtcd_options += ['--disable-@0@'.format(feature)]
+						rtcd_options += ['--disable', feature]
 					else
 						if features.get(opt, true) # soft_enabled
 							if not features.has(opt)
diff --git a/vp8/common/rtcd_defs.py b/vp8/common/rtcd_defs.py
new file mode 100755
index 000000000..4edaea4cd
--- /dev/null
+++ b/vp8/common/rtcd_defs.py
@@ -0,0 +1,248 @@
+# SPDX-FileCopyrightText: 2017 The WebM Authors
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@centricular.com>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typing import Any, Dict, List
+    opts: Dict[str, Any] = {}
+    def qw(s: str) -> List[str]: ...
+    def forward_decls(*args: str): ...
+    def add_proto(*args: str): ...
+    def specialize(*args: str): ...
+    def vpx_config(s: str) -> str: ...
+
+def vp8_common_forward_decls():
+    print('''/*
+ * VP8
+ */
+
+struct blockd;
+struct macroblockd;
+struct loop_filter_info;
+
+/* Encoder forward decls */
+struct block;
+struct macroblock;
+struct variance_vtable;
+union int_mv;
+struct yv12_buffer_config;
+''')
+forward_decls(*qw('vp8_common_forward_decls'))
+
+#
+# Dequant
+#
+add_proto(*qw('void vp8_dequantize_b'), "struct blockd*, short *DQC")
+specialize(*qw('vp8_dequantize_b mmx neon msa mmi'))
+
+add_proto(*qw('void vp8_dequant_idct_add'), "short *input, short *dq, unsigned char *dest, int stride")
+specialize(*qw('vp8_dequant_idct_add mmx neon dspr2 msa mmi'))
+
+add_proto(*qw('void vp8_dequant_idct_add_y_block'), "short *q, short *dq, unsigned char *dst, int stride, char *eobs")
+specialize(*qw('vp8_dequant_idct_add_y_block sse2 neon dspr2 msa mmi lsx'))
+
+add_proto(*qw('void vp8_dequant_idct_add_uv_block'), "short *q, short *dq, unsigned char *dst_u, unsigned char *dst_v, int stride, char *eobs")
+specialize(*qw('vp8_dequant_idct_add_uv_block sse2 neon dspr2 msa mmi lsx'))
+
+#
+# Loopfilter
+#
+add_proto(*qw('void vp8_loop_filter_mbv'), "unsigned char *y_ptr, unsigned char *u_ptr, unsigned char *v_ptr, int y_stride, int uv_stride, struct loop_filter_info *lfi")
+specialize(*qw('vp8_loop_filter_mbv sse2 neon dspr2 msa mmi lsx'))
+
+add_proto(*qw('void vp8_loop_filter_bv'), "unsigned char *y_ptr, unsigned char *u_ptr, unsigned char *v_ptr, int y_stride, int uv_stride, struct loop_filter_info *lfi")
+specialize(*qw('vp8_loop_filter_bv sse2 neon dspr2 msa mmi lsx'))
+
+add_proto(*qw('void vp8_loop_filter_mbh'), "unsigned char *y_ptr, unsigned char *u_ptr, unsigned char *v_ptr, int y_stride, int uv_stride, struct loop_filter_info *lfi")
+specialize(*qw('vp8_loop_filter_mbh sse2 neon dspr2 msa mmi lsx'))
+
+add_proto(*qw('void vp8_loop_filter_bh'), "unsigned char *y_ptr, unsigned char *u_ptr, unsigned char *v_ptr, int y_stride, int uv_stride, struct loop_filter_info *lfi")
+specialize(*qw('vp8_loop_filter_bh sse2 neon dspr2 msa mmi lsx'))
+
+
+add_proto(*qw('void vp8_loop_filter_simple_mbv'), "unsigned char *y_ptr, int y_stride, const unsigned char *blimit")
+specialize(*qw('vp8_loop_filter_simple_mbv sse2 neon msa mmi'))
+vp8_loop_filter_simple_mbv_c='vp8_loop_filter_simple_vertical_edge_c'
+vp8_loop_filter_simple_mbv_sse2='vp8_loop_filter_simple_vertical_edge_sse2'
+vp8_loop_filter_simple_mbv_neon='vp8_loop_filter_mbvs_neon'
+vp8_loop_filter_simple_mbv_msa='vp8_loop_filter_simple_vertical_edge_msa'
+vp8_loop_filter_simple_mbv_mmi='vp8_loop_filter_simple_vertical_edge_mmi'
+
+add_proto(*qw('void vp8_loop_filter_simple_mbh'), "unsigned char *y_ptr, int y_stride, const unsigned char *blimit")
+specialize(*qw('vp8_loop_filter_simple_mbh sse2 neon msa mmi'))
+vp8_loop_filter_simple_mbh_c='vp8_loop_filter_simple_horizontal_edge_c'
+vp8_loop_filter_simple_mbh_sse2='vp8_loop_filter_simple_horizontal_edge_sse2'
+vp8_loop_filter_simple_mbh_neon='vp8_loop_filter_mbhs_neon'
+vp8_loop_filter_simple_mbh_msa='vp8_loop_filter_simple_horizontal_edge_msa'
+vp8_loop_filter_simple_mbh_mmi='vp8_loop_filter_simple_horizontal_edge_mmi'
+
+add_proto(*qw('void vp8_loop_filter_simple_bv'), "unsigned char *y_ptr, int y_stride, const unsigned char *blimit")
+specialize(*qw('vp8_loop_filter_simple_bv sse2 neon msa mmi'))
+vp8_loop_filter_simple_bv_c='vp8_loop_filter_bvs_c'
+vp8_loop_filter_simple_bv_sse2='vp8_loop_filter_bvs_sse2'
+vp8_loop_filter_simple_bv_neon='vp8_loop_filter_bvs_neon'
+vp8_loop_filter_simple_bv_msa='vp8_loop_filter_bvs_msa'
+vp8_loop_filter_simple_bv_mmi='vp8_loop_filter_bvs_mmi'
+
+add_proto(*qw('void vp8_loop_filter_simple_bh'), "unsigned char *y_ptr, int y_stride, const unsigned char *blimit")
+specialize(*qw('vp8_loop_filter_simple_bh sse2 neon msa mmi'))
+vp8_loop_filter_simple_bh_c='vp8_loop_filter_bhs_c'
+vp8_loop_filter_simple_bh_sse2='vp8_loop_filter_bhs_sse2'
+vp8_loop_filter_simple_bh_neon='vp8_loop_filter_bhs_neon'
+vp8_loop_filter_simple_bh_msa='vp8_loop_filter_bhs_msa'
+vp8_loop_filter_simple_bh_mmi='vp8_loop_filter_bhs_mmi'
+
+#
+# IDCT
+#
+#idct16
+add_proto(*qw('void vp8_short_idct4x4llm'), "short *input, unsigned char *pred_ptr, int pred_stride, unsigned char *dst_ptr, int dst_stride")
+specialize(*qw('vp8_short_idct4x4llm mmx neon dspr2 msa mmi'))
+
+#iwalsh1
+add_proto(*qw('void vp8_short_inv_walsh4x4_1'), "short *input, short *mb_dqcoeff")
+specialize(*qw('vp8_short_inv_walsh4x4_1 dspr2'))
+
+#iwalsh16
+add_proto(*qw('void vp8_short_inv_walsh4x4'), "short *input, short *mb_dqcoeff")
+specialize(*qw('vp8_short_inv_walsh4x4 sse2 neon dspr2 msa mmi'))
+
+#idct1_scalar_add
+add_proto(*qw('void vp8_dc_only_idct_add'), "short input_dc, unsigned char *pred_ptr, int pred_stride, unsigned char *dst_ptr, int dst_stride")
+specialize(*qw('vp8_dc_only_idct_add mmx neon dspr2 msa mmi lsx'))
+
+#
+# RECON
+#
+add_proto(*qw('void vp8_copy_mem16x16'), "unsigned char *src, int src_stride, unsigned char *dst, int dst_stride")
+specialize(*qw('vp8_copy_mem16x16 sse2 neon dspr2 msa mmi'))
+
+add_proto(*qw('void vp8_copy_mem8x8'), "unsigned char *src, int src_stride, unsigned char *dst, int dst_stride")
+specialize(*qw('vp8_copy_mem8x8 mmx neon dspr2 msa mmi'))
+
+add_proto(*qw('void vp8_copy_mem8x4'), "unsigned char *src, int src_stride, unsigned char *dst, int dst_stride")
+specialize(*qw('vp8_copy_mem8x4 mmx neon dspr2 msa mmi'))
+
+#
+# Postproc
+#
+if vpx_config("CONFIG_POSTPROC") == "yes":
+
+    add_proto(*qw('void vp8_blend_mb_inner'), "unsigned char *y, unsigned char *u, unsigned char *v, int y_1, int u_1, int v_1, int alpha, int stride")
+
+    add_proto(*qw('void vp8_blend_mb_outer'), "unsigned char *y, unsigned char *u, unsigned char *v, int y_1, int u_1, int v_1, int alpha, int stride")
+
+    add_proto(*qw('void vp8_blend_b'), "unsigned char *y, unsigned char *u, unsigned char *v, int y_1, int u_1, int v_1, int alpha, int stride")
+
+    add_proto(*qw('void vp8_filter_by_weight16x16'), "unsigned char *src, int src_stride, unsigned char *dst, int dst_stride, int src_weight")
+    specialize(*qw('vp8_filter_by_weight16x16 sse2 msa'))
+
+    add_proto(*qw('void vp8_filter_by_weight8x8'), "unsigned char *src, int src_stride, unsigned char *dst, int dst_stride, int src_weight")
+    specialize(*qw('vp8_filter_by_weight8x8 sse2 msa'))
+
+    add_proto(*qw('void vp8_filter_by_weight4x4'), "unsigned char *src, int src_stride, unsigned char *dst, int dst_stride, int src_weight")
+
+#
+# Subpixel
+#
+add_proto(*qw('void vp8_sixtap_predict16x16'), "unsigned char *src_ptr, int src_pixels_per_line, int xoffset, int yoffset, unsigned char *dst_ptr, int dst_pitch")
+specialize(*qw('vp8_sixtap_predict16x16 sse2 ssse3 neon dspr2 msa mmi lsx'))
+
+add_proto(*qw('void vp8_sixtap_predict8x8'), "unsigned char *src_ptr, int src_pixels_per_line, int xoffset, int yoffset, unsigned char *dst_ptr, int dst_pitch")
+specialize(*qw('vp8_sixtap_predict8x8 sse2 ssse3 neon dspr2 msa mmi lsx'))
+
+add_proto(*qw('void vp8_sixtap_predict8x4'), "unsigned char *src_ptr, int src_pixels_per_line, int xoffset, int yoffset, unsigned char *dst_ptr, int dst_pitch")
+specialize(*qw('vp8_sixtap_predict8x4 sse2 ssse3 neon dspr2 msa mmi'))
+
+add_proto(*qw('void vp8_sixtap_predict4x4'), "unsigned char *src_ptr, int src_pixels_per_line, int xoffset, int yoffset, unsigned char *dst_ptr, int dst_pitch")
+specialize(*qw('vp8_sixtap_predict4x4 mmx ssse3 neon dspr2 msa mmi lsx'))
+
+add_proto(*qw('void vp8_bilinear_predict16x16'), "unsigned char *src_ptr, int src_pixels_per_line, int xoffset, int yoffset, unsigned char *dst_ptr, int dst_pitch")
+specialize(*qw('vp8_bilinear_predict16x16 sse2 ssse3 neon msa'))
+
+add_proto(*qw('void vp8_bilinear_predict8x8'), "unsigned char *src_ptr, int src_pixels_per_line, int xoffset, int yoffset, unsigned char *dst_ptr, int dst_pitch")
+specialize(*qw('vp8_bilinear_predict8x8 sse2 ssse3 neon msa'))
+
+add_proto(*qw('void vp8_bilinear_predict8x4'), "unsigned char *src_ptr, int src_pixels_per_line, int xoffset, int yoffset, unsigned char *dst_ptr, int dst_pitch")
+specialize(*qw('vp8_bilinear_predict8x4 sse2 neon msa'))
+
+add_proto(*qw('void vp8_bilinear_predict4x4'), "unsigned char *src_ptr, int src_pixels_per_line, int xoffset, int yoffset, unsigned char *dst_ptr, int dst_pitch")
+specialize(*qw('vp8_bilinear_predict4x4 sse2 neon msa'))
+
+#
+# Encoder functions below this point.
+#
+if vpx_config("CONFIG_VP8_ENCODER") == "yes":
+
+    #
+    # Block copy
+    #
+    add_proto(*qw('void vp8_copy32xn'), "const unsigned char *src_ptr, int src_stride, unsigned char *dst_ptr, int dst_stride, int height")
+    specialize(*qw('vp8_copy32xn sse2 sse3'))
+
+    #
+    # Forward DCT
+    #
+    add_proto(*qw('void vp8_short_fdct4x4'), "short *input, short *output, int pitch")
+    specialize(*qw('vp8_short_fdct4x4 sse2 neon msa mmi lsx'))
+
+    add_proto(*qw('void vp8_short_fdct8x4'), "short *input, short *output, int pitch")
+    specialize(*qw('vp8_short_fdct8x4 sse2 neon msa mmi lsx'))
+
+    add_proto(*qw('void vp8_short_walsh4x4'), "short *input, short *output, int pitch")
+    specialize(*qw('vp8_short_walsh4x4 sse2 neon msa mmi'))
+
+    #
+    # Quantizer
+    #
+    add_proto(*qw('void vp8_regular_quantize_b'), "struct block *, struct blockd *")
+    specialize(*qw('vp8_regular_quantize_b sse2 sse4_1 msa mmi lsx'))
+
+    add_proto(*qw('void vp8_fast_quantize_b'), "struct block *, struct blockd *")
+    specialize(*qw('vp8_fast_quantize_b sse2 ssse3 neon msa mmi'))
+
+    #
+    # Block subtraction
+    #
+    add_proto(*qw('int vp8_block_error'), "short *coeff, short *dqcoeff")
+    specialize(*qw('vp8_block_error sse2 msa lsx'))
+
+    add_proto(*qw('int vp8_mbblock_error'), "struct macroblock *mb, int dc")
+    specialize(*qw('vp8_mbblock_error sse2 msa lsx'))
+
+    add_proto(*qw('int vp8_mbuverror'), "struct macroblock *mb")
+    specialize(*qw('vp8_mbuverror sse2 msa'))
+
+    #
+    # Motion search
+    #
+    add_proto(*qw('int vp8_refining_search_sad'), "struct macroblock *x, struct block *b, struct blockd *d, union int_mv *ref_mv, int error_per_bit, int search_range, struct variance_vtable *fn_ptr, int *mvcost[2], union int_mv *center_mv")
+    specialize(*qw('vp8_refining_search_sad sse2 msa'))
+    vp8_refining_search_sad_sse2='vp8_refining_search_sadx4';
+    vp8_refining_search_sad_msa='vp8_refining_search_sadx4';
+
+    add_proto(*qw('int vp8_diamond_search_sad'), "struct macroblock *x, struct block *b, struct blockd *d, union int_mv *ref_mv, union int_mv *best_mv, int search_param, int sad_per_bit, int *num00, struct variance_vtable *fn_ptr, int *mvcost[2], union int_mv *center_mv")
+    specialize(*qw('vp8_diamond_search_sad sse2 msa lsx'))
+    vp8_diamond_search_sad_sse2='vp8_diamond_search_sadx4';
+    vp8_diamond_search_sad_msa='vp8_diamond_search_sadx4';
+    vp8_diamond_search_sad_lsx='vp8_diamond_search_sadx4';
+
+    #
+    # Alt-ref Noise Reduction (ARNR)
+    #
+    if vpx_config("CONFIG_REALTIME_ONLY") != "yes":
+        add_proto(*qw('void vp8_temporal_filter_apply'), "unsigned char *frame1, unsigned int stride, unsigned char *frame2, unsigned int block_size, int strength, int filter_weight, unsigned int *accumulator, unsigned short *count")
+        specialize(*qw('vp8_temporal_filter_apply sse2 msa'))
+
+    #
+    # Denoiser filter
+    #
+    if vpx_config("CONFIG_TEMPORAL_DENOISING") == "yes":
+        add_proto(*qw('int vp8_denoiser_filter'), "unsigned char *mc_running_avg_y, int mc_avg_y_stride, unsigned char *running_avg_y, int avg_y_stride, unsigned char *sig, int sig_stride, unsigned int motion_magnitude, int increase_denoising")
+        specialize(*qw('vp8_denoiser_filter sse2 neon msa'))
+        add_proto(*qw('int vp8_denoiser_filter_uv'), "unsigned char *mc_running_avg, int mc_avg_stride, unsigned char *running_avg, int avg_stride, unsigned char *sig, int sig_stride, unsigned int motion_magnitude, int increase_denoising")
+        specialize(*qw('vp8_denoiser_filter_uv sse2 neon msa'))
+
+    # End of encoder only functions
diff --git a/vp9/common/vp9_rtcd_defs.py b/vp9/common/vp9_rtcd_defs.py
new file mode 100755
index 000000000..41fdd120b
--- /dev/null
+++ b/vp9/common/vp9_rtcd_defs.py
@@ -0,0 +1,214 @@
+# SPDX-FileCopyrightText: 2017 The WebM Authors
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@centricular.com>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typing import Any, Dict, List
+    opts: Dict[str, Any] = {}
+    def qw(s: str) -> List[str]: ...
+    def forward_decls(*args: str): ...
+    def add_proto(*args: str): ...
+    def specialize(*args: str): ...
+    def vpx_config(s: str) -> str: ...
+
+def vp9_common_forward_decls():
+    print('''/*
+ * VP9
+ */
+
+#include "vpx/vpx_integer.h"
+#include "vp9/common/vp9_common.h"
+#include "vp9/common/vp9_enums.h"
+#include "vp9/common/vp9_filter.h"
+
+struct macroblockd;
+
+/* Encoder forward decls */
+struct macroblock;
+struct vp9_variance_vtable;
+struct search_site_config;
+struct mv;
+union int_mv;
+struct yv12_buffer_config;
+''')
+forward_decls(*qw('vp9_common_forward_decls'))
+
+# functions that are 64 bit only.
+mmx_x86_64 = sse2_x86_64 = ssse3_x86_64 = avx_x86_64 = avx2_x86_64 = ''
+if opts["arch"] == "x86_64":
+    mmx_x86_64 = 'mmx'
+    sse2_x86_64 = 'sse2'
+    ssse3_x86_64 = 'ssse3'
+    avx_x86_64 = 'avx'
+    avx2_x86_64 = 'avx2'
+    avx512_x86_64 = 'avx512'
+
+#
+# post proc
+#
+if vpx_config("CONFIG_VP9_POSTPROC") == "yes":
+    add_proto(*qw('void vp9_filter_by_weight16x16'), "const uint8_t *src, int src_stride, uint8_t *dst, int dst_stride, int src_weight")
+    specialize(*qw('vp9_filter_by_weight16x16 sse2 msa'))
+
+    add_proto(*qw('void vp9_filter_by_weight8x8'), "const uint8_t *src, int src_stride, uint8_t *dst, int dst_stride, int src_weight")
+    specialize(*qw('vp9_filter_by_weight8x8 sse2 msa'))
+
+#
+# dct
+#
+# Force C versions if CONFIG_EMULATE_HARDWARE is 1
+add_proto(*qw('void vp9_iht4x4_16_add'), "const tran_low_t *input, uint8_t *dest, int stride, int tx_type")
+
+add_proto(*qw('void vp9_iht8x8_64_add'), "const tran_low_t *input, uint8_t *dest, int stride, int tx_type")
+
+add_proto(*qw('void vp9_iht16x16_256_add'), "const tran_low_t *input, uint8_t *dest, int stride, int tx_type")
+
+if vpx_config("CONFIG_EMULATE_HARDWARE") != "yes":
+    # Note that there are more specializations appended when
+    # CONFIG_VP9_HIGHBITDEPTH is off.
+    specialize(*qw('vp9_iht4x4_16_add neon sse2 vsx'))
+    specialize(*qw('vp9_iht8x8_64_add neon sse2 vsx'))
+    specialize(*qw('vp9_iht16x16_256_add neon sse2 vsx'))
+    if vpx_config("CONFIG_VP9_HIGHBITDEPTH") != "yes":
+        # Note that these specializations are appended to the above ones.
+        specialize(*qw('vp9_iht4x4_16_add dspr2 msa'))
+        specialize(*qw('vp9_iht8x8_64_add dspr2 msa'))
+        specialize(*qw('vp9_iht16x16_256_add dspr2 msa'))
+
+# High bitdepth functions
+if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+    #
+    # post proc
+    #
+    if vpx_config("CONFIG_VP9_POSTPROC") == "yes":
+        add_proto(*qw('void vp9_highbd_mbpost_proc_down'), "uint16_t *dst, int pitch, int rows, int cols, int flimit")
+
+        add_proto(*qw('void vp9_highbd_mbpost_proc_across_ip'), "uint16_t *src, int pitch, int rows, int cols, int flimit")
+
+        add_proto(*qw('void vp9_highbd_post_proc_down_and_across'), "const uint16_t *src_ptr, uint16_t *dst_ptr, int src_pixels_per_line, int dst_pixels_per_line, int rows, int cols, int flimit")
+
+    #
+    # dct
+    #
+    # Note as optimized versions of these functions are added we need to add a check to ensure
+    # that when CONFIG_EMULATE_HARDWARE is on, it defaults to the C versions only.
+    add_proto(*qw('void vp9_highbd_iht4x4_16_add'), "const tran_low_t *input, uint16_t *dest, int stride, int tx_type, int bd")
+
+    add_proto(*qw('void vp9_highbd_iht8x8_64_add'), "const tran_low_t *input, uint16_t *dest, int stride, int tx_type, int bd")
+
+    add_proto(*qw('void vp9_highbd_iht16x16_256_add'), "const tran_low_t *input, uint16_t *dest, int stride, int tx_type, int bd")
+
+    if vpx_config("CONFIG_EMULATE_HARDWARE") != "yes":
+        specialize(*qw('vp9_highbd_iht4x4_16_add neon sse4_1'))
+        specialize(*qw('vp9_highbd_iht8x8_64_add neon sse4_1'))
+        specialize(*qw('vp9_highbd_iht16x16_256_add neon sse4_1'))
+
+#
+# Encoder functions below this point.
+#
+if vpx_config("CONFIG_VP9_ENCODER") == "yes":
+    # ENCODEMB INVOKE
+
+    #
+    # Denoiser
+    #
+    if vpx_config("CONFIG_VP9_TEMPORAL_DENOISING") == "yes":
+        add_proto(*qw('int vp9_denoiser_filter'), "const uint8_t *sig, int sig_stride, const uint8_t *mc_avg, int mc_avg_stride, uint8_t *avg, int avg_stride, int increase_denoising, BLOCK_SIZE bs, int motion_magnitude")
+        specialize(*qw('vp9_denoiser_filter neon sse2'))
+
+    add_proto(*qw('int64_t vp9_block_error'), "const tran_low_t *coeff, const tran_low_t *dqcoeff, intptr_t block_size, int64_t *ssz")
+
+    add_proto(*qw('int64_t vp9_block_error_fp'), "const tran_low_t *coeff, const tran_low_t *dqcoeff, int block_size")
+
+    add_proto(*qw('void vp9_quantize_fp'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *round_ptr, const int16_t *quant_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+    specialize(*qw('vp9_quantize_fp neon sse2 ssse3 avx2 vsx'))
+
+    add_proto(*qw('void vp9_quantize_fp_32x32'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *round_ptr, const int16_t *quant_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+    specialize(*qw('vp9_quantize_fp_32x32 neon ssse3 avx2 vsx'))
+
+    if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+        specialize(*qw('vp9_block_error avx2 sse2'))
+
+        specialize(*qw('vp9_block_error_fp avx2 sse2'))
+
+        add_proto(*qw('int64_t vp9_highbd_block_error'), "const tran_low_t *coeff, const tran_low_t *dqcoeff, intptr_t block_size, int64_t *ssz, int bd")
+        specialize(*qw('vp9_highbd_block_error sse2'))
+    else:
+        specialize(*qw('vp9_block_error avx2 msa sse2'))
+
+        specialize(*qw('vp9_block_error_fp neon avx2 sse2'))
+
+    # fdct functions
+
+    add_proto(*qw('void vp9_fht4x4'), "const int16_t *input, tran_low_t *output, int stride, int tx_type")
+
+    add_proto(*qw('void vp9_fht8x8'), "const int16_t *input, tran_low_t *output, int stride, int tx_type")
+
+    add_proto(*qw('void vp9_fht16x16'), "const int16_t *input, tran_low_t *output, int stride, int tx_type")
+
+    add_proto(*qw('void vp9_fwht4x4'), "const int16_t *input, tran_low_t *output, int stride")
+
+    # Note that there are more specializations appended when CONFIG_VP9_HIGHBITDEPTH
+    # is off.
+    specialize(*qw('vp9_fht4x4 sse2 neon'))
+    specialize(*qw('vp9_fht8x8 sse2 neon'))
+    specialize(*qw('vp9_fht16x16 sse2 neon'))
+    specialize(*qw('vp9_fwht4x4 sse2'))
+    if vpx_config("CONFIG_VP9_HIGHBITDEPTH") != "yes":
+        # Note that these specializations are appended to the above ones.
+        specialize(*qw('vp9_fht4x4 msa'))
+        specialize(*qw('vp9_fht8x8 msa'))
+        specialize(*qw('vp9_fht16x16 msa'))
+        specialize(*qw('vp9_fwht4x4 msa'))
+
+    #
+    # Motion search
+    #
+    add_proto(*qw('int vp9_diamond_search_sad'), "const struct macroblock *x, const struct search_site_config *cfg,  struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, const struct mv *center_mv")
+    specialize(*qw('vp9_diamond_search_sad avx neon'))
+
+    #
+    # Apply temporal filter
+    #
+    if vpx_config("CONFIG_REALTIME_ONLY") != "yes":
+        add_proto(*qw('void vp9_apply_temporal_filter'), "const uint8_t *y_src, int y_src_stride, const uint8_t *y_pre, int y_pre_stride, const uint8_t *u_src, const uint8_t *v_src, int uv_src_stride, const uint8_t *u_pre, const uint8_t *v_pre, int uv_pre_stride, unsigned int block_width, unsigned int block_height, int ss_x, int ss_y, int strength, const int *const blk_fw, int use_32x32, uint32_t *y_accumulator, uint16_t *y_count, uint32_t *u_accumulator, uint16_t *u_count, uint32_t *v_accumulator, uint16_t *v_count")
+        specialize(*qw('vp9_apply_temporal_filter sse4_1'))
+
+        if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+            add_proto(*qw('void vp9_highbd_apply_temporal_filter'), "const uint16_t *y_src, int y_src_stride, const uint16_t *y_pre, int y_pre_stride, const uint16_t *u_src, const uint16_t *v_src, int uv_src_stride, const uint16_t *u_pre, const uint16_t *v_pre, int uv_pre_stride, unsigned int block_width, unsigned int block_height, int ss_x, int ss_y, int strength, const int *const blk_fw, int use_32x32, uint32_t *y_accum, uint16_t *y_count, uint32_t *u_accum, uint16_t *u_count, uint32_t *v_accum, uint16_t *v_count")
+            specialize(*qw('vp9_highbd_apply_temporal_filter sse4_1'))
+
+
+    if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+        # ENCODEMB INVOKE
+
+        add_proto(*qw('void vp9_highbd_quantize_fp'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *round_ptr, const int16_t *quant_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+        specialize(*qw('vp9_highbd_quantize_fp avx2 neon'))
+
+        add_proto(*qw('void vp9_highbd_quantize_fp_32x32'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *round_ptr, const int16_t *quant_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan" )
+        specialize(*qw('vp9_highbd_quantize_fp_32x32 avx2 neon'))
+
+        # fdct functions
+        add_proto(*qw('void vp9_highbd_fht4x4'), "const int16_t *input, tran_low_t *output, int stride, int tx_type")
+        specialize(*qw('vp9_highbd_fht4x4 neon'))
+
+        add_proto(*qw('void vp9_highbd_fht8x8'), "const int16_t *input, tran_low_t *output, int stride, int tx_type")
+
+        add_proto(*qw('void vp9_highbd_fht16x16'), "const int16_t *input, tran_low_t *output, int stride, int tx_type")
+
+        add_proto(*qw('void vp9_highbd_fwht4x4'), "const int16_t *input, tran_low_t *output, int stride")
+
+        add_proto(*qw('void vp9_highbd_temporal_filter_apply'), "const uint8_t *frame1, unsigned int stride, const uint8_t *frame2, unsigned int block_width, unsigned int block_height, int strength, int *blk_fw, int use_32x32, uint32_t *accumulator, uint16_t *count")
+
+    # End vp9_high encoder functions
+
+    #
+    # frame based scale
+    #
+    add_proto(*qw('void vp9_scale_and_extend_frame'), "const struct yv12_buffer_config *src, struct yv12_buffer_config *dst, INTERP_FILTER filter_type, int phase_scaler")
+    specialize(*qw('vp9_scale_and_extend_frame neon ssse3'))
+
+# end encoder functions
+
diff --git a/vpx_dsp/vpx_dsp_rtcd_defs.py b/vpx_dsp/vpx_dsp_rtcd_defs.py
new file mode 100755
index 000000000..03974bebd
--- /dev/null
+++ b/vpx_dsp/vpx_dsp_rtcd_defs.py
@@ -0,0 +1,1655 @@
+# SPDX-FileCopyrightText: 2017 The WebM Authors
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@centricular.com>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typing import Any, Dict, List
+    opts: Dict[str, Any] = {}
+    def qw(s: str) -> List[str]: ...
+    def forward_decls(*args: str): ...
+    def add_proto(*args: str): ...
+    def specialize(*args: str): ...
+    def vpx_config(s: str) -> str: ...
+
+def vpx_dsp_forward_decls():
+    print('''/*
+ * DSP
+ */
+
+#include "vpx/vpx_integer.h"
+#include "vpx_dsp/vpx_dsp_common.h"
+#include "vpx_dsp/vpx_filter.h"
+
+''')
+forward_decls(*qw('vpx_dsp_forward_decls'))
+
+# functions that are 64 bit only.
+mmx_x86_64 = sse2_x86_64 = ssse3_x86_64 = avx_x86_64 = avx2_x86_64 = ''
+if opts["arch"] == "x86_64":
+    mmx_x86_64 = 'mmx'
+    sse2_x86_64 = 'sse2'
+    ssse3_x86_64 = 'ssse3'
+    avx_x86_64 = 'avx'
+    avx2_x86_64 = 'avx2'
+    avx512_x86_64 = 'avx512'
+
+#
+# Intra prediction
+#
+
+add_proto(*qw('void vpx_d207_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d207_predictor_4x4 sse2'))
+
+add_proto(*qw('void vpx_d45_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d45_predictor_4x4 neon sse2'))
+
+add_proto(*qw('void vpx_d45e_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+
+add_proto(*qw('void vpx_d63_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d63_predictor_4x4 ssse3'))
+
+add_proto(*qw('void vpx_d63e_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+
+add_proto(*qw('void vpx_h_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+# TODO(crbug.com/webm/1522): Re-enable vsx implementation.
+specialize(*qw('vpx_h_predictor_4x4 neon dspr2 msa sse2'))
+
+add_proto(*qw('void vpx_he_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+
+add_proto(*qw('void vpx_d117_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+
+add_proto(*qw('void vpx_d135_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d135_predictor_4x4 neon'))
+
+add_proto(*qw('void vpx_d153_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d153_predictor_4x4 ssse3'))
+
+add_proto(*qw('void vpx_v_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_v_predictor_4x4 neon msa sse2'))
+
+add_proto(*qw('void vpx_ve_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+
+add_proto(*qw('void vpx_tm_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+# TODO(crbug.com/webm/1522): Re-enable vsx implementation.
+specialize(*qw('vpx_tm_predictor_4x4 neon dspr2 msa sse2'))
+
+add_proto(*qw('void vpx_dc_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_predictor_4x4 dspr2 msa neon sse2'))
+
+add_proto(*qw('void vpx_dc_top_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_top_predictor_4x4 msa neon sse2'))
+
+add_proto(*qw('void vpx_dc_left_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_left_predictor_4x4 msa neon sse2'))
+
+add_proto(*qw('void vpx_dc_128_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_128_predictor_4x4 msa neon sse2'))
+
+add_proto(*qw('void vpx_d207_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d207_predictor_8x8 ssse3'))
+
+add_proto(*qw('void vpx_d45_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+# TODO(crbug.com/webm/1522): Re-enable vsx implementation.
+specialize(*qw('vpx_d45_predictor_8x8 neon sse2'))
+
+add_proto(*qw('void vpx_d63_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+# TODO(crbug.com/webm/1522): Re-enable vsx implementation.
+specialize(*qw('vpx_d63_predictor_8x8 ssse3'))
+
+add_proto(*qw('void vpx_h_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+# TODO(crbug.com/webm/1522): Re-enable vsx implementation.
+specialize(*qw('vpx_h_predictor_8x8 neon dspr2 msa sse2'))
+
+add_proto(*qw('void vpx_d117_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+
+add_proto(*qw('void vpx_d135_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d135_predictor_8x8 neon'))
+
+add_proto(*qw('void vpx_d153_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d153_predictor_8x8 ssse3'))
+
+add_proto(*qw('void vpx_v_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_v_predictor_8x8 neon msa sse2'))
+
+add_proto(*qw('void vpx_tm_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+# TODO(crbug.com/webm/1522): Re-enable vsx implementation.
+specialize(*qw('vpx_tm_predictor_8x8 neon dspr2 msa sse2'))
+
+add_proto(*qw('void vpx_dc_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+# TODO(crbug.com/webm/1522): Re-enable vsx implementation.
+specialize(*qw('vpx_dc_predictor_8x8 dspr2 neon msa sse2 lsx'))
+
+add_proto(*qw('void vpx_dc_top_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_top_predictor_8x8 neon msa sse2'))
+
+add_proto(*qw('void vpx_dc_left_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_left_predictor_8x8 neon msa sse2'))
+
+add_proto(*qw('void vpx_dc_128_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_128_predictor_8x8 neon msa sse2'))
+
+add_proto(*qw('void vpx_d207_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d207_predictor_16x16 ssse3'))
+
+add_proto(*qw('void vpx_d45_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d45_predictor_16x16 neon ssse3 vsx'))
+
+add_proto(*qw('void vpx_d63_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d63_predictor_16x16 ssse3 vsx'))
+
+add_proto(*qw('void vpx_h_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_h_predictor_16x16 neon dspr2 msa sse2 vsx'))
+
+add_proto(*qw('void vpx_d117_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+
+add_proto(*qw('void vpx_d135_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d135_predictor_16x16 neon'))
+
+add_proto(*qw('void vpx_d153_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d153_predictor_16x16 ssse3'))
+
+add_proto(*qw('void vpx_v_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_v_predictor_16x16 neon msa sse2 vsx'))
+
+add_proto(*qw('void vpx_tm_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_tm_predictor_16x16 neon msa sse2 vsx'))
+
+add_proto(*qw('void vpx_dc_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_predictor_16x16 dspr2 neon msa sse2 vsx lsx'))
+
+add_proto(*qw('void vpx_dc_top_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_top_predictor_16x16 neon msa sse2 vsx'))
+
+add_proto(*qw('void vpx_dc_left_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_left_predictor_16x16 neon msa sse2 vsx'))
+
+add_proto(*qw('void vpx_dc_128_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_128_predictor_16x16 neon msa sse2 vsx'))
+
+add_proto(*qw('void vpx_d207_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d207_predictor_32x32 ssse3'))
+
+add_proto(*qw('void vpx_d45_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d45_predictor_32x32 neon ssse3 vsx'))
+
+add_proto(*qw('void vpx_d63_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d63_predictor_32x32 ssse3 vsx'))
+
+add_proto(*qw('void vpx_h_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_h_predictor_32x32 neon msa sse2 vsx'))
+
+add_proto(*qw('void vpx_d117_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+
+add_proto(*qw('void vpx_d135_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d135_predictor_32x32 neon'))
+
+add_proto(*qw('void vpx_d153_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d153_predictor_32x32 ssse3'))
+
+add_proto(*qw('void vpx_v_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_v_predictor_32x32 neon msa sse2 vsx'))
+
+add_proto(*qw('void vpx_tm_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_tm_predictor_32x32 neon msa sse2 vsx'))
+
+add_proto(*qw('void vpx_dc_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_predictor_32x32 msa neon sse2 vsx'))
+
+add_proto(*qw('void vpx_dc_top_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_top_predictor_32x32 msa neon sse2 vsx'))
+
+add_proto(*qw('void vpx_dc_left_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_left_predictor_32x32 msa neon sse2 vsx'))
+
+add_proto(*qw('void vpx_dc_128_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_dc_128_predictor_32x32 msa neon sse2 vsx'))
+
+# High bitdepth functions
+if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+    add_proto(*qw('void vpx_highbd_d207_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d207_predictor_4x4 sse2'))
+
+    add_proto(*qw('void vpx_highbd_d45_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d45_predictor_4x4 neon ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d63_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d63_predictor_4x4 sse2'))
+
+    add_proto(*qw('void vpx_highbd_h_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_h_predictor_4x4 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_d117_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d117_predictor_4x4 sse2'))
+
+    add_proto(*qw('void vpx_highbd_d135_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d135_predictor_4x4 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_d153_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d153_predictor_4x4 sse2'))
+
+    add_proto(*qw('void vpx_highbd_v_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_v_predictor_4x4 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_tm_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_tm_predictor_4x4 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_predictor_4x4 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_top_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_top_predictor_4x4 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_left_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_left_predictor_4x4 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_128_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_128_predictor_4x4 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_d207_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d207_predictor_8x8 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d45_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d45_predictor_8x8 neon ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d63_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d63_predictor_8x8 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_h_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_h_predictor_8x8 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_d117_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d117_predictor_8x8 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d135_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d135_predictor_8x8 neon ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d153_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d153_predictor_8x8 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_v_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_v_predictor_8x8 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_tm_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_tm_predictor_8x8 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_predictor_8x8 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_top_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_top_predictor_8x8 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_left_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_left_predictor_8x8 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_128_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_128_predictor_8x8 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_d207_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d207_predictor_16x16 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d45_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d45_predictor_16x16 neon ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d63_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d63_predictor_16x16 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_h_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_h_predictor_16x16 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_d117_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d117_predictor_16x16 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d135_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d135_predictor_16x16 neon ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d153_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d153_predictor_16x16 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_v_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_v_predictor_16x16 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_tm_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_tm_predictor_16x16 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_predictor_16x16 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_top_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_top_predictor_16x16 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_left_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_left_predictor_16x16 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_128_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_128_predictor_16x16 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_d207_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d207_predictor_32x32 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d45_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d45_predictor_32x32 neon ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d63_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d63_predictor_32x32 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_h_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_h_predictor_32x32 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_d117_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d117_predictor_32x32 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d135_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d135_predictor_32x32 neon ssse3'))
+
+    add_proto(*qw('void vpx_highbd_d153_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_d153_predictor_32x32 ssse3'))
+
+    add_proto(*qw('void vpx_highbd_v_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_v_predictor_32x32 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_tm_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_tm_predictor_32x32 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_predictor_32x32 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_top_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_top_predictor_32x32 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_left_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_left_predictor_32x32 neon sse2'))
+
+    add_proto(*qw('void vpx_highbd_dc_128_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
+    specialize(*qw('vpx_highbd_dc_128_predictor_32x32 neon sse2'))
+    # CONFIG_VP9_HIGHBITDEPTH
+
+if vpx_config("CONFIG_VP9") == "yes":
+    #
+    # Sub Pixel Filters
+    #
+    add_proto(*qw('void vpx_convolve_copy'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+    specialize(*qw('vpx_convolve_copy neon dspr2 msa sse2 vsx lsx'))
+
+    add_proto(*qw('void vpx_convolve_avg'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+    specialize(*qw('vpx_convolve_avg neon dspr2 msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_convolve8'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+    specialize(*qw('vpx_convolve8 sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_convolve8_horiz'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+    specialize(*qw('vpx_convolve8_horiz sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_convolve8_vert'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+    specialize(*qw('vpx_convolve8_vert sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_convolve8_avg'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+    specialize(*qw('vpx_convolve8_avg sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_convolve8_avg_horiz'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+    specialize(*qw('vpx_convolve8_avg_horiz sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_convolve8_avg_vert'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+    specialize(*qw('vpx_convolve8_avg_vert sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_scaled_2d'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+    specialize(*qw('vpx_scaled_2d ssse3 neon msa'))
+
+    add_proto(*qw('void vpx_scaled_horiz'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+
+    add_proto(*qw('void vpx_scaled_vert'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+
+    add_proto(*qw('void vpx_scaled_avg_2d'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+
+    add_proto(*qw('void vpx_scaled_avg_horiz'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+
+    add_proto(*qw('void vpx_scaled_avg_vert'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
+    #CONFIG_VP9
+
+if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+    #
+    # Sub Pixel Filters
+    #
+    add_proto(*qw('void vpx_highbd_convolve_copy'), "const uint16_t *src, ptrdiff_t src_stride, uint16_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h, int bd")
+    specialize(*qw('vpx_highbd_convolve_copy sse2 avx2 neon'))
+
+    add_proto(*qw('void vpx_highbd_convolve_avg'), "const uint16_t *src, ptrdiff_t src_stride, uint16_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h, int bd")
+    specialize(*qw('vpx_highbd_convolve_avg sse2 avx2 neon'))
+
+    add_proto(*qw('void vpx_highbd_convolve8'), "const uint16_t *src, ptrdiff_t src_stride, uint16_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h, int bd")
+    specialize(*qw('vpx_highbd_convolve8 avx2 neon'), f"{sse2_x86_64}")
+
+    add_proto(*qw('void vpx_highbd_convolve8_horiz'), "const uint16_t *src, ptrdiff_t src_stride, uint16_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h, int bd")
+    specialize(*qw('vpx_highbd_convolve8_horiz avx2 neon'), f"{sse2_x86_64}")
+
+    add_proto(*qw('void vpx_highbd_convolve8_vert'), "const uint16_t *src, ptrdiff_t src_stride, uint16_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h, int bd")
+    specialize(*qw('vpx_highbd_convolve8_vert avx2 neon'), f"{sse2_x86_64}")
+
+    add_proto(*qw('void vpx_highbd_convolve8_avg'), "const uint16_t *src, ptrdiff_t src_stride, uint16_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h, int bd")
+    specialize(*qw('vpx_highbd_convolve8_avg avx2 neon'), f"{sse2_x86_64}")
+
+    add_proto(*qw('void vpx_highbd_convolve8_avg_horiz'), "const uint16_t *src, ptrdiff_t src_stride, uint16_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h, int bd")
+    specialize(*qw('vpx_highbd_convolve8_avg_horiz avx2 neon'), f"{sse2_x86_64}")
+
+    add_proto(*qw('void vpx_highbd_convolve8_avg_vert'), "const uint16_t *src, ptrdiff_t src_stride, uint16_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h, int bd")
+    specialize(*qw('vpx_highbd_convolve8_avg_vert avx2 neon'), f"{sse2_x86_64}")
+    # CONFIG_VP9_HIGHBITDEPTH
+
+if vpx_config("CONFIG_VP9") == "yes":
+    #
+    # Loopfilter
+    #
+    add_proto(*qw('void vpx_lpf_vertical_16'), "uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh")
+    specialize(*qw('vpx_lpf_vertical_16 sse2 neon dspr2 msa'))
+
+    add_proto(*qw('void vpx_lpf_vertical_16_dual'), "uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh")
+    specialize(*qw('vpx_lpf_vertical_16_dual sse2 neon dspr2 msa lsx'))
+
+    add_proto(*qw('void vpx_lpf_vertical_8'), "uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh")
+    specialize(*qw('vpx_lpf_vertical_8 sse2 neon dspr2 msa lsx'))
+
+    add_proto(*qw('void vpx_lpf_vertical_8_dual'), "uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1")
+    specialize(*qw('vpx_lpf_vertical_8_dual sse2 neon dspr2 msa lsx'))
+
+    add_proto(*qw('void vpx_lpf_vertical_4'), "uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh")
+    specialize(*qw('vpx_lpf_vertical_4 sse2 neon dspr2 msa lsx'))
+
+    add_proto(*qw('void vpx_lpf_vertical_4_dual'), "uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1")
+    specialize(*qw('vpx_lpf_vertical_4_dual sse2 neon dspr2 msa lsx'))
+
+    add_proto(*qw('void vpx_lpf_horizontal_16'), "uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh")
+    specialize(*qw('vpx_lpf_horizontal_16 sse2 avx2 neon dspr2 msa'))
+
+    add_proto(*qw('void vpx_lpf_horizontal_16_dual'), "uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh")
+    specialize(*qw('vpx_lpf_horizontal_16_dual sse2 avx2 neon dspr2 msa lsx'))
+
+    add_proto(*qw('void vpx_lpf_horizontal_8'), "uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh")
+    specialize(*qw('vpx_lpf_horizontal_8 sse2 neon dspr2 msa lsx'))
+
+    add_proto(*qw('void vpx_lpf_horizontal_8_dual'), "uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1")
+    specialize(*qw('vpx_lpf_horizontal_8_dual sse2 neon dspr2 msa lsx'))
+
+    add_proto(*qw('void vpx_lpf_horizontal_4'), "uint8_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh")
+    specialize(*qw('vpx_lpf_horizontal_4 sse2 neon dspr2 msa lsx'))
+
+    add_proto(*qw('void vpx_lpf_horizontal_4_dual'), "uint8_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1")
+    specialize(*qw('vpx_lpf_horizontal_4_dual sse2 neon dspr2 msa lsx'))
+    #CONFIG_VP9
+
+if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+    add_proto(*qw('void vpx_highbd_lpf_vertical_16'), "uint16_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int bd")
+    specialize(*qw('vpx_highbd_lpf_vertical_16 sse2 neon'))
+
+    add_proto(*qw('void vpx_highbd_lpf_vertical_16_dual'), "uint16_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int bd")
+    specialize(*qw('vpx_highbd_lpf_vertical_16_dual sse2 neon'))
+
+    add_proto(*qw('void vpx_highbd_lpf_vertical_8'), "uint16_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int bd")
+    specialize(*qw('vpx_highbd_lpf_vertical_8 sse2 neon'))
+
+    add_proto(*qw('void vpx_highbd_lpf_vertical_8_dual'), "uint16_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1, int bd")
+    specialize(*qw('vpx_highbd_lpf_vertical_8_dual sse2 neon'))
+
+    add_proto(*qw('void vpx_highbd_lpf_vertical_4'), "uint16_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int bd")
+    specialize(*qw('vpx_highbd_lpf_vertical_4 sse2 neon'))
+
+    add_proto(*qw('void vpx_highbd_lpf_vertical_4_dual'), "uint16_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1, int bd")
+    specialize(*qw('vpx_highbd_lpf_vertical_4_dual sse2 neon'))
+
+    add_proto(*qw('void vpx_highbd_lpf_horizontal_16'), "uint16_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int bd")
+    specialize(*qw('vpx_highbd_lpf_horizontal_16 sse2 neon'))
+
+    add_proto(*qw('void vpx_highbd_lpf_horizontal_16_dual'), "uint16_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int bd")
+    specialize(*qw('vpx_highbd_lpf_horizontal_16_dual sse2 neon'))
+
+    add_proto(*qw('void vpx_highbd_lpf_horizontal_8'), "uint16_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int bd")
+    specialize(*qw('vpx_highbd_lpf_horizontal_8 sse2 neon'))
+
+    add_proto(*qw('void vpx_highbd_lpf_horizontal_8_dual'), "uint16_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1, int bd")
+    specialize(*qw('vpx_highbd_lpf_horizontal_8_dual sse2 neon'))
+
+    add_proto(*qw('void vpx_highbd_lpf_horizontal_4'), "uint16_t *s, int pitch, const uint8_t *blimit, const uint8_t *limit, const uint8_t *thresh, int bd")
+    specialize(*qw('vpx_highbd_lpf_horizontal_4 sse2 neon'))
+
+    add_proto(*qw('void vpx_highbd_lpf_horizontal_4_dual'), "uint16_t *s, int pitch, const uint8_t *blimit0, const uint8_t *limit0, const uint8_t *thresh0, const uint8_t *blimit1, const uint8_t *limit1, const uint8_t *thresh1, int bd")
+    specialize(*qw('vpx_highbd_lpf_horizontal_4_dual sse2 neon'))
+    # CONFIG_VP9_HIGHBITDEPTH
+
+#
+# Encoder functions.
+#
+
+#
+# Forward transform
+#
+if vpx_config("CONFIG_VP9_ENCODER") == "yes":
+    if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+        add_proto(*qw('void vpx_fdct4x4'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct4x4 neon sse2'))
+
+        add_proto(*qw('void vpx_fdct4x4_1'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct4x4_1 sse2 neon'))
+        specialize(*qw('vpx_highbd_fdct4x4_1 neon'))
+        vpx_highbd_fdct4x4_1_neon='vpx_fdct4x4_1_neon'
+
+        add_proto(*qw('void vpx_fdct8x8'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct8x8 neon sse2'))
+
+        add_proto(*qw('void vpx_fdct8x8_1'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct8x8_1 neon sse2 msa'))
+
+        add_proto(*qw('void vpx_fdct16x16'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct16x16 neon sse2'))
+
+        add_proto(*qw('void vpx_fdct16x16_1'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct16x16_1 sse2 neon'))
+
+        add_proto(*qw('void vpx_fdct32x32'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct32x32 neon sse2'))
+
+        add_proto(*qw('void vpx_fdct32x32_rd'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct32x32_rd neon sse2'))
+
+        add_proto(*qw('void vpx_fdct32x32_1'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct32x32_1 sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_fdct4x4'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_highbd_fdct4x4 sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_fdct8x8'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_highbd_fdct8x8 sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_fdct8x8_1'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_highbd_fdct8x8_1 neon'))
+        vpx_highbd_fdct8x8_1_neon='vpx_fdct8x8_1_neon'
+
+        add_proto(*qw('void vpx_highbd_fdct16x16'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_highbd_fdct16x16 sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_fdct16x16_1'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_highbd_fdct16x16_1 neon'))
+
+        add_proto(*qw('void vpx_highbd_fdct32x32'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_highbd_fdct32x32 sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_fdct32x32_rd'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_highbd_fdct32x32_rd sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_fdct32x32_1'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_highbd_fdct32x32_1 neon'))
+    else:
+        add_proto(*qw('void vpx_fdct4x4'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct4x4 neon sse2 msa lsx'))
+
+        add_proto(*qw('void vpx_fdct4x4_1'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct4x4_1 sse2 neon'))
+
+        add_proto(*qw('void vpx_fdct8x8'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct8x8 sse2 neon msa lsx'), f"{ssse3_x86_64}")
+
+        add_proto(*qw('void vpx_fdct8x8_1'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct8x8_1 sse2 neon msa'))
+
+        add_proto(*qw('void vpx_fdct16x16'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct16x16 neon sse2 msa lsx'))
+
+        add_proto(*qw('void vpx_fdct16x16_1'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct16x16_1 sse2 neon msa'))
+
+        add_proto(*qw('void vpx_fdct32x32'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct32x32 neon sse2 avx2 msa lsx'))
+
+        add_proto(*qw('void vpx_fdct32x32_rd'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct32x32_rd sse2 avx2 neon msa vsx lsx'))
+
+        add_proto(*qw('void vpx_fdct32x32_1'), "const int16_t *input, tran_low_t *output, int stride")
+        specialize(*qw('vpx_fdct32x32_1 sse2 neon msa'))
+        # CONFIG_VP9_HIGHBITDEPTH
+    # CONFIG_VP9_ENCODER
+
+#
+# Inverse transform
+if vpx_config("CONFIG_VP9") == "yes":
+
+    add_proto(*qw('void vpx_idct4x4_16_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct4x4_1_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct8x8_64_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct8x8_12_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct8x8_1_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct16x16_256_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct16x16_38_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct16x16_10_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct16x16_1_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct32x32_1024_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct32x32_135_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct32x32_34_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_idct32x32_1_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_iwht4x4_16_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+    add_proto(*qw('void vpx_iwht4x4_1_add'), "const tran_low_t *input, uint8_t *dest, int stride")
+
+    if vpx_config("CONFIG_EMULATE_HARDWARE") != "yes":
+        # Note that there are more specializations appended when
+        # CONFIG_VP9_HIGHBITDEPTH is off.
+        specialize(*qw('vpx_idct4x4_16_add neon sse2 vsx'))
+        specialize(*qw('vpx_idct4x4_1_add neon sse2'))
+        specialize(*qw('vpx_idct8x8_64_add neon sse2 vsx'))
+        specialize(*qw('vpx_idct8x8_12_add neon sse2 ssse3'))
+        specialize(*qw('vpx_idct8x8_1_add neon sse2'))
+        specialize(*qw('vpx_idct16x16_256_add neon sse2 vsx'))
+        specialize(*qw('vpx_idct16x16_38_add neon sse2'))
+        specialize(*qw('vpx_idct16x16_10_add neon sse2'))
+        specialize(*qw('vpx_idct16x16_1_add neon sse2'))
+        specialize(*qw('vpx_idct32x32_1024_add neon sse2 vsx'))
+        specialize(*qw('vpx_idct32x32_135_add neon sse2 ssse3'))
+        specialize(*qw('vpx_idct32x32_34_add neon sse2 ssse3'))
+        specialize(*qw('vpx_idct32x32_1_add neon sse2'))
+        specialize(*qw('vpx_iwht4x4_16_add sse2 vsx'))
+
+        if vpx_config("CONFIG_VP9_HIGHBITDEPTH") != "yes":
+            # Note that these specializations are appended to the above ones.
+            specialize(*qw('vpx_idct4x4_16_add dspr2 msa'))
+            specialize(*qw('vpx_idct4x4_1_add dspr2 msa'))
+            specialize(*qw('vpx_idct8x8_64_add dspr2 msa'))
+            specialize(*qw('vpx_idct8x8_12_add dspr2 msa'))
+            specialize(*qw('vpx_idct8x8_1_add dspr2 msa'))
+            specialize(*qw('vpx_idct16x16_256_add dspr2 msa'))
+            specialize(*qw('vpx_idct16x16_38_add dspr2 msa'))
+            vpx_idct16x16_38_add_dspr2='vpx_idct16x16_256_add_dspr2'
+            vpx_idct16x16_38_add_msa='vpx_idct16x16_256_add_msa'
+            specialize(*qw('vpx_idct16x16_10_add dspr2 msa'))
+            specialize(*qw('vpx_idct16x16_1_add dspr2 msa'))
+            specialize(*qw('vpx_idct32x32_1024_add dspr2 msa lsx'))
+            specialize(*qw('vpx_idct32x32_135_add dspr2 msa'))
+            vpx_idct32x32_135_add_dspr2='vpx_idct32x32_1024_add_dspr2'
+            vpx_idct32x32_135_add_msa='vpx_idct32x32_1024_add_msa'
+            vpx_idct32x32_135_add_lsx='vpx_idct32x32_1024_add_lsx'
+            specialize(*qw('vpx_idct32x32_34_add dspr2 msa lsx'))
+            specialize(*qw('vpx_idct32x32_1_add dspr2 msa lsx'))
+            specialize(*qw('vpx_iwht4x4_16_add msa'))
+            specialize(*qw('vpx_iwht4x4_1_add msa'))
+            # !CONFIG_VP9_HIGHBITDEPTH
+        # !CONFIG_EMULATE_HARDWARE
+
+    if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+        # Note as optimized versions of these functions are added we need to add a check to ensure
+        # that when CONFIG_EMULATE_HARDWARE is on, it defaults to the C versions only.
+
+        add_proto(*qw('void vpx_highbd_idct4x4_16_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        add_proto(*qw('void vpx_highbd_idct4x4_1_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        specialize(*qw('vpx_highbd_idct4x4_1_add neon sse2'))
+
+        add_proto(*qw('void vpx_highbd_idct8x8_64_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        add_proto(*qw('void vpx_highbd_idct8x8_12_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        add_proto(*qw('void vpx_highbd_idct8x8_1_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        specialize(*qw('vpx_highbd_idct8x8_1_add neon sse2'))
+
+        add_proto(*qw('void vpx_highbd_idct16x16_256_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        add_proto(*qw('void vpx_highbd_idct16x16_38_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        add_proto(*qw('void vpx_highbd_idct16x16_10_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        add_proto(*qw('void vpx_highbd_idct16x16_1_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        specialize(*qw('vpx_highbd_idct16x16_1_add neon sse2'))
+
+        add_proto(*qw('void vpx_highbd_idct32x32_1024_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        add_proto(*qw('void vpx_highbd_idct32x32_135_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        add_proto(*qw('void vpx_highbd_idct32x32_34_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        add_proto(*qw('void vpx_highbd_idct32x32_1_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        specialize(*qw('vpx_highbd_idct32x32_1_add neon sse2'))
+
+        add_proto(*qw('void vpx_highbd_iwht4x4_16_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+        add_proto(*qw('void vpx_highbd_iwht4x4_1_add'), "const tran_low_t *input, uint16_t *dest, int stride, int bd")
+
+        if vpx_config("CONFIG_EMULATE_HARDWARE") != "yes":
+            specialize(*qw('vpx_highbd_idct4x4_16_add neon sse2 sse4_1'))
+            specialize(*qw('vpx_highbd_idct8x8_64_add neon sse2 sse4_1'))
+            specialize(*qw('vpx_highbd_idct8x8_12_add neon sse2 sse4_1'))
+            specialize(*qw('vpx_highbd_idct16x16_256_add neon sse2 sse4_1'))
+            specialize(*qw('vpx_highbd_idct16x16_38_add neon sse2 sse4_1'))
+            specialize(*qw('vpx_highbd_idct16x16_10_add neon sse2 sse4_1'))
+            specialize(*qw('vpx_highbd_idct32x32_1024_add neon sse2 sse4_1'))
+            specialize(*qw('vpx_highbd_idct32x32_135_add neon sse2 sse4_1'))
+            specialize(*qw('vpx_highbd_idct32x32_34_add neon sse2 sse4_1'))
+            # !CONFIG_EMULATE_HARDWARE
+        # CONFIG_VP9_HIGHBITDEPTH
+    # CONFIG_VP9
+
+#
+# Quantization
+#
+if vpx_config("CONFIG_VP9_ENCODER") == "yes":
+    add_proto(*qw('void vpx_quantize_b'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+    specialize(*qw('vpx_quantize_b neon sse2 ssse3 avx avx2 vsx lsx'))
+
+    add_proto(*qw('void vpx_quantize_b_32x32'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+    specialize(*qw('vpx_quantize_b_32x32 neon ssse3 avx avx2 vsx lsx'))
+
+    if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+        add_proto(*qw('void vpx_highbd_quantize_b'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+        specialize(*qw('vpx_highbd_quantize_b neon sse2 avx2'))
+
+        add_proto(*qw('void vpx_highbd_quantize_b_32x32'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+        specialize(*qw('vpx_highbd_quantize_b_32x32 neon sse2 avx2'))
+        # CONFIG_VP9_HIGHBITDEPTH
+    # CONFIG_VP9_ENCODER
+
+if vpx_config("CONFIG_ENCODERS") == "yes":
+    #
+    # Block subtraction
+    #
+    add_proto(*qw('void vpx_subtract_block'), "int rows, int cols, int16_t *diff_ptr, ptrdiff_t diff_stride, const uint8_t *src_ptr, ptrdiff_t src_stride, const uint8_t *pred_ptr, ptrdiff_t pred_stride")
+    specialize(*qw('vpx_subtract_block neon msa mmi sse2 avx2 vsx lsx'))
+
+    #
+    # Single block SAD
+    #
+    add_proto(*qw('unsigned int vpx_sad64x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad64x64 neon avx2 msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('unsigned int vpx_sad64x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad64x32 neon avx2 msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad32x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad32x64 neon avx2 msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad32x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad32x32 neon avx2 msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('unsigned int vpx_sad32x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad32x16 neon avx2 msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad16x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad16x32 neon msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad16x16 neon msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('unsigned int vpx_sad16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad16x8 neon msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad8x16 neon msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad8x8 neon msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('unsigned int vpx_sad8x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad8x4 neon msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad4x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad4x8 neon msa sse2 mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad4x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad4x4 neon msa sse2 mmi'))
+
+    #
+    # Avg
+    #
+    if vpx_config("CONFIG_VP9_ENCODER") == "yes":
+        add_proto(*qw('unsigned int vpx_avg_8x8'), "const uint8_t *, int p")
+        specialize(*qw('vpx_avg_8x8 sse2 neon msa'))
+
+        add_proto(*qw('unsigned int vpx_avg_4x4'), "const uint8_t *, int p")
+        specialize(*qw('vpx_avg_4x4 sse2 neon msa'))
+
+        add_proto(*qw('void vpx_minmax_8x8'), "const uint8_t *s, int p, const uint8_t *d, int dp, int *min, int *max")
+        specialize(*qw('vpx_minmax_8x8 sse2 neon msa'))
+
+        if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+            add_proto(*qw('void vpx_hadamard_8x8'), "const int16_t *src_diff, ptrdiff_t src_stride, tran_low_t *coeff")
+            specialize(*qw('vpx_hadamard_8x8 sse2 neon vsx lsx'), f"{ssse3_x86_64}")
+
+            add_proto(*qw('void vpx_hadamard_16x16'), "const int16_t *src_diff, ptrdiff_t src_stride, tran_low_t *coeff")
+            specialize(*qw('vpx_hadamard_16x16 avx2 sse2 neon vsx lsx'))
+
+            add_proto(*qw('void vpx_hadamard_32x32'), "const int16_t *src_diff, ptrdiff_t src_stride, tran_low_t *coeff")
+            specialize(*qw('vpx_hadamard_32x32 sse2 avx2 neon'))
+
+            add_proto(*qw('void vpx_highbd_hadamard_8x8'), "const int16_t *src_diff, ptrdiff_t src_stride, tran_low_t *coeff")
+            specialize(*qw('vpx_highbd_hadamard_8x8 avx2'))
+
+            add_proto(*qw('void vpx_highbd_hadamard_16x16'), "const int16_t *src_diff, ptrdiff_t src_stride, tran_low_t *coeff")
+            specialize(*qw('vpx_highbd_hadamard_16x16 avx2'))
+
+            add_proto(*qw('void vpx_highbd_hadamard_32x32'), "const int16_t *src_diff, ptrdiff_t src_stride, tran_low_t *coeff")
+            specialize(*qw('vpx_highbd_hadamard_32x32 avx2'))
+
+            add_proto(*qw('int vpx_satd'), "const tran_low_t *coeff, int length")
+            specialize(*qw('vpx_satd avx2 sse2 neon'))
+
+            add_proto(*qw('int vpx_highbd_satd'), "const tran_low_t *coeff, int length")
+            specialize(*qw('vpx_highbd_satd avx2'))
+        else:
+            add_proto(*qw('void vpx_hadamard_8x8'), "const int16_t *src_diff, ptrdiff_t src_stride, int16_t *coeff")
+            specialize(*qw('vpx_hadamard_8x8 sse2 neon msa vsx lsx'), f"{ssse3_x86_64}")
+
+            add_proto(*qw('void vpx_hadamard_16x16'), "const int16_t *src_diff, ptrdiff_t src_stride, int16_t *coeff")
+            specialize(*qw('vpx_hadamard_16x16 avx2 sse2 neon msa vsx lsx'))
+
+            add_proto(*qw('void vpx_hadamard_32x32'), "const int16_t *src_diff, ptrdiff_t src_stride, int16_t *coeff")
+            specialize(*qw('vpx_hadamard_32x32 sse2 avx2 neon'))
+
+            add_proto(*qw('int vpx_satd'), "const int16_t *coeff, int length")
+            specialize(*qw('vpx_satd avx2 sse2 neon msa'))
+
+
+        add_proto(*qw('void vpx_int_pro_row'), "int16_t hbuf[16], const uint8_t *ref, const int ref_stride, const int height")
+        specialize(*qw('vpx_int_pro_row sse2 neon msa'))
+
+        add_proto(*qw('int16_t vpx_int_pro_col'), "const uint8_t *ref, const int width")
+        specialize(*qw('vpx_int_pro_col sse2 neon msa'))
+
+        add_proto(*qw('int vpx_vector_var'), "const int16_t *ref, const int16_t *src, const int bwl")
+        specialize(*qw('vpx_vector_var neon sse2 msa'))
+        # CONFIG_VP9_ENCODER
+
+    add_proto(*qw('unsigned int vpx_sad64x64_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad64x64_avg neon avx2 msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('unsigned int vpx_sad64x32_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad64x32_avg neon avx2 msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad32x64_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad32x64_avg neon avx2 msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad32x32_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad32x32_avg neon avx2 msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('unsigned int vpx_sad32x16_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad32x16_avg neon avx2 msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad16x32_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad16x32_avg neon msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad16x16_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad16x16_avg neon msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad16x8_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad16x8_avg neon msa sse2 vsx mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad8x16_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad8x16_avg neon msa sse2 mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad8x8_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad8x8_avg neon msa sse2 mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad8x4_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad8x4_avg neon msa sse2 mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad4x8_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad4x8_avg neon msa sse2 mmi'))
+
+    add_proto(*qw('unsigned int vpx_sad4x4_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+    specialize(*qw('vpx_sad4x4_avg neon msa sse2 mmi'))
+
+    #
+    # Multi-block SAD, comparing a reference to N independent blocks
+    #
+    add_proto(*qw('void vpx_sad64x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad64x64x4d avx512 avx2 neon msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_sad64x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad64x32x4d neon msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_sad32x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad32x64x4d neon msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_sad32x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad32x32x4d avx2 neon msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_sad32x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad32x16x4d neon msa sse2 vsx mmi'))
+
+    add_proto(*qw('void vpx_sad16x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad16x32x4d neon msa sse2 vsx mmi'))
+
+    add_proto(*qw('void vpx_sad16x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad16x16x4d neon msa sse2 vsx mmi lsx'))
+
+    add_proto(*qw('void vpx_sad16x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad16x8x4d neon msa sse2 vsx mmi'))
+
+    add_proto(*qw('void vpx_sad8x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad8x16x4d neon msa sse2 mmi'))
+
+    add_proto(*qw('void vpx_sad8x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad8x8x4d neon msa sse2 mmi lsx'))
+
+    add_proto(*qw('void vpx_sad8x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad8x4x4d neon msa sse2 mmi'))
+
+    add_proto(*qw('void vpx_sad4x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad4x8x4d neon msa sse2 mmi'))
+
+    add_proto(*qw('void vpx_sad4x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad4x4x4d neon msa sse2 mmi'))
+
+    add_proto(*qw('uint64_t vpx_sum_squares_2d_i16'), "const int16_t *src, int stride, int size")
+    specialize(*qw('vpx_sum_squares_2d_i16 neon sse2 msa'))
+
+    #
+    # Structured Similarity (SSIM)
+    #
+    if vpx_config("CONFIG_INTERNAL_STATS") == "yes":
+        add_proto(*qw('void vpx_ssim_parms_8x8'), "const uint8_t *s, int sp, const uint8_t *r, int rp, uint32_t *sum_s, uint32_t *sum_r, uint32_t *sum_sq_s, uint32_t *sum_sq_r, uint32_t *sum_sxr")
+        specialize(*qw('vpx_ssim_parms_8x8'), f"{sse2_x86_64}")
+
+        add_proto(*qw('void vpx_ssim_parms_16x16'), "const uint8_t *s, int sp, const uint8_t *r, int rp, uint32_t *sum_s, uint32_t *sum_r, uint32_t *sum_sq_s, uint32_t *sum_sq_r, uint32_t *sum_sxr")
+        specialize(*qw('vpx_ssim_parms_16x16'), f"{sse2_x86_64}")
+
+    if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+        #
+        # Block subtraction
+        #
+        add_proto(*qw('void vpx_highbd_subtract_block'), "int rows, int cols, int16_t *diff_ptr, ptrdiff_t diff_stride, const uint8_t *src8_ptr, ptrdiff_t src_stride, const uint8_t *pred8_ptr, ptrdiff_t pred_stride, int bd")
+        specialize(*qw('vpx_highbd_subtract_block neon avx2'))
+
+        #
+        # Single block SAD
+        #
+        add_proto(*qw('unsigned int vpx_highbd_sad64x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad64x64 sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad64x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad64x32 sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad32x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad32x64 sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad32x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad32x32 sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad32x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad32x16 sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad16x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad16x32 sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad16x16 sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad16x8 sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad8x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad8x8 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad8x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad8x4 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad4x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad4x8 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad4x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad4x4 neon'))
+
+        #
+        # Avg
+        #
+        add_proto(*qw('unsigned int vpx_highbd_avg_8x8'), "const uint8_t *s8, int p")
+        specialize(*qw('vpx_highbd_avg_8x8 sse2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_avg_4x4'), "const uint8_t *s8, int p")
+        specialize(*qw('vpx_highbd_avg_4x4 sse2'))
+
+        add_proto(*qw('void vpx_highbd_minmax_8x8'), "const uint8_t *s8, int p, const uint8_t *d8, int dp, int *min, int *max")
+
+        add_proto(*qw('unsigned int vpx_highbd_sad64x64_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad64x64_avg sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad64x32_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad64x32_avg sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad32x64_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad32x64_avg sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad32x32_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad32x32_avg sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad32x16_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad32x16_avg sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad16x32_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad16x32_avg sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad16x16_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad16x16_avg sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad16x8_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad16x8_avg sse2 neon avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad8x16_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad8x16_avg sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad8x8_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad8x8_avg sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad8x4_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad8x4_avg sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad4x8_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad4x8_avg neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad4x4_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_sad4x4_avg neon'))
+
+        #
+        # Multi-block SAD, comparing a reference to N independent blocks
+        #
+        add_proto(*qw('void vpx_highbd_sad64x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad64x64x4d sse2 neon avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad64x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad64x32x4d sse2 neon avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad32x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad32x64x4d sse2 neon avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad32x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad32x32x4d sse2 neon avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad32x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad32x16x4d sse2 neon avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad16x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad16x32x4d sse2 neon avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad16x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad16x16x4d sse2 neon avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad16x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad16x8x4d sse2 neon avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad8x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad8x16x4d sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_sad8x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad8x8x4d sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_sad8x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad8x4x4d sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_sad4x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad4x8x4d sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_sad4x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad4x4x4d sse2 neon'))
+
+        #
+        # Structured Similarity (SSIM)
+        #
+        if (vpx_config("CONFIG_INTERNAL_STATS") == "yes"):
+            add_proto(*qw('void vpx_highbd_ssim_parms_8x8'), "const uint16_t *s, int sp, const uint16_t *r, int rp, uint32_t *sum_s, uint32_t *sum_r, uint32_t *sum_sq_s, uint32_t *sum_sq_r, uint32_t *sum_sxr")
+
+        # CONFIG_VP9_HIGHBITDEPTH
+    # CONFIG_ENCODERS
+
+if vpx_config("CONFIG_ENCODERS") == "yes" or vpx_config("CONFIG_POSTPROC") == "yes" or vpx_config("CONFIG_VP9_POSTPROC") == "yes":
+
+    #
+    # Variance
+    #
+    add_proto(*qw('unsigned int vpx_variance64x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance64x64 sse2 avx2 neon msa mmi vsx lsx'))
+
+    add_proto(*qw('unsigned int vpx_variance64x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance64x32 sse2 avx2 neon msa mmi vsx'))
+
+    add_proto(*qw('unsigned int vpx_variance32x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance32x64 sse2 avx2 neon msa mmi vsx'))
+
+    add_proto(*qw('unsigned int vpx_variance32x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance32x32 sse2 avx2 neon msa mmi vsx lsx'))
+
+    add_proto(*qw('unsigned int vpx_variance32x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance32x16 sse2 avx2 neon msa mmi vsx'))
+
+    add_proto(*qw('unsigned int vpx_variance16x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance16x32 sse2 avx2 neon msa mmi vsx'))
+
+    add_proto(*qw('unsigned int vpx_variance16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance16x16 sse2 avx2 neon msa mmi vsx lsx'))
+
+    add_proto(*qw('unsigned int vpx_variance16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance16x8 sse2 avx2 neon msa mmi vsx'))
+
+    add_proto(*qw('unsigned int vpx_variance8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance8x16 sse2 neon msa mmi vsx'))
+
+    add_proto(*qw('unsigned int vpx_variance8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance8x8 sse2 neon msa mmi vsx lsx'))
+
+    add_proto(*qw('unsigned int vpx_variance8x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance8x4 sse2 neon msa mmi vsx'))
+
+    add_proto(*qw('unsigned int vpx_variance4x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance4x8 sse2 neon msa mmi vsx'))
+
+    add_proto(*qw('unsigned int vpx_variance4x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_variance4x4 sse2 neon msa mmi vsx'))
+
+    #
+    # Specialty Variance
+    #
+    add_proto(*qw('void vpx_get16x16var'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum")
+    specialize(*qw('vpx_get16x16var sse2 avx2 neon msa vsx lsx'))
+
+    add_proto(*qw('void vpx_get8x8var'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum")
+    specialize(*qw('vpx_get8x8var sse2 neon msa vsx'))
+
+    add_proto(*qw('unsigned int vpx_mse16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_mse16x16 sse2 avx2 neon msa mmi vsx lsx'))
+
+    add_proto(*qw('unsigned int vpx_mse16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_mse16x8 sse2 avx2 msa mmi vsx'))
+
+    add_proto(*qw('unsigned int vpx_mse8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_mse8x16 sse2 msa mmi vsx'))
+
+    add_proto(*qw('unsigned int vpx_mse8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+    specialize(*qw('vpx_mse8x8 sse2 msa mmi vsx'))
+
+    add_proto(*qw('unsigned int vpx_get_mb_ss'), "const int16_t *")
+    specialize(*qw('vpx_get_mb_ss sse2 msa vsx'))
+
+    add_proto(*qw('unsigned int vpx_get4x4sse_cs'), "const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_get4x4sse_cs neon msa vsx'))
+
+    add_proto(*qw('void vpx_comp_avg_pred'), "uint8_t *comp_pred, const uint8_t *pred, int width, int height, const uint8_t *ref, int ref_stride")
+    specialize(*qw('vpx_comp_avg_pred neon sse2 vsx lsx'))
+
+    #
+    # Subpixel Variance
+    #
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance64x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance64x64 avx2 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance64x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance64x32 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance32x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance32x64 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance32x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance32x32 avx2 neon msa mmi sse2 ssse3 lsx'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance32x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance32x16 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance16x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance16x32 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance16x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance16x16 neon msa mmi sse2 ssse3 lsx'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance16x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance16x8 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance8x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance8x16 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance8x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance8x8 neon msa mmi sse2 ssse3 lsx'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance8x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance8x4 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance4x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance4x8 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_variance4x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+    specialize(*qw('vpx_sub_pixel_variance4x4 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance64x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance64x64 neon avx2 msa mmi sse2 ssse3 lsx'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance64x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance64x32 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance32x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance32x64 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance32x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance32x32 neon avx2 msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance32x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance32x16 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance16x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance16x32 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance16x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance16x16 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance16x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance16x8 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance8x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance8x16 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance8x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance8x8 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance8x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance8x4 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance4x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance4x8 neon msa mmi sse2 ssse3'))
+
+    add_proto(*qw('uint32_t vpx_sub_pixel_avg_variance4x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+    specialize(*qw('vpx_sub_pixel_avg_variance4x4 neon msa mmi sse2 ssse3'))
+
+    if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
+        add_proto(*qw('unsigned int vpx_highbd_12_variance64x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance64x64 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_variance64x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance64x32 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_variance32x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance32x64 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_variance32x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance32x32 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_variance32x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance32x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_variance16x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance16x32 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_variance16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance16x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_variance16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance16x8 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_variance8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance8x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_variance8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance8x8 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_variance8x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance8x4 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_12_variance4x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance4x8 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_12_variance4x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_variance4x4 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_variance64x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance64x64 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_variance64x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance64x32 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_variance32x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance32x64 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_variance32x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance32x32 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_variance32x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance32x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_variance16x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance16x32 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_variance16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance16x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_variance16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance16x8 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_variance8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance8x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_variance8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance8x8 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_variance8x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance8x4 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_10_variance4x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance4x8 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_10_variance4x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_variance4x4 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_variance64x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance64x64 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_variance64x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance64x32 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_variance32x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance32x64 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_variance32x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance32x32 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_variance32x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance32x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_variance16x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance16x32 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_variance16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance16x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_variance16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance16x8 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_variance8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance8x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_variance8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance8x8 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_variance8x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance8x4 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_8_variance4x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance4x8 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_8_variance4x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_variance4x4 neon'))
+
+        add_proto(*qw('void vpx_highbd_8_get16x16var'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum")
+        specialize(*qw('vpx_highbd_8_get16x16var sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_8_get8x8var'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum")
+        specialize(*qw('vpx_highbd_8_get8x8var sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_10_get16x16var'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum")
+        specialize(*qw('vpx_highbd_10_get16x16var sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_10_get8x8var'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum")
+        specialize(*qw('vpx_highbd_10_get8x8var sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_12_get16x16var'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum")
+        specialize(*qw('vpx_highbd_12_get16x16var sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_12_get8x8var'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum")
+        specialize(*qw('vpx_highbd_12_get8x8var sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_mse16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_mse16x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_8_mse16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_mse16x8 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_8_mse8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_mse8x16 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_8_mse8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_8_mse8x8 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_mse16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_mse16x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_10_mse16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_mse16x8 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_10_mse8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_mse8x16 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_10_mse8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_10_mse8x8 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_mse16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_mse16x16 sse2 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_12_mse16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_mse16x8 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_12_mse8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_mse8x16 neon'))
+        add_proto(*qw('unsigned int vpx_highbd_12_mse8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
+        specialize(*qw('vpx_highbd_12_mse8x8 sse2 neon'))
+
+        add_proto(*qw('void vpx_highbd_comp_avg_pred'), "uint16_t *comp_pred, const uint16_t *pred, int width, int height, const uint16_t *ref, int ref_stride")
+        specialize(*qw('vpx_highbd_comp_avg_pred neon sse2'))
+
+        #
+        # Subpixel Variance
+        #
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance64x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance64x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance64x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance64x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance32x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance32x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance32x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance32x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance32x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance32x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance16x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance16x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance16x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance16x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance16x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance16x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance8x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance8x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance8x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance8x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance8x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance8x4 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance4x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance4x8 neon'))
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_variance4x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_12_sub_pixel_variance4x4 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance64x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance64x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance64x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance64x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance32x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance32x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance32x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance32x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance32x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance32x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance16x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance16x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance16x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance16x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance16x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance16x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance8x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance8x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance8x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance8x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance8x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance8x4 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance4x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance4x8 neon'))
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_variance4x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_10_sub_pixel_variance4x4 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance64x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance64x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance64x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance64x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance32x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance32x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance32x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance32x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance32x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance32x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance16x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance16x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance16x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance16x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance16x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance16x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance8x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance8x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance8x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance8x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance8x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance8x4 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance4x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance4x8 neon'))
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_variance4x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse")
+        specialize(*qw('vpx_highbd_8_sub_pixel_variance4x4 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance64x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance64x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance64x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance64x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance32x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance32x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance32x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance32x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance32x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance32x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance16x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance16x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance16x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance16x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance16x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance16x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance8x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance8x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance8x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance8x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance8x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance8x4 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance4x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance4x8 neon'))
+        add_proto(*qw('uint32_t vpx_highbd_12_sub_pixel_avg_variance4x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_12_sub_pixel_avg_variance4x4 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance64x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance64x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance64x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance64x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance32x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance32x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance32x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance32x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance32x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance32x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance16x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance16x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance16x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance16x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance16x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance16x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance8x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance8x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance8x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance8x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance8x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance8x4 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance4x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance4x8 neon'))
+        add_proto(*qw('uint32_t vpx_highbd_10_sub_pixel_avg_variance4x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_10_sub_pixel_avg_variance4x4 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance64x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance64x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance64x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance64x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance32x64'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance32x64 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance32x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance32x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance32x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance32x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance16x32'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance16x32 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance16x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance16x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance16x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance16x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance8x16'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance8x16 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance8x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance8x8 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance8x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance8x4 sse2 neon'))
+
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance4x8'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance4x8 neon'))
+        add_proto(*qw('uint32_t vpx_highbd_8_sub_pixel_avg_variance4x4'), "const uint8_t *src_ptr, int src_stride, int x_offset, int y_offset, const uint8_t *ref_ptr, int ref_stride, uint32_t *sse, const uint8_t *second_pred")
+        specialize(*qw('vpx_highbd_8_sub_pixel_avg_variance4x4 neon'))
+
+        # CONFIG_VP9_HIGHBITDEPTH
+
+    #
+    # Post Processing
+    #
+    if vpx_config("CONFIG_POSTPROC") == "yes" or vpx_config("CONFIG_VP9_POSTPROC") == "yes":
+        add_proto(*qw('void vpx_plane_add_noise'), "uint8_t *start, const int8_t *noise, int blackclamp, int whiteclamp, int width, int height, int pitch")
+        specialize(*qw('vpx_plane_add_noise sse2 msa'))
+
+        add_proto(*qw('void vpx_mbpost_proc_down'), "unsigned char *dst, int pitch, int rows, int cols,int flimit")
+        specialize(*qw('vpx_mbpost_proc_down sse2 neon msa vsx'))
+
+        add_proto(*qw('void vpx_mbpost_proc_across_ip'), "unsigned char *src, int pitch, int rows, int cols,int flimit")
+        specialize(*qw('vpx_mbpost_proc_across_ip sse2 neon msa vsx'))
+
+        add_proto(*qw('void vpx_post_proc_down_and_across_mb_row'), "unsigned char *src, unsigned char *dst, int src_pitch, int dst_pitch, int cols, unsigned char *flimits, int size")
+        specialize(*qw('vpx_post_proc_down_and_across_mb_row sse2 neon msa vsx'))
+
+    # CONFIG_ENCODERS || CONFIG_POSTPROC || CONFIG_VP9_POSTPROC
diff --git a/vpx_scale/vpx_scale_rtcd.py b/vpx_scale/vpx_scale_rtcd.py
new file mode 100755
index 000000000..c881053a3
--- /dev/null
+++ b/vpx_scale/vpx_scale_rtcd.py
@@ -0,0 +1,45 @@
+# SPDX-FileCopyrightText: 2017 The WebM Authors
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@centricular.com>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typing import Any, Dict, List
+    opts: Dict[str, Any] = {}
+    def qw(s: str) -> List[str]: ...
+    def forward_decls(*args: str): ...
+    def add_proto(*args: str): ...
+    def specialize(*args: str): ...
+    def vpx_config(s: str) -> str: ...
+
+def vpx_scale_forward_decls():
+    print('''struct yv12_buffer_config;
+''')
+
+forward_decls(*qw('vpx_scale_forward_decls'))
+
+# Scaler functions
+if vpx_config("CONFIG_SPATIAL_RESAMPLING") == "yes":
+    add_proto(*qw('void vp8_horizontal_line_5_4_scale'), "const unsigned char *source, unsigned int source_width, unsigned char *dest, unsigned int dest_width")
+    add_proto(*qw('void vp8_vertical_band_5_4_scale'), "unsigned char *source, unsigned int src_pitch, unsigned char *dest, unsigned int dest_pitch, unsigned int dest_width")
+    add_proto(*qw('void vp8_horizontal_line_5_3_scale'), "const unsigned char *source, unsigned int source_width, unsigned char *dest, unsigned int dest_width")
+    add_proto(*qw('void vp8_vertical_band_5_3_scale'), "unsigned char *source, unsigned int src_pitch, unsigned char *dest, unsigned int dest_pitch, unsigned int dest_width")
+    add_proto(*qw('void vp8_horizontal_line_2_1_scale'), "const unsigned char *source, unsigned int source_width, unsigned char *dest, unsigned int dest_width")
+    add_proto(*qw('void vp8_vertical_band_2_1_scale'), "unsigned char *source, unsigned int src_pitch, unsigned char *dest, unsigned int dest_pitch, unsigned int dest_width")
+    add_proto(*qw('void vp8_vertical_band_2_1_scale_i'), "unsigned char *source, unsigned int src_pitch, unsigned char *dest, unsigned int dest_pitch, unsigned int dest_width")
+
+add_proto(*qw('void vp8_yv12_extend_frame_borders'), "struct yv12_buffer_config *ybf")
+
+add_proto(*qw('void vp8_yv12_copy_frame'), "const struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc")
+
+add_proto(*qw('void vpx_yv12_copy_y'), "const struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc")
+
+if vpx_config("CONFIG_VP9") == "yes":
+    add_proto(*qw('void vpx_yv12_copy_frame'), "const struct yv12_buffer_config *src_ybc, struct yv12_buffer_config *dst_ybc")
+
+    add_proto(*qw('void vpx_extend_frame_borders'), "struct yv12_buffer_config *ybf")
+    specialize(*qw('vpx_extend_frame_borders dspr2'))
+
+    add_proto(*qw('void vpx_extend_frame_inner_borders'), "struct yv12_buffer_config *ybf")
+    specialize(*qw('vpx_extend_frame_inner_borders dspr2'))
-- 
2.44.0.windows.1


From e8960d50b78adcb71534463a3ccf63aa5f4678cb Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Sat, 8 Jul 2023 14:52:05 +0000
Subject: [PATCH] Remove Perl as a dependency

Fixes #1

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/5>

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 251278731..872c5dfaf 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -27,7 +27,6 @@ stages:
       ninja-build
       build-essential
       yasm
-      perl
       git
 
 .container.debian@common.minimum:
@@ -107,7 +106,6 @@ with deps nasm:
       ninja-build
       build-essential
       yasm
-      perl
       git
 
 # UNCOMMENT when the following is fixed:
@@ -148,7 +146,6 @@ with deps nasm:
     key:
       files:
         - subprojects/nasm-win.wrap
-        - subprojects/perl-win.wrap
       prefix: $CI_JOB_NAME
   variables:
     # Make sure any failure in PowerShell scripts is fatal
@@ -164,7 +161,7 @@ with deps nasm:
     - pip3 install -U meson
   script:
     # HACK to sneak Nasm and Perl under Meson's nose.
-    - $env:PATH="$(pwd)\subprojects\nasm-2.16.01;$(pwd)\subprojects\strawberry-perl-5.32.1.1-32bit-portable\perl\bin;$env:PATH"
+    - $env:PATH="$(pwd)\subprojects\nasm-2.16.01;$env:PATH"
     # For some reason, options are separated by newline instead of space, so we
     # have to replace them first.
     # - $env:MESON_ARGS = $env:MESON_ARGS.replace("`n"," ")
@@ -285,7 +282,7 @@ iOS arm64 cross:
     TOOLCHAIN: "$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64"
     NASM: "/usr/bin/nasm"
   before_script:
-    - dnf install -y python3-pip binutils nasm gcc ninja-build perl-core
+    - dnf install -y python3-pip binutils nasm gcc ninja-build
     - pip3 install -U meson
   script:
     - |
diff --git a/meson.build b/meson.build
index 016528a03..9d7a8a9a2 100644
--- a/meson.build
+++ b/meson.build
@@ -50,14 +50,6 @@ foreach t : all_targets
 	features.set(t, true)
 endforeach
 
-# we don't use diff in Meson.
-perl_executables = ['perl']
-# Adding Meson overrides manually.
-if host_machine.system() == 'windows'
-	perl_executables += ['perl_windows_exe']
-endif
-perl_exe = find_program(perl_executables, required: true)
-
 doxygen = find_program('doxygen', required: false, disabler: true)
 
 if doxygen.found()
@@ -1548,7 +1540,7 @@ vpx_config_c = configure_file(
 
 # libs.mk
 
-rtcd_exe = find_program('build/make/rtcd.pl', required: true)
+rtcd_exe = find_program('build/make/rtcd.py', required: true)
 
 extra_libs += c.find_library('m', required: false)
 
diff --git a/subprojects/packagefiles/perl/meson.build b/subprojects/packagefiles/perl/meson.build
deleted file mode 100644
index 26d084fd4..000000000
--- a/subprojects/packagefiles/perl/meson.build
+++ /dev/null
@@ -1,8 +0,0 @@
-project('strawberryperl', 'c', license: ' Artistic-1.0-Perl OR GPL-1.0-or-later')
-
-perl_exe = find_program('perl',
-	dirs: [meson.current_source_dir() / 'perl' / 'bin'],
-	required: true
-)
-
-meson.override_find_program('perl_windows_exe', perl_exe)
diff --git a/subprojects/perl-win.wrap b/subprojects/perl-win.wrap
deleted file mode 100644
index f2074299b..000000000
--- a/subprojects/perl-win.wrap
+++ /dev/null
@@ -1,10 +0,0 @@
-[wrap-file]
-directory = strawberry-perl-5.32.1.1-32bit-portable
-source_url = https://strawberryperl.com/download/5.32.1.1/strawberry-perl-5.32.1.1-32bit-portable.zip
-source_filename = strawberry-perl-5.32.1.1-32bit-portable.zip
-source_hash = d9c5711d12573a0f6d977792caa58364b1d46217521ae5c25cf5cc378a7c23c0
-patch_directory = perl
-lead_directory_missing = true
-
-[provide]
-program_names = perl_windows_exe
diff --git a/vp8/meson.build b/vp8/meson.build
index 9b6b977d2..354af8375 100644
--- a/vp8/meson.build
+++ b/vp8/meson.build
@@ -532,7 +532,7 @@ if features.get('vp8_encoder', false)
 endif
 
 vp8_rtcd_defs = files(
-	'common/rtcd_defs.pl',
+	'common/rtcd_defs.py',
 )
 
 codec_rtcds += {
diff --git a/vp9/meson.build b/vp9/meson.build
index b27740684..a565300b7 100644
--- a/vp9/meson.build
+++ b/vp9/meson.build
@@ -574,7 +574,7 @@ if features.get('vp9_encoder', false)
 endif
 
 vp9_rtcd_defs = files(
-	'common/vp9_rtcd_defs.pl',
+	'common/vp9_rtcd_defs.py',
 )
 codec_rtcds += {
 	'vp9_rtcd': vp9_rtcd_defs[0]
diff --git a/vpx_dsp/meson.build b/vpx_dsp/meson.build
index 6369dde50..1556dd310 100644
--- a/vpx_dsp/meson.build
+++ b/vpx_dsp/meson.build
@@ -1196,7 +1196,7 @@ foreach comp_name, comp_sources : optional_sources
 endforeach
 
 vpx_dsp_rtcd_defs = files(
-	'vpx_dsp_rtcd_defs.pl',
+	'vpx_dsp_rtcd_defs.py',
 )
 
 codec_rtcds += {
diff --git a/vpx_scale/meson.build b/vpx_scale/meson.build
index c35d8830e..22a13650c 100644
--- a/vpx_scale/meson.build
+++ b/vpx_scale/meson.build
@@ -62,7 +62,7 @@ foreach comp_name, comp_sources : optional_sources
 endforeach
 
 vpx_scale_rtcd_defs = files(
-	'vpx_scale_rtcd.pl',
+	'vpx_scale_rtcd.py',
 )
 
 codec_rtcds += {
-- 
2.44.0.windows.1


From 689a1b361101452cf50ad325f47f29603ccef473 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Sat, 8 Jul 2023 19:39:55 +0000
Subject: [PATCH] meson: Add test for rtcd generation parity

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/5>

diff --git a/meson.build b/meson.build
index 9d7a8a9a2..2d64b1184 100644
--- a/meson.build
+++ b/meson.build
@@ -1638,7 +1638,7 @@ else
 	)
 endif
 
-rtcd_h_template = [rtcd_exe, '--arch=@0@'.format(tgt_isa), '--config=@INPUT0@'] + rtcd_options
+rtcd_h_template = ['--arch=@0@'.format(tgt_isa), '--config=@INPUT0@'] + rtcd_options
 
 doxy_template = find_program('meson/generate_doxy.py', required: true)
 
@@ -1660,17 +1660,45 @@ subdir('vpx_util')
 subdir('vp8')
 subdir('vp9')
 
+# Meson: allow validation of original rtcd headers
+perl_exe = find_program('perl', required: false)
+diff_exe = find_program('diff', required: false)
+original_rtcd_exe = find_program('build/make/rtcd.pl', required: perl_exe.found() and diff_exe.found())
+
 foreach symbol, input_file : codec_rtcds
 	rtcd_filename = '@0@.h'.format(symbol)
+
+	rtcd_py = files(input_file)
+
 	rtcd_h = configure_file(
-		command: rtcd_h_template + ['--sym=@0@'.format(symbol), '@INPUT1@'],
-		input: [config_mk, input_file],
+		command: [rtcd_exe] + rtcd_h_template + ['--sym=@0@'.format(symbol), '@INPUT1@'],
+		input: [config_mk] + rtcd_py,
 		output: rtcd_filename,
 		capture: true,
 	)
 
 	codec_srcs += rtcd_h
 	codec_arch_prereqs += rtcd_h
+
+	if perl_exe.found() and diff_exe.found()
+		original_rtcd_pl = files(
+			input_file.replace('.py', '.pl')
+		)
+
+		original_rtcd_h = configure_file(
+			command: [original_rtcd_exe] + rtcd_h_template + ['--sym=@0@'.format(symbol), '@INPUT1@'],
+			input: [config_mk] + original_rtcd_pl,
+			output: 'original@0@'.format(rtcd_filename),
+			capture: true,
+		)
+
+		test('@0@'.format(symbol),
+			diff_exe,
+			args: ['-u', rtcd_h, original_rtcd_h],
+			verbose: true,
+			suite: 'validate_rtcd'
+		)
+	endif
 endforeach
 
 gen_def_exe = find_program('meson/gen_def.py', required: true)
diff --git a/vp8/meson.build b/vp8/meson.build
index 354af8375..6f9ff5467 100644
--- a/vp8/meson.build
+++ b/vp8/meson.build
@@ -531,15 +531,13 @@ if features.get('vp8_encoder', false)
 	endforeach
 endif
 
-vp8_rtcd_defs = files(
-	'common/rtcd_defs.py',
-)
+vp8_rtcd_defs = meson.current_source_dir() / 'common/rtcd_defs.py'
 
 codec_rtcds += {
-	'vp8_rtcd': vp8_rtcd_defs[0]
+	'vp8_rtcd': vp8_rtcd_defs
 }
 
-codec_headers += vp8_rtcd_defs
+codec_headers += files(vp8_rtcd_defs)
 
 if features.get('vp8_encoder', false)
 	codec_exports += files(
diff --git a/vp9/meson.build b/vp9/meson.build
index a565300b7..398dd8d4c 100644
--- a/vp9/meson.build
+++ b/vp9/meson.build
@@ -573,14 +573,13 @@ if features.get('vp9_encoder', false)
 	endforeach
 endif
 
-vp9_rtcd_defs = files(
-	'common/vp9_rtcd_defs.py',
-)
+vp9_rtcd_defs = meson.current_source_dir() / 'common/vp9_rtcd_defs.py'
+
 codec_rtcds += {
-	'vp9_rtcd': vp9_rtcd_defs[0]
+	'vp9_rtcd': vp9_rtcd_defs
 }
 
-codec_headers += vp9_rtcd_defs
+codec_headers += files(vp9_rtcd_defs)
 
 if features.get('vp9_encoder', false)
 	codec_exports += files(
diff --git a/vpx_dsp/meson.build b/vpx_dsp/meson.build
index 1556dd310..92d90d7c2 100644
--- a/vpx_dsp/meson.build
+++ b/vpx_dsp/meson.build
@@ -1195,12 +1195,10 @@ foreach comp_name, comp_sources : optional_sources
 	endif
 endforeach
 
-vpx_dsp_rtcd_defs = files(
-	'vpx_dsp_rtcd_defs.py',
-)
+vpx_dsp_rtcd_defs = meson.current_source_dir() / 'vpx_dsp_rtcd_defs.py'
 
 codec_rtcds += {
-	'vpx_dsp_rtcd': vpx_dsp_rtcd_defs[0]
+	'vpx_dsp_rtcd': vpx_dsp_rtcd_defs
 }
 
-codec_headers += vpx_dsp_rtcd_defs
+codec_headers += files(vpx_dsp_rtcd_defs)
diff --git a/vpx_scale/meson.build b/vpx_scale/meson.build
index 22a13650c..1450d97d7 100644
--- a/vpx_scale/meson.build
+++ b/vpx_scale/meson.build
@@ -61,11 +61,9 @@ foreach comp_name, comp_sources : optional_sources
 	endif
 endforeach
 
-vpx_scale_rtcd_defs = files(
-	'vpx_scale_rtcd.py',
-)
+vpx_scale_rtcd_defs = meson.current_source_dir() / 'vpx_scale_rtcd.py'
 
 codec_rtcds += {
-	'vpx_scale_rtcd': vpx_scale_rtcd_defs[0]
+	'vpx_scale_rtcd': vpx_scale_rtcd_defs
 }
-codec_headers += vpx_scale_rtcd_defs
+codec_headers += files(vpx_scale_rtcd_defs)
-- 
2.44.0.windows.1


From dd7d5fa6f34df3c78542da4eeef1cfd830ad3e6a Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Tue, 18 Jul 2023 10:57:25 -0300
Subject: [PATCH] Backport NASM to GStreamer's manual execution and install

Closes !3

diff --git a/meson.build b/meson.build
index 2d64b1184..4f9cde607 100644
--- a/meson.build
+++ b/meson.build
@@ -925,9 +925,9 @@ elif tgt_isa.startswith('x86')
 		endif
 	endif
 
-	x86_bits = 32
+	bits = 32
 	if target_machine.cpu_family() == 'x86_64'
-		x86_bits = 64
+		bits = 64
 	endif
 
 	feature = 'runtime_cpu_detect'
@@ -1005,27 +1005,18 @@ elif tgt_isa.startswith('x86')
 	endforeach
 
 	nasm_exe = find_program('nasm', required: false)
-	if meson.version().version_compare('> 1.1.0')
-		yasm_exe = find_program('yasm', required: false)
-	else
-		# Removing Yasm support because Meson adds optimization flags
-		# which it doesn't support.
-		# https://github.com/mesonbuild/meson/issues/11726
-		yasm_exe = disabler()
-	endif
-	# Adding Meson overrides manually.
+	yasm_exe = find_program('yasm', required: false)
+	as_exe = disabler()
 	if not nasm_exe.found() and not yasm_exe.found()
-		if host_machine.system() == 'windows'
-			nasm_exe = find_program('nasm_windows_exe')
-		elif host_machine.system() == 'darwin'
-			nasm_exe = find_program('nasm_macos_exe')
-		endif
+		subproject('nasm')
+		nasm_exe = find_program('nasm', required: false)
 	endif
 	if nasm_exe.found()
 		# Apple ships version 0.98 of nasm through at least Xcode 6. Revisit
 		# this check if they start shipping a compatible version.
 		out = run_command(nasm_exe, '-v', capture: true, check: true).stdout().strip()
 		as = 'nasm'
+		as_exe = nasm_exe
 		if out.contains('Apple')
 			warning('Unsupported version of nasm: @0@'.format(out))
 			as = 'auto'
@@ -1041,18 +1032,40 @@ elif tgt_isa.startswith('x86')
 		endif
 	elif yasm_exe.found()
 		as = 'yasm'
+		as_exe = yasm_exe
 	endif
 
 	if as == 'auto'
 		error('Neither yasm nor nasm have been found. See the prerequisites section in the README for more info.')
-	else
-		add_languages('nasm', required: true)
 	endif
 
 	as_sfx = '.asm'
 
-	# Nasm flags are Meson handled.
-	if tgt_os == 'iphonesimulator'
+	if tgt_os == 'windows'
+		asm_args += ['-f', 'win@0@'.format(bits)]
+		if get_option('debug')
+			if as == 'yasm'
+				asm_args += ['-g', 'cv8']
+			elif as == 'nasm'
+				asm_args += ['-g']
+			endif
+		endif
+	elif ['linux', 'solaris', 'android'].contains(tgt_os)
+		asm_args += ['-f', 'elf@0@'.format(bits)]
+		if get_option('debug')
+			if as == 'yasm'
+				asm_args += ['-g', 'dwarf2']
+			elif as == 'nasm'
+				asm_args += ['-g']
+			endif
+		endif
+	elif tgt_os == 'darwin'
+		asm_args += ['-f', 'macho@0@'.format(bits)]
+		if get_option('debug')
+			asm_args += ['-g']
+		endif
+	elif tgt_os == 'iphonesimulator'
+		asm_args += ['-f', 'macho@0@'.format(bits)]
 		sdk_version = run_command(xcrun_exe, '--sdk', tgt_os, '--show-sdk-version', check: true, capture: true)
 		if sdk_version.version_compare('> 8.0')
 			# yasm v1.3.0 doesn't know what -fembed-bitcode means, so turning it
@@ -1619,6 +1632,11 @@ if features.get('x86', false) or features.get('x86_64', false)
 		input: vpx_config_h,
 		output: 'vpx_config.asm',
 	)
+	asm_compiler = generator(
+		as_exe,
+		arguments: asm_args + ['-i', '@SOURCE_DIR@', '-o', '@OUTPUT@', '@INPUT@'],
+		output: '@PLAINNAME@.o'
+	)
 elif asm_conversion_exe.found()
 	ads_config_asm = configure_file(
 		command: [config_asm_generator, '@INPUT@', '@OUTPUT@'],
@@ -1630,12 +1648,14 @@ elif asm_conversion_exe.found()
 		input: ads_config_asm,
 		output: 'vpx_config.asm',
 	)
+	asm_compiler = disabler()
 else
 	config_asm = configure_file(
 		command: [config_asm_generator, '@INPUT@', '@OUTPUT@'],
 		input: vpx_config_h,
 		output: 'vpx_config.asm',
 	)
+	asm_compiler = disabler()
 endif
 
 rtcd_h_template = ['--arch=@0@'.format(tgt_isa), '--config=@INPUT0@'] + rtcd_options
diff --git a/subprojects/.gitignore b/subprojects/.gitignore
index e14daf2a4..5ab8b15d3 100644
--- a/subprojects/.gitignore
+++ b/subprojects/.gitignore
@@ -1,3 +1 @@
-strawberry-perl*
-nasm-*
 packagecache
diff --git a/subprojects/nasm-mac.wrap b/subprojects/nasm-mac.wrap
deleted file mode 100644
index 396961ffe..000000000
--- a/subprojects/nasm-mac.wrap
+++ /dev/null
@@ -1,9 +0,0 @@
-[wrap-file]
-directory = nasm-2.16.01
-source_url = https://www.nasm.us/pub/nasm/releasebuilds/2.16.01/macosx/nasm-2.16.01-macosx.zip
-source_filename = nasm-2.16.01-macosx.zip
-source_hash = d53c9a1bc9cd92d22e37924d31e9c68413fa03104fd165a6e7b7faf8800a1822
-patch_directory = nasm
-
-[provide]
-program_names = nasm_macos_exe
diff --git a/subprojects/nasm-win.wrap b/subprojects/nasm-win.wrap
deleted file mode 100644
index b103ddc9a..000000000
--- a/subprojects/nasm-win.wrap
+++ /dev/null
@@ -1,9 +0,0 @@
-[wrap-file]
-directory = nasm-2.16.01
-source_url = https://www.nasm.us/pub/nasm/releasebuilds/2.16.01/win32/nasm-2.16.01-win32.zip
-source_filename = nasm-2.16.01-win32.zip
-source_hash = e289fa70c88594b092c916344bb8bfcd6896b604bfab284ab57b1372997c820c
-patch_directory = nasm
-
-[provide]
-program_names = nasm_windows_exe
diff --git a/subprojects/nasm/.gitignore b/subprojects/nasm/.gitignore
new file mode 100644
index 000000000..12f237237
--- /dev/null
+++ b/subprojects/nasm/.gitignore
@@ -0,0 +1,2 @@
+nasm-*/
+nasm-*.zip
diff --git a/subprojects/nasm/download-binary.py b/subprojects/nasm/download-binary.py
new file mode 100755
index 000000000..047ae7bd4
--- /dev/null
+++ b/subprojects/nasm/download-binary.py
@@ -0,0 +1,76 @@
+#!/usr/bin/env python3
+# SPDX-FileCopyrightText: 2020 Nirbheek Chauhan <nirbheek@centricular.com>
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@centricular.com>
+# SPDX-License-Ref: LGPL-2.1-or-later
+
+import os
+import sys
+import ssl
+import zipfile
+import hashlib
+import urllib.request
+import urllib.error
+
+# Disable certificate checking because it always fails on Windows
+# We verify the checksum anyway.
+ctx = ssl.create_default_context()
+ctx.check_hostname = False
+ctx.verify_mode = ssl.CERT_NONE
+
+BASENAME = 'nasm-{}-{}.zip'
+UPSTREAM_URL = 'https://www.nasm.us/pub/nasm/releasebuilds/{}/{}/{}'
+GSTREAMER_URL = 'https://gstreamer.freedesktop.org/src/mirror/{}'
+
+version = sys.argv[1]
+if sys.argv[2] == 'darwin':
+    arch = 'macosx'
+elif sys.argv[2] == 'x86_64':
+    arch = 'win64'
+else:
+    arch = 'win32'
+zip_sha256 = sys.argv[3]
+source_dir = os.path.join(os.environ['MESON_SOURCE_ROOT'], os.environ['MESON_SUBDIR'])
+dest = BASENAME.format(version, arch)
+dest_path = os.path.join(source_dir, dest)
+
+def get_sha256(zipf):
+    hasher = hashlib.sha256()
+    with open(zipf, 'rb') as f:
+        hasher.update(f.read())
+    return hasher.hexdigest()
+
+if os.path.isfile(dest_path):
+    found_sha256 = get_sha256(dest_path)
+    if found_sha256 == zip_sha256:
+        print('{} already downloaded'.format(dest))
+    else:
+        os.remove(dest)
+        print('{} checksum mismatch, redownloading'.format(dest), file=sys.stderr)
+
+if not os.path.isfile(dest_path):
+    for url in (GSTREAMER_URL.format(dest), UPSTREAM_URL.format(version, arch, dest)):
+        print('Downloading {} to {}'.format(url, dest))
+        try:
+            with open(dest_path, 'wb') as d:
+                f = urllib.request.urlopen(url, context=ctx)
+                d.write(f.read())
+            break
+        except BaseException as ex:
+            print(ex, file=sys.stderr)
+            print('Failed to download from {!r}, trying mirror...'.format(url), file=sys.stderr)
+            continue
+    else:
+        curdir = os.path.dirname(sys.argv[0])
+        print('Couldn\'t download {!r}! Try downloading it manually and '
+            'placing it into {!r}'.format(dest, curdir), file=sys.stderr)
+        sys.exit(1)
+
+found_sha256 = get_sha256(dest_path)
+if found_sha256 != zip_sha256:
+    print('SHA256 of downloaded file {} was {} instead of {}'
+          ''.format(dest, found_sha256, zip_sha256), file=sys.stderr)
+    sys.exit(1)
+
+print('Extracting {}'.format(dest))
+zf = zipfile.ZipFile(dest_path, "r")
+zf.extractall(path=source_dir)
diff --git a/subprojects/nasm/meson.build b/subprojects/nasm/meson.build
new file mode 100644
index 000000000..ef796103d
--- /dev/null
+++ b/subprojects/nasm/meson.build
@@ -0,0 +1,41 @@
+project('nasm', version : '2.16.01')
+
+download_binary = find_program(meson.current_source_dir() / 'download-binary.py')
+
+arch = host_machine.system()
+
+if not ['windows', 'darwin'].contains(arch)
+  warning('Can only download nasm for Windows or macOS, sorry')
+  subdir_done()
+endif
+
+message('Downloading and extracting nasm binaries for @0@...'.format(arch))
+
+if arch == 'windows'
+  arch = host_machine.cpu_family()
+  if arch == 'x86_64'
+    zip_hash = '029eed31faf0d2c5f95783294432cbea6c15bf633430f254bb3c1f195c67ca3a'
+  else
+    zip_hash = 'e289fa70c88594b092c916344bb8bfcd6896b604bfab284ab57b1372997c820c'
+  endif
+else
+  # macOS binaries are only identified as architecture "macosx"
+  zip_hash = 'd53c9a1bc9cd92d22e37924d31e9c68413fa03104fd165a6e7b7faf8800a1822'
+endif
+
+download = run_command(download_binary, meson.project_version(), arch, zip_hash)
+
+if download.returncode() != 0
+  warning('Download failed: @0@'.format(download.stderr().strip()))
+  subdir_done()
+endif
+
+nasm_path = meson.current_source_dir() / 'nasm-@0@'.format(meson.project_version())
+
+if host_machine.system() != 'windows'
+  # Fix ZIP permissions -- zipfile doesn't support this extended format
+  patch_nasm = find_program('patch_nasm.py', required: true)
+  run_command(patch_nasm, nasm_path, check: true)
+endif
+
+meson.override_find_program('nasm', find_program(nasm_path / 'nasm'))
diff --git a/subprojects/nasm/patch_nasm.py b/subprojects/nasm/patch_nasm.py
new file mode 100755
index 000000000..366892146
--- /dev/null
+++ b/subprojects/nasm/patch_nasm.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python3
+
+# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
+# SPDX-License-Identifier: BSD-3-Clause
+
+from pathlib import Path
+import os
+import stat
+from argparse import ArgumentParser
+
+if __name__ == '__main__':
+    parser = ArgumentParser(description='Make Nasm executable')
+    parser.add_argument('dir', type=Path, help='Source directory')
+    args = parser.parse_args()
+    os.chmod(args.dir / "nasm", stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH | stat.S_IWUSR)
diff --git a/subprojects/packagefiles/nasm/meson.build b/subprojects/packagefiles/nasm/meson.build
deleted file mode 100644
index 5e3d92fc6..000000000
--- a/subprojects/packagefiles/nasm/meson.build
+++ /dev/null
@@ -1,13 +0,0 @@
-project('nasm', 'c', license: 'BSD-2-Clause')
-
-if host_machine.system() == 'windows'
-	nasm_exe = find_program('nasm', required: true)
-	meson.override_find_program('nasm_windows_exe', nasm_exe)
-elif host_machine.system() == 'darwin'
-	python_exe = find_program('patch_nasm.py')
-	run_command(python_exe, meson.current_source_dir(), check: true)
-	nasm_exe = find_program('nasm', required: true)
-	meson.override_find_program('nasm_macos_exe', nasm_exe)
-else
-	error('This wrap only supports Windows or macOS')
-endif
diff --git a/subprojects/packagefiles/nasm/patch_nasm.py b/subprojects/packagefiles/nasm/patch_nasm.py
deleted file mode 100644
index d41e9cb65..000000000
--- a/subprojects/packagefiles/nasm/patch_nasm.py
+++ /dev/null
@@ -1,15 +0,0 @@
-#!/usr/bin/env python3
-
-# SPDX-FileCopyrightText: 2023 L. E. Segovia <amy@amyspark.me>
-# SPDX-License-Identifier: BSD-3-Clause
-
-from pathlib import Path
-import os
-import stat
-from argparse import ArgumentParser
-
-if __name__ == '__main__':
-	parser = ArgumentParser(description='Make Nasm executable')
-	parser.add_argument('dir', type=Path, help='Source directory')
-	args = parser.parse_args()
-	os.chmod(args.dir / "nasm", stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH | stat.S_IWUSR)
diff --git a/vp8/meson.build b/vp8/meson.build
index 6f9ff5467..647460ae4 100644
--- a/vp8/meson.build
+++ b/vp8/meson.build
@@ -409,13 +409,19 @@ foreach comp_name, comp_sources : optional_sources
 	if not features.get(comp_name, false)
 		continue
 	elif ARCH_EXT_LIST.contains(comp_name)
-		transformed_sources = comp_sources
-		if asm_conversion_exe.found()
-			transformed_sources = asm_transformer.process(comp_sources)
+		if comp_sources.length() > 0
+			transformed_sources = comp_sources
+			if asm_conversion_exe.found()
+				transformed_sources = asm_transformer.process(comp_sources)
+			elif features.get('x86', false) or features.get('x86_64', false)
+				transformed_sources = asm_compiler.process(comp_sources,
+					preserve_path_from: meson.project_source_root()
+				)
+			endif
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+			}
 		endif
-		codec_arch_srcs += {
-			comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
-		}
 	else
 		codec_srcs += comp_sources
 	endif
@@ -458,8 +464,14 @@ if features.get('vp8_encoder', false)
 			continue
 		elif ARCH_EXT_LIST.contains(comp_name)
 			transformed_sources = comp_sources
-			if asm_conversion_exe.found()
-				transformed_sources = asm_transformer.process(comp_sources)
+			if comp_sources.length() > 0
+				if asm_conversion_exe.found()
+					transformed_sources = asm_transformer.process(comp_sources)
+				elif features.get('x86', false) or features.get('x86_64', false)
+					transformed_sources = asm_compiler.process(comp_sources,
+						preserve_path_from: meson.project_source_root()
+					)
+				endif
 			endif
 			codec_arch_srcs += {
 				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
@@ -506,8 +518,14 @@ if features.get('vp8_encoder', false)
 			continue
 		elif ARCH_EXT_LIST.contains(comp_name)
 			transformed_sources = comp_sources
-			if asm_conversion_exe.found()
-				transformed_sources = asm_transformer.process(comp_sources)
+			if comp_sources.length() > 0
+				if asm_conversion_exe.found()
+					transformed_sources = asm_transformer.process(comp_sources)
+				elif features.get('x86', false) or features.get('x86_64', false)
+					transformed_sources = asm_compiler.process(comp_sources,
+						preserve_path_from: meson.project_source_root()
+					)
+				endif
 			endif
 			codec_arch_srcs += {
 				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
diff --git a/vp9/meson.build b/vp9/meson.build
index 398dd8d4c..709a236e6 100644
--- a/vp9/meson.build
+++ b/vp9/meson.build
@@ -451,13 +451,19 @@ foreach comp_name, comp_sources : optional_sources
 	if not features.get(comp_name, false)
 		continue
 	elif ARCH_EXT_LIST.contains(comp_name)
-		transformed_sources = comp_sources
-		if asm_conversion_exe.found()
-			transformed_sources = asm_transformer.process(comp_sources)
+		if comp_sources.length() > 0
+			transformed_sources = comp_sources
+			if asm_conversion_exe.found()
+				transformed_sources = asm_transformer.process(comp_sources)
+			elif features.get('x86', false) or features.get('x86_64', false)
+				transformed_sources = asm_compiler.process(comp_sources,
+					preserve_path_from: meson.project_source_root()
+				)
+			endif
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+			}
 		endif
-		codec_arch_srcs += {
-			comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
-		}
 	else
 		codec_srcs += comp_sources
 	endif
@@ -500,8 +506,14 @@ if features.get('vp9_encoder', false)
 			continue
 		elif ARCH_EXT_LIST.contains(comp_name)
 			transformed_sources = comp_sources
-			if asm_conversion_exe.found()
-				transformed_sources = asm_transformer.process(comp_sources)
+			if comp_sources.length() > 0
+				if asm_conversion_exe.found()
+					transformed_sources = asm_transformer.process(comp_sources)
+				elif features.get('x86', false) or features.get('x86_64', false)
+					transformed_sources = asm_compiler.process(comp_sources,
+						preserve_path_from: meson.project_source_root()
+					)
+				endif
 			endif
 			codec_arch_srcs += {
 				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
@@ -548,8 +560,14 @@ if features.get('vp9_encoder', false)
 			continue
 		elif ARCH_EXT_LIST.contains(comp_name)
 			transformed_sources = comp_sources
-			if asm_conversion_exe.found()
-				transformed_sources = asm_transformer.process(comp_sources)
+			if comp_sources.length() > 0
+				if asm_conversion_exe.found()
+					transformed_sources = asm_transformer.process(comp_sources)
+				elif features.get('x86', false) or features.get('x86_64', false)
+					transformed_sources = asm_compiler.process(comp_sources,
+						preserve_path_from: meson.project_source_root()
+					)
+				endif
 			endif
 			codec_arch_srcs += {
 				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
diff --git a/vpx_dsp/meson.build b/vpx_dsp/meson.build
index 92d90d7c2..182b14c11 100644
--- a/vpx_dsp/meson.build
+++ b/vpx_dsp/meson.build
@@ -1169,13 +1169,19 @@ foreach comp_name, comp_sources : optional_sources
 	if not features.get(comp_name, false)
 		continue
 	elif ARCH_EXT_LIST.contains(comp_name)
-		transformed_sources = comp_sources
-		if asm_conversion_exe.found()
-			transformed_sources = asm_transformer.process(comp_sources)
+		if comp_sources.length() > 0
+			transformed_sources = comp_sources
+			if asm_conversion_exe.found()
+				transformed_sources = asm_transformer.process(comp_sources)
+			elif features.get('x86', false) or features.get('x86_64', false)
+				transformed_sources = asm_compiler.process(comp_sources,
+					preserve_path_from: meson.project_source_root()
+				)
+			endif
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+			}
 		endif
-		codec_arch_srcs += {
-			comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
-		}
 	else
 		codec_srcs += comp_sources
 	endif
diff --git a/vpx_ports/meson.build b/vpx_ports/meson.build
index febfda80c..961ed54bd 100644
--- a/vpx_ports/meson.build
+++ b/vpx_ports/meson.build
@@ -90,7 +90,7 @@ if features.get('x86_64', false) # MANUAL
 	}
 
 	ports_asm_optional_sources += {
-		'msvs' : ports_asm_optional_sources['msvs'] +files(
+		'msvs' : ports_asm_optional_sources['msvs'] + files(
 			'float_control_word.asm'
 		),
 	}
@@ -135,14 +135,20 @@ optional_sources = get_variable('ports_asm_optional_sources', {})
 foreach comp_name, comp_sources : optional_sources
 	if not features.get(comp_name, false)
 		continue
-	elif ARCH_EXT_LIST.contains(comp_name)
-		transformed_sources = comp_sources
-		if asm_conversion_exe.found()
-			transformed_sources = asm_transformer.process(comp_sources)
+	elif (ARCH_EXT_LIST + ['msvs']).contains(comp_name) # MANUAL
+		if comp_sources.length() > 0
+			transformed_sources = comp_sources
+			if asm_conversion_exe.found()
+				transformed_sources = asm_transformer.process(comp_sources)
+			elif features.get('x86', false) or features.get('x86_64', false)
+				transformed_sources = asm_compiler.process(comp_sources,
+					preserve_path_from: meson.project_source_root()
+				)
+			endif
+			codec_arch_srcs += {
+				comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
+			}
 		endif
-		codec_arch_srcs += {
-			comp_name: codec_arch_srcs.get(comp_name, []) + transformed_sources
-		}
 	else
 		codec_srcs += comp_sources
 	endif
-- 
2.44.0.windows.1


From 56d124f9b6a47b0dcc9c86cc8d5f5e8faa870e39 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Wed, 19 Jul 2023 10:44:26 -0300
Subject: [PATCH] meson: Work around Meson bug when using @SOURCE_DIR@ in a
 subproject

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/7>

diff --git a/meson.build b/meson.build
index 4f9cde607..5365af788 100644
--- a/meson.build
+++ b/meson.build
@@ -1632,9 +1632,15 @@ if features.get('x86', false) or features.get('x86_64', false)
 		input: vpx_config_h,
 		output: 'vpx_config.asm',
 	)
+	# https://github.com/mesonbuild/meson/issues/11994
+	# Note that add_language("nasm") would just work
 	asm_compiler = generator(
 		as_exe,
-		arguments: asm_args + ['-i', '@SOURCE_DIR@', '-o', '@OUTPUT@', '@INPUT@'],
+		arguments: asm_args + [
+			'-i', meson.project_source_root(),
+			'-i', meson.project_build_root(),
+			'-o', '@OUTPUT@', '@INPUT@'
+		],
 		output: '@PLAINNAME@.o'
 	)
 elif asm_conversion_exe.found()
-- 
2.44.0.windows.1


From b61cfc48a81547e3f9e6b0aabf20c49b8ba8b8b2 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Fri, 21 Jul 2023 16:34:50 -0300
Subject: [PATCH] meson: Fix several typos discovered when testing for Cerbero
 integration

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/8>

diff --git a/meson.build b/meson.build
index 5365af788..111c44cee 100644
--- a/meson.build
+++ b/meson.build
@@ -386,7 +386,7 @@ foreach flag: CMDLINE_SELECT
 		elif w >= 65536 or h >= 65536
 			error('Invalid size-limit: too big.')
 		else
-			var_list += ['DECODE_WIDTH_LIMIT', 'DECODE_HEIGHT_LIMIT']
+			VAR_LIST += ['DECODE_WIDTH_LIMIT', 'DECODE_HEIGHT_LIMIT']
 			features.set('DECODE_WIDTH_LIMIT', w)
 			features.set('DECODE_HEIGHT_LIMIT', h)
 			features.set('size_limit', true)
@@ -1460,7 +1460,7 @@ foreach feature : CONFIG_LIST
 endforeach
 
 foreach var : VAR_LIST
-	cfgdata.set10(var.to_upper(), features.get(var, false))
+	cfgdata.set(var.to_upper(), features.get(var, ''))
 endforeach
 
 version_str = 'v@0@'.format(meson.project_version())
diff --git a/vp9/meson.build b/vp9/meson.build
index 709a236e6..7b7619575 100644
--- a/vp9/meson.build
+++ b/vp9/meson.build
@@ -340,7 +340,7 @@ vp9_common_asm_optional_sources = {
 }
 
 if features.get('vp9_postproc', false) # MANUAL
-	vp9_common_optional_sources += {
+	vp9_common_asm_optional_sources += {
 		'sse2': vp9_common_asm_optional_sources['sse2'] + files(
 			'common/x86/vp9_mfqe_sse2.asm'
 		)
@@ -420,7 +420,7 @@ if not features.get('realtime_only', false)
 		),
 	}
 
-	if not features.get('vp9_highbitdepth', true)
+	if features.get('vp9_highbitdepth', false)
 		vp9_cx_optional_sources += {
 			'sse4_1' : vp9_cx_optional_sources['sse4_1'] + files(
 				'encoder/x86/highbd_temporal_filter_sse4.c',
diff --git a/vpx_dsp/meson.build b/vpx_dsp/meson.build
index 182b14c11..04ec4b5d7 100644
--- a/vpx_dsp/meson.build
+++ b/vpx_dsp/meson.build
@@ -442,7 +442,7 @@ if features.get('vp9_highbitdepth', false) # MANUAL
 endif
 
 # intra predictions
-if not features.get('postproc', false) or not features.get('vp9_postproc', false) # MANUAL
+if features.get('postproc', false) or features.get('vp9_postproc', false) # MANUAL
 	dsp_sources += files(
 		'add_noise.c',
 		'deblock.c',
@@ -870,7 +870,7 @@ if features.get('vp9', true) # MANUAL
 				'x86/highbd_idct16x16_add_sse2.c',
 				'x86/highbd_idct32x32_add_sse2.c',
 			),
-			'lsx' : dsp_optional_sources['lsx'] + files(
+			'sse4_1' : dsp_optional_sources['sse4_1'] + files(
 				'x86/highbd_idct4x4_add_sse4.c',
 				'x86/highbd_idct8x8_add_sse4.c',
 				'x86/highbd_idct16x16_add_sse4.c',
@@ -974,7 +974,7 @@ if features.get('vp9_encoder', false) # MANUAL
 			'sse2' : dsp_optional_sources['sse2'] + files(
 				'x86/highbd_quantize_intrin_sse2.c',
 			),
-			'avx2' : dsp_optional_sources['avx'] + files(
+			'avx2' : dsp_optional_sources['avx2'] + files(
 				'x86/highbd_quantize_intrin_avx2.c',
 			),
 			'neon' : dsp_optional_sources['neon'] + files(
@@ -1066,7 +1066,7 @@ if features.get('encoders', false) # MANUAL
 endif
 
 
-if not features.get('encoders', false) or not features.get('postproc', false) or not features.get('vp9_postproc', false) # MANUAL
+if features.get('encoders', false) or features.get('postproc', false) or features.get('vp9_postproc', false) # MANUAL
 	dsp_sources += files(
 		'variance.c',
 	)
@@ -1193,8 +1193,8 @@ foreach comp_name, comp_sources : optional_sources
 	if not features.get(comp_name, false)
 		continue
 	elif ARCH_EXT_LIST.contains(comp_name)
-		codec_arch_srcs += {
-			comp_name: codec_arch_srcs.get(comp_name, []) + comp_sources
+		codec_arch_headers += {
+			comp_name: codec_arch_headers.get(comp_name, []) + comp_sources
 		}
 	else
 		codec_headers += comp_sources
-- 
2.44.0.windows.1


From dd3c30ef972094ff82b78963e1ead6016fc6f87d Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Fri, 21 Jul 2023 17:13:19 -0300
Subject: [PATCH] meson: Work around Cerbero's GCC being too old to build
 AVX512 safely

See:

https://stackoverflow.com/questions/43152633/invalid-register-for-seh-savexmm-in-cygwin

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/8>

diff --git a/meson.build b/meson.build
index 111c44cee..a237c3edf 100644
--- a/meson.build
+++ b/meson.build
@@ -1603,6 +1603,14 @@ else
 		'lsx': ['-mlsx'],
 		'lasx': ['-mlasx'],
 	}
+
+	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65782
+	# https://stackoverflow.com/questions/43152633/invalid-register-for-seh-savexmm-in-cygwin
+	if c.get_id() == 'gcc' and c.version().version_compare('<= 10.1.0')
+		arch_flags += {
+			'avx512': arch_flags['avx512'] + ['-fno-asynchronous-unwind-tables']
+		}
+	endif
 endif
 
 codec_arch_prereqs = []
-- 
2.44.0.windows.1


From 88723553bc84ce4b237e4986e85a6ac76f943275 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Tim-Philipp=20M=C3=BCller?= <tim@centricular.com>
Date: Sun, 30 Jul 2023 16:03:48 +0100
Subject: [PATCH] ci: bump macos and ios images

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/9>

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 872c5dfaf..c4f27d483 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -232,13 +232,13 @@ macOS x86_64:
   extends: '.build darwin'
   stage: 'build'
   tags:
-    - gst-macos-12.3
+    - gst-macos-13
 
 iOS arm64 cross:
   extends: '.build darwin'
   stage: 'build'
   tags:
-    - gst-ios-15.4
+    - gst-ios-16
   script:
     - |
       cat > ios-cross-file.txt <<EOF
-- 
2.44.0.windows.1


From db447e8b40177aefd5d38d197b85c67b3ad873f9 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Fri, 4 Aug 2023 23:09:33 +0000
Subject: [PATCH] meson: Implement header installation

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/10>

diff --git a/meson.build b/meson.build
index a237c3edf..d34c07045 100644
--- a/meson.build
+++ b/meson.build
@@ -1809,6 +1809,41 @@ else
 	)
 endif
 
+headers = files(
+	'vpx/vpx_codec.h',
+	'vpx/vpx_frame_buffer.h',
+	'vpx/vpx_image.h',
+	'vpx/vpx_integer.h',
+)
+if features.get('vp8_encoder', false) or features.get('vp9_encoder', false)
+	headers += files(
+		'vpx/vp8.h',
+		'vpx/vp8cx.h',
+  		'vpx/vpx_ext_ratectrl.h',
+	)
+endif
+if features.get('vp8_decoder', false) or features.get('vp9_decoder', false)
+	headers += files(
+		'vpx/vp8.h',
+		'vpx/vp8dx.h',
+	)
+endif
+if features.get('decoders', false)
+	headers += files(
+		'vpx/vpx_decoder.h',
+	)
+endif
+if features.get('encoders', false)
+	headers += files(
+		'vpx/vpx_encoder.h',
+	)
+endif
+
+install_headers(
+	headers,
+	subdir: 'vpx'
+)
+
 libvpx_dep = declare_dependency(
 	link_with: libvpx,
 	dependencies: extra_libs,
-- 
2.44.0.windows.1


From 5709e126a71cd40fce52110c10e7289b60b42904 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Fri, 4 Aug 2023 21:35:07 -0300
Subject: [PATCH] meson: Fix internal flags not superseding toolchain's

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/10>

diff --git a/examples/meson.build b/examples/meson.build
index 9c3df73ab..9b511686e 100644
--- a/examples/meson.build
+++ b/examples/meson.build
@@ -252,6 +252,8 @@ if features.get('encoders', false)
 	vpxenc = executable(
 		'vpxenc',
 		vpxenc_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: vpxenc_headers,
 		dependencies: vpxenc_deps,
 		install: features.get('install_bins', false),
@@ -266,6 +268,8 @@ if features.get('vp9_encoder', false)
 	vp9_spatial_svc_encoder = executable(
 		'vp9_spatial_svc_encoder',
 		vp9_spatial_svc_encoder_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: vp9_spatial_svc_encoder_headers,
 		dependencies: examples_deps,
 	)
@@ -281,6 +285,8 @@ if not features.get('shared', false)
 		files(
 			'resize_util.c'
 		),
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		dependencies: examples_deps,
 	)
 endif
@@ -289,6 +295,8 @@ if features.get('encoders', false)
 	vpx_temporal_svc_encoder = executable(
 		'vpx_temporal_svc_encoder',
 		vpx_temporal_svc_encoder_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: vpx_temporal_svc_encoder_headers,
 		dependencies: examples_deps,
 	)
@@ -296,6 +304,8 @@ if features.get('encoders', false)
 	decode_to_md5 = executable(
 		'decode_to_md5',
 		decode_to_md5_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: decode_to_md5_headers,
 		dependencies: examples_deps,
 	)
@@ -303,6 +313,8 @@ if features.get('encoders', false)
 	simple_encoder = executable(
 		'simple_encoder',
 		simple_encoder_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: simple_encoder_headers,
 		dependencies: examples_deps,
 	)
@@ -310,6 +322,8 @@ if features.get('encoders', false)
 	vp9_lossless_encoder = executable(
 		'vp9_lossless_encoder',
 		vp9_lossless_encoder_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: vp9_lossless_encoder_headers,
 		dependencies: examples_deps,
 	)
@@ -317,6 +331,8 @@ if features.get('encoders', false)
 	twopass_encoder = executable(
 		'twopass_encoder',
 		twopass_encoder_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: twopass_encoder_headers,
 		dependencies: examples_deps,
 	)
@@ -324,6 +340,8 @@ if features.get('encoders', false)
 	set_maps = executable(
 		'set_maps',
 		set_maps_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: set_maps_headers,
 		dependencies: examples_deps,
 	)
@@ -342,6 +360,8 @@ if features.get('decoders', false)
 	simple_decoder = executable(
 		'simple_decoder',
 		simple_decoder_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: simple_decoder_headers,
 		dependencies: examples_deps,
 	)
@@ -349,6 +369,8 @@ if features.get('decoders', false)
 	postproc = executable(
 		'postproc',
 		postproc_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: postproc_headers,
 		dependencies: examples_deps,
 	)
@@ -356,6 +378,8 @@ if features.get('decoders', false)
 	decode_with_drops = executable(
 		'decode_with_drops',
 		decode_with_drops_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: postproc_headers,
 		dependencies: examples_deps,
 	)
@@ -371,6 +395,8 @@ if features.get('vp8_encoder', false)
 	vp8cx_set_ref = executable(
 		'vp8cx_set_ref',
 		vp8cx_set_ref_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: vp8cx_set_ref_headers,
 		dependencies: examples_deps,
 	)
@@ -384,6 +410,8 @@ if features.get('vp9_encoder', false) and features.get('decoders', false)
 	vp9cx_set_ref = executable(
 		'vp9cx_set_ref',
 		vp9cx_set_ref_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: vp9cx_set_ref_headers,
 		dependencies: examples_deps,
 	)
@@ -397,6 +425,8 @@ if features.get('multi_res_encoding', false) and features.get('libyuv', false)
 	vp8_multi_resolution_encoder = executable(
 		'vp8_multi_resolution_encoder',
 		vp8_multi_resolution_encoder_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: vp8_multi_resolution_encoder_headers,
 		dependencies: examples_deps + libyuv_dep,
 	)
diff --git a/meson.build b/meson.build
index d34c07045..87c1c7261 100644
--- a/meson.build
+++ b/meson.build
@@ -30,6 +30,11 @@ rtcd_options = []
 link_args = []
 extra_libs = []
 
+project_c_args = []
+project_cpp_args = []
+project_c_link_args = []
+project_cpp_link_args = []
+
 libyuv_cpp_args = []
 
 #######################
@@ -663,8 +668,8 @@ if tgt_isa.startswith('arm')
 		if tgt_isa == 'armv7'
 			if features.get('neon', false) or features.get('neon_asm', false)
 				gcc_flags = ['-mfpu=neon']
-				add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c') #-ftree-vectorize
-				add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+				project_c_args += c.get_supported_arguments(gcc_flags) #-ftree-vectorize
+				project_cpp_args += cpp.get_supported_arguments(gcc_flags)
 			endif
 		endif
 
@@ -680,8 +685,8 @@ if tgt_isa.startswith('arm')
 		if features.get('thumb', false)
 			asm_conversion_cmd += ['-thumb']
 			gcc_flags = ['-mthumb', '-Wa,-mimplicit-it=always']
-			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c') #-ftree-vectorize
-			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+			project_c_args += c.get_supported_arguments(gcc_flags) #-ftree-vectorize
+			project_cpp_args += cpp.get_supported_arguments(gcc_flags) #-ftree-vectorize
 		endif
 	elif tgt_cc == 'msvs'
 		# A number of ARM-based Windows platforms are constrained by their
@@ -771,8 +776,8 @@ elif tgt_isa.startswith('mips')
 	tune_cflags = '-mtune=@0@'
 
 	if features.get('dspr2', false)
-		add_project_arguments(c.get_supported_arguments('-mips2r32', '-mdspr2'), language: 'cpp')
-		add_project_arguments(cpp.get_supported_arguments('-mips2r32', '-mdspr2'), language: 'cpp')
+		project_c_args += c.get_supported_arguments('-mips2r32', '-mdspr2')
+		project_cpp_args += cpp.get_supported_arguments('-mips2r32', '-mdspr2')
 	endif
 
 	if features.get('runtime_cpu_detect', false)
@@ -782,14 +787,14 @@ elif tgt_isa.startswith('mips')
 	if tune_cpu != ''
 		if tune_cpu == 'p5600'
 			gcc_flags = ['-mips32r5', '-mload-store-pairs', '-msched-weight', '-mhard-float', '-mfp64']
-			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
-			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+			project_c_args += c.get_supported_arguments(gcc_flags)
+			project_cpp_args += cpp.get_supported_arguments(gcc_flags)
 		elif ['i6400', 'p6600'].contains(tune_cpu)
 			gcc_flags = ['-mips64r6', '-mabi=64', '-msched-weight', '-mload-store-pairs', '-mhard-float', '-mfp64']
-			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
-			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
-			add_project_link_arguments(c.get_supported_link_arguments(gcc_flags), language: 'c')
-			add_project_link_arguments(cpp.get_supported_link_arguments(gcc_flags), language: 'cpp')
+			project_c_args += c.get_supported_arguments(gcc_flags)
+			project_cpp_args += cpp.get_supported_arguments(gcc_flags)
+			project_c_link_args += c.get_supported_link_arguments(gcc_flags)
+			project_cpp_link_args += cpp.get_supported_link_arguments(gcc_flags)
 		elif tune_cpu.startswith('loongson3')
 			if c.has_argument('-march=loongson3a')
 				feature = 'mmi'
@@ -842,7 +847,7 @@ elif tgt_isa.startswith('mips')
 		endif
 	endif
 
-	add_project_arguments(c.get_supported_arguments('-march=@0@'.format(tgt_isa)), language: 'c')
+	project_c_args += c.get_supported_arguments('-march=@0@'.format(tgt_isa))
 	# KPIC is a flag that is valid only for SunCC.
 	# As such, we'll use the Meson derived version.
 elif tgt_isa == 'ppc64' and target_machine.endian() == 'little'
@@ -867,8 +872,8 @@ elif tgt_isa.startswith('x86')
 	elif tgt_os == 'windows'
 		if features.get('gcc', false)
 			gcc_flags = ['-fno-common']
-			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
-			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+			project_c_args += c.get_supported_arguments(gcc_flags)
+			project_cpp_args += cpp.get_supported_arguments(gcc_flags)
 		endif
 	# Solaris is Meson handled, and OS/2 is unsupported by Meson.
 	endif
@@ -877,21 +882,21 @@ elif tgt_isa.startswith('x86')
 
 	if tgt_cc == 'icc'
 		gcc_flags = ['-use-msasm']
-		add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
-		add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+		project_c_args += c.get_supported_arguments(gcc_flags)
+		project_cpp_args += cpp.get_supported_arguments(gcc_flags)
 		# add -no-intel-extensions to suppress warning #10237
 		# refer to http://software.intel.com/en-us/forums/topic/280199
 		# Meson: -i-static is deprecated
 		# See https://www.cita.utoronto.ca/~merz/intel_c10b/main_cls/mergedProjects/copts_cls/common_options/option_i_static.htm
 		gcc_flags = ['-static-intel', '-no-intel-extensions']
-		add_project_link_arguments(c.get_supported_link_arguments(gcc_flags), language: 'c')
-		add_project_link_arguments(cpp.get_supported_link_arguments(gcc_flags), language: 'cpp')
+		project_c_link_args += c.get_supported_link_arguments(gcc_flags)
+		project_cpp_link_args += cpp.get_supported_link_arguments(gcc_flags)
 
 		if tgt_isa == 'x86_64'
 			# -ipo is LTO, -static and -O3 all are Meson handled
 			gcc_flags = ['-no-prec-div']
-			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
-			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+			project_c_args += c.get_supported_arguments(gcc_flags)
+			project_cpp_args += cpp.get_supported_arguments(gcc_flags)
 			# xiar is also Meson handled
 			if tune_cpu.startswith('atom')
 				tune_cflags = '-x'
@@ -905,8 +910,8 @@ elif tgt_isa.startswith('x86')
 		# #for 32 bit x86 builds, -O3 did not turn on this flag
 		if features.get('optimizations', false) and not features.get('gprof', true)
 			gcc_flags = ['-fomit-frame-pointer']
-			add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
-			add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+			project_c_args += c.get_supported_arguments(gcc_flags)
+			project_cpp_args += cpp.get_supported_arguments(gcc_flags)
 		endif
 	elif tgt_cc == 'msvs'
 		# Based on the Gerrit review, it seems the author intended to ban
@@ -1107,10 +1112,7 @@ endif
 # Try to enable CPU specific tuning
 if tune_cpu != ''
 	if tune_cflags != ''
-		add_project_arguments(
-			c.get_supported_arguments(tune_cflags.format(tune_cpu), checked: 'require'),
-			language: 'c'
-		)
+		project_c_args += c.get_supported_arguments(tune_cflags.format(tune_cpu), checked: 'require')
 	else
 		warning('CPU tuning not supported by this toolchain')
 	endif
@@ -1121,8 +1123,8 @@ endif
 if features.get('gprof', false)
 	gcc_flags = ['-pg']
 
-	add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
-	add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+	project_c_args += c.get_supported_arguments(gcc_flags)
+	project_cpp_args += cpp.get_supported_arguments(gcc_flags)
 endif
 
 # optimizations are Meson handled
@@ -1190,18 +1192,14 @@ endif
 
 # glibc needs these
 if features.get('linux', false)
-	add_project_arguments(
-		'-D_LARGEFILE_SOURCE', '-D_FILE_OFFSET_BITS=64',
-		language: ['c', 'cpp']
-	)
+	project_c_args += ['-D_LARGEFILE_SOURCE', '-D_FILE_OFFSET_BITS=64']
+	project_cpp_args += ['-D_LARGEFILE_SOURCE', '-D_FILE_OFFSET_BITS=64']
 elif tgt_os == 'android'
 	api_level = c.get_define('__ANDROID_API__')
 	if api_level.version_compare('< 24') and tgt_isa == 'armv7'
 		warning('Disabling transparent large-file-support for Android API < 24 on armv7-a')
-		add_project_arguments(
-			'-U_FILE_OFFSET_BITS',
-			language: ['c', 'cpp']
-		)
+		project_c_args += ['-U_FILE_OFFSET_BITS']
+		project_cpp_args += ['-U_FILE_OFFSET_BITS']
 	endif
 endif
 
@@ -1226,37 +1224,34 @@ if features.get('gcc', false)
 		'-Wunused',
 	]
 
-	add_project_arguments(c.get_supported_arguments(gcc_flags), language: 'c')
-	add_project_arguments(cpp.get_supported_arguments(gcc_flags), language: 'cpp')
+	project_c_args += c.get_supported_arguments(gcc_flags)
+	project_cpp_args += cpp.get_supported_arguments(gcc_flags)
 
 	# gtest does not do well with
 	# these flags so add them explicitly to CFLAGS only.
-	add_project_arguments(c.get_supported_arguments('-Wundef'), language: 'c')
-	add_project_arguments(c.get_supported_arguments('-Wframe-larger-than=52000'), language: 'c')
+	project_c_args += c.get_supported_arguments('-Wundef')
+	project_c_args += c.get_supported_arguments('-Wframe-larger-than=52000')
 
 	if (features.get('mips', false) or features.get('INLINE', '') == '') and features.get('extra_warnings', false)
-		add_project_arguments(c.get_supported_arguments('-Wno-unused-function'), language: 'c')
-		add_project_arguments(cpp.get_supported_arguments('-Wno-unused-function'), language: 'cpp')
+		project_c_args += c.get_supported_arguments('-Wno-unused-function')
+		project_cpp_args += cpp.get_supported_arguments('-Wno-unused-function')
 	endif
 
 	# Avoid this warning for third_party C++ sources. Some reorganization
 	# would be needed to apply this only to test/*.cc.
-	add_project_arguments(c.get_supported_arguments('-Wshorten-64-to-32'), language: 'c')
+	project_c_args += c.get_supported_arguments('-Wshorten-64-to-32')
 
 	# Quiet gcc 6 vs 7 abi warnings:
 	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=77728
 	if features.get('arm', false)
-		add_project_arguments(cpp.get_supported_arguments('-Wno-psabi'), language: 'cpp')
+		project_cpp_args += cpp.get_supported_arguments('-Wno-psabi')
 	endif
 
 	# Enforce C++11 compatibility.
-	add_project_arguments(
-		cpp.get_supported_arguments(
-			'-Wc++14-extensions',
-			'-Wc++17-extensions',
-			'-Wc++20-extensions',
-		),
-		language: 'cpp'
+	project_cpp_args += cpp.get_supported_arguments(
+		'-Wc++14-extensions',
+		'-Wc++17-extensions',
+		'-Wc++20-extensions',
 	)
 	# disable some warnings specific to libyuv.
 	libyuv_cpp_args += cpp.get_supported_arguments(
@@ -1276,8 +1271,8 @@ if features.get('icc', false)
 		'-fp-model=precise',
 	]
 
-	add_project_arguments(c.get_supported_arguments(icc_flags), language: 'c')
-	add_project_arguments(cpp.get_supported_arguments(icc_flags), language: 'cpp')
+	project_c_args += c.get_supported_arguments(icc_flags)
+	project_cpp_args += cpp.get_supported_arguments(icc_flags)
 endif
 
 # Enable extra, harmless warnings. These might provide additional insight
@@ -1291,10 +1286,10 @@ extra_warnings = [
 ]
 
 if features.get('extra_warnings', false)
-	add_project_arguments(c.get_supported_arguments(extra_warnings), language: 'c')
+	project_c_args += c.get_supported_arguments(extra_warnings)
 	if features.get('gcc', false) and features.get('werror', false)
 		foreach w: extra_warnings
-			add_project_arguments(c.get_supported_arguments('-Wno-error=@0@'.format(w)), language: 'c')
+			project_c_args += c.get_supported_arguments('-Wno-error=@0@'.format(w))
 		endforeach
 	endif
 endif
@@ -1315,10 +1310,8 @@ if tgt_cc == 'msvs'
 		features.set('solution', true)
 	endif
 	features.set('INLINE', '__inline')
-	add_project_arguments(
-		'-D_CRT_SECURE_NO_WARNINGS', '-D_CRT_SECURE_NO_DEPRECATE',
-		language: ['c', 'cpp']
-	)
+	project_c_args += ['-D_CRT_SECURE_NO_WARNINGS', '-D_CRT_SECURE_NO_DEPRECATE']
+	project_cpp_args += ['-D_CRT_SECURE_NO_WARNINGS', '-D_CRT_SECURE_NO_DEPRECATE']
 endif
 
 # Other toolchain specific defaults
@@ -1350,7 +1343,7 @@ if tgt_cc == 'msvs'
 elif tgt_os == 'android'
 	enable_features = ['libyuv']
 	if cpp.has_argument('-std=gnu++11')
-		add_project_arguments('-std=gnu++11', language: 'cpp')
+		project_cpp_args += '-std=gnu++11'
 		enable_features += ['webm_io']
 	endif
 	foreach feature: enable_features
@@ -1369,7 +1362,7 @@ elif tgt_os == 'darwin'
 elif target_machine.system() == 'iphonesimulator'
 	enable_features = ['libyuv']
 	if cpp.has_argument('-std=gnu++11')
-		add_project_arguments('-std=gnu++11', language: 'cpp')
+		project_cpp_args += '-std=gnu++11'
 		enable_features += ['webm_io']
 	endif
 	foreach feature: enable_features
@@ -1386,7 +1379,7 @@ elif target_machine.system() == 'windows'
 	# would be disabled for the same reason.
 	enable_features = []
 	if cpp.has_argument('-std=gnu++11')
-		add_project_arguments('-std=gnu++11', language: 'cpp')
+		project_cpp_args += '-std=gnu++11'
 		enable_features += ['unit_tests', 'webm_io']
 	endif
 	if cpp.compiles('int z;')
@@ -1403,7 +1396,7 @@ elif target_machine.system() == 'windows'
 else
 	enable_features = []
 	if cpp.has_argument('-std=gnu++11')
-		add_project_arguments('-std=gnu++11', language: 'cpp')
+		project_cpp_args += '-std=gnu++11'
 		if features.get('pthread_h', false)
 			enable_features += ['unit_tests']
 		endif
@@ -1778,7 +1771,7 @@ foreach arch, srcs : codec_arch_srcs
 		'vpx-@0@'.format(arch),
 		codec_arch_prereqs + srcs,
 		extra_files: codec_arch_headers.get(comp_name, []),
-		c_args: arch_flags.get(arch, []),
+		c_args: arch_flags.get(arch, []) + project_c_args,
 		dependencies: extra_libs,
 	)
 endforeach
@@ -1787,7 +1780,8 @@ if features.get('static', false) and features.get('shared', false)
 	libvpx = both_libraries(
 		'vpx',
 		codec_srcs,
-		link_args: link_args,
+		c_args: project_c_args,
+		link_args: project_c_link_args + link_args,
 		extra_files: codec_headers,
 		dependencies: extra_libs,
 		link_whole: codec_arch_libs,
@@ -1799,7 +1793,8 @@ else
 	libvpx = library(
 		'vpx',
 		codec_srcs,
-		link_args: link_args,
+		c_args: project_c_args,
+		link_args: project_c_link_args + link_args,
 		extra_files: codec_headers,
 		dependencies: extra_libs,
 		link_whole: codec_arch_libs,
@@ -1898,6 +1893,8 @@ if features.get('unit_tests', false)
 		vpxrc_lib = static_library(
 			'vpxrc',
 			rc_rtc_srcs,
+			c_args: project_c_args,
+			link_args: project_c_link_args,
 			extra_files: codec_headers + rc_rtc_headers,
 			dependencies: extra_libs + libvpx_dep,
 		)
diff --git a/third_party/googletest/meson.build b/third_party/googletest/meson.build
index 767c9e140..abf9c3215 100644
--- a/third_party/googletest/meson.build
+++ b/third_party/googletest/meson.build
@@ -19,8 +19,9 @@ endif
 libgtest = static_library(
 	'gtest',
 	gtest_srcs,
-	c_args: gtest_flags,
-	cpp_args: gtest_flags,
+	c_args: project_c_args + gtest_flags,
+	cpp_args: project_cpp_args + gtest_flags,
+	link_args: project_cpp_link_args,
 	include_directories: gtest_includes,
 	dependencies: extra_libs,
 )
diff --git a/third_party/libwebm/meson.build b/third_party/libwebm/meson.build
index bd1671135..d567f226b 100644
--- a/third_party/libwebm/meson.build
+++ b/third_party/libwebm/meson.build
@@ -39,11 +39,12 @@ libwebm = static_library(
 	libwebm_common_srcs + libwebm_muxer_srcs + libwebm_parser_srcs,
 	extra_files: libwebm_common_includes + libwebm_muxer_headers + libwebm_parser_headers,
 	include_directories: include_directories('.'),
-	cpp_args: [
+	cpp_args: project_cpp_args + [
 		'-D__STDC_CONSTANT_MACROS',
 		'-D__STDC_FORMAT_MACROS',
 		'-D__STDC_LIMIT_MACROS'
-	]
+	],
+	link_args: project_cpp_link_args,
 )
 
 libwebm_dep = declare_dependency(
diff --git a/third_party/libyuv/meson.build b/third_party/libyuv/meson.build
index 0f67c4ec0..78af1b775 100644
--- a/third_party/libyuv/meson.build
+++ b/third_party/libyuv/meson.build
@@ -38,7 +38,8 @@ libyuv_srcs = files(
 libyuv = static_library(
 	'vpx_yuv',
 	libyuv_srcs,
-	cpp_args: libyuv_cpp_args,
+	cpp_args: project_cpp_args + libyuv_cpp_args,
+	link_args: project_cpp_link_args,
 	extra_files: libyuv_includes,
 	include_directories: libyuv_include_directories,
 )
diff --git a/tools/meson.build b/tools/meson.build
index c46c8358b..47c9ee831 100644
--- a/tools/meson.build
+++ b/tools/meson.build
@@ -24,7 +24,8 @@ tiny_ssim_headers = files(
 tiny_ssim = executable(
 	'tiny_ssim',
 	tiny_ssim_srcs,
-	link_args: link_args,
+	c_args: project_c_args,
+	link_args: project_c_link_args + link_args,
 	extra_files: tiny_ssim_headers,
 	dependencies: libvpx_dep,
 	install: get_option('install_bins'),
-- 
2.44.0.windows.1


From 3d03b7f932d65c889da954de62306605c8d75a0e Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Fri, 4 Aug 2023 21:48:05 -0300
Subject: [PATCH] meson: Fix another typo discovered by Cerbero's

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/10>

diff --git a/vpx_dsp/meson.build b/vpx_dsp/meson.build
index 04ec4b5d7..d8c83297c 100644
--- a/vpx_dsp/meson.build
+++ b/vpx_dsp/meson.build
@@ -435,7 +435,7 @@ if features.get('vp9_highbitdepth', false) # MANUAL
 		'ssse3' : dsp_optional_sources['ssse3'] + files(
 			'x86/highbd_intrapred_intrin_ssse3.c',
 		),
-		'neon' : dsp_optional_sources['ssse3'] + files(
+		'neon' : dsp_optional_sources['neon'] + files(
 			'arm/highbd_intrapred_neon.c',
 		),
 	}
-- 
2.44.0.windows.1


From 6ee5fcba336808bec88285fc46d092af0ba0ff4b Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Fri, 4 Aug 2023 22:27:09 -0300
Subject: [PATCH] meson: Implement missing workarounds for Android
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

With credits to Tim-Philipp Müller for the cpu-features lookup.

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/10>

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index c4f27d483..11fc1536a 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -280,6 +280,7 @@ iOS arm64 cross:
     ANDROID_NDK: '/android/ndk'
     ANDROID_API: '21'
     TOOLCHAIN: "$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64"
+    CPUFEATURES: "$ANDROID_NDK/sources/android/cpufeatures"
     NASM: "/usr/bin/nasm"
   before_script:
     - dnf install -y python3-pip binutils nasm gcc ninja-build
@@ -312,7 +313,7 @@ iOS arm64 cross:
       nasm      = '$NASM'
       pkgconfig = 'false'
       EOF
-    - meson setup mesonbuild --cross-file android-cross-file.txt
+    - meson setup mesonbuild --cross-file android-cross-file.txt -Dcpu_features_path=$CPUFEATURES
     - meson compile -C mesonbuild
 
 android arm64 cross:
diff --git a/meson.build b/meson.build
index 87c1c7261..3105f67f2 100644
--- a/meson.build
+++ b/meson.build
@@ -1196,11 +1196,28 @@ if features.get('linux', false)
 	project_cpp_args += ['-D_LARGEFILE_SOURCE', '-D_FILE_OFFSET_BITS=64']
 elif tgt_os == 'android'
 	api_level = c.get_define('__ANDROID_API__')
-	if api_level.version_compare('< 24') and tgt_isa == 'armv7'
+	if api_level.version_compare('< 24')
 		warning('Disabling transparent large-file-support for Android API < 24 on armv7-a')
 		project_c_args += ['-U_FILE_OFFSET_BITS']
 		project_cpp_args += ['-U_FILE_OFFSET_BITS']
 	endif
+
+	if api_level.version_compare('< 24') and tgt_isa == 'x86'
+		warning('''x86 targets prior to Android Nougat (API 24) need
+		-mstackrealign to properly align stack for global constructors.
+		See https://github.com/android-ndk/ndk/issues/635''')
+		project_c_args += ['-mstackrealign']
+		project_cpp_args += ['-mstackrealign']
+	endif
+	if c.get_linker_id().contains('lld') and tgt_isa == 'x86' and get_option('b_staticpic')
+		# Text relocations are required for all x86 objects. We
+		# must disable the warning to allow linking with lld. Unlike gold, ld which
+		# will silently allow text relocations, lld support must be explicit.
+		#
+		# See https://crbug.com/911658#c19 for more information. See also
+		# https://trac.ffmpeg.org/ticket/7878
+		project_c_link_args += ['-Wl,-z,notext']
+	endif
 endif
 
 if features.get('gcc', false)
@@ -1606,6 +1623,26 @@ else
 	endif
 endif
 
+if tgt_os == 'android'
+	# Android cpu-features
+	cpu_features_path = get_option('cpu_features_path')
+	cpu_features_sources = []
+	cpu_features_inc = []
+	if cpu_features_path == ''
+		error('cpu-features is a required Android component')
+	endif
+	message('Using cpu-features.[ch] from ' + cpu_features_path)
+	cpu_features_sources = files(
+		cpu_features_path / 'cpu-features.h',
+		cpu_features_path / 'cpu-features.c',
+	)
+	cpu_features_inc = include_directories(cpu_features_path)
+	codec_srcs += cpu_features_sources
+	extra_libs += declare_dependency(
+		include_directories: cpu_features_inc
+	)
+endif
+
 codec_arch_prereqs = []
 codec_arch_srcs = {}
 codec_arch_headers = {}
@@ -1772,6 +1809,7 @@ foreach arch, srcs : codec_arch_srcs
 		codec_arch_prereqs + srcs,
 		extra_files: codec_arch_headers.get(comp_name, []),
 		c_args: arch_flags.get(arch, []) + project_c_args,
+		link_args: project_c_link_args,
 		dependencies: extra_libs,
 	)
 endforeach
diff --git a/meson_options.txt b/meson_options.txt
index c94df9ccf..100d17ad8 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -47,3 +47,8 @@ option('vp8_decoder', type: 'feature', description: 'Enable the VP8 decoder only
 option('vp9_encoder', type: 'feature', description: 'Enable the VP9 encoder only')
 option('vp9_decoder', type: 'feature', description: 'Enable the VP9 decoder only')
 #### --- END GENERATED EXTERN OPTIONS --- ####
+option(
+  'cpu_features_path',
+  type : 'string',
+  description : 'Path to platform-specific cpu-features.[ch] for systems that do not provide it (e.g. Android)',
+)
-- 
2.44.0.windows.1


From 510c6132fdeaeaa368294c8b453de4b3920674de Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Sat, 5 Aug 2023 00:12:48 -0300
Subject: [PATCH] meson: Fix missing PIC detection

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/10>

diff --git a/meson.build b/meson.build
index 3105f67f2..2dd5730ca 100644
--- a/meson.build
+++ b/meson.build
@@ -85,6 +85,7 @@ features.set('spatial_resampling', true)
 features.set('multithread', true)
 features.set('os_support', true)
 features.set('temporal_denoising', true)
+features.set('pic', get_option('b_staticpic'))
 
 CODECS = [
 	'vp8_encoder',
@@ -1209,7 +1210,7 @@ elif tgt_os == 'android'
 		project_c_args += ['-mstackrealign']
 		project_cpp_args += ['-mstackrealign']
 	endif
-	if c.get_linker_id().contains('lld') and tgt_isa == 'x86' and get_option('b_staticpic')
+	if c.get_linker_id().contains('lld') and tgt_isa == 'x86' and features.get('pic')
 		# Text relocations are required for all x86 objects. We
 		# must disable the warning to allow linking with lld. Unlike gold, ld which
 		# will silently allow text relocations, lld support must be explicit.
-- 
2.44.0.windows.1


From b0b6317f5079ce35002166b7c078643f4f2f49bf Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Sat, 5 Aug 2023 00:10:23 -0300
Subject: [PATCH] meson: Fix iOS Simulator build

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/10>

diff --git a/meson.build b/meson.build
index 2dd5730ca..3a72512cf 100644
--- a/meson.build
+++ b/meson.build
@@ -525,8 +525,8 @@ c = meson.get_compiler('c')
 cpp = meson.get_compiler('cpp')
 asm = meson.get_compiler('c') # asm == GCC
 
-tgt_isa = target_machine.cpu_family()
-tgt_os = target_machine.system()
+tgt_isa = host_machine.cpu_family()
+tgt_os = host_machine.system()
 tgt_cc = c.get_id()
 
 if tgt_isa == 'arm'
@@ -541,27 +541,26 @@ endif
 
 if tgt_os == 'windows' or tgt_os == 'cygwin'
 	tgt_os = 'windows'
-elif ['darwin', 'ios', 'tvos'].contains(tgt_os)
+elif ['darwin', 'ios', 'tvos', 'iphonesimulator'].contains(tgt_os)
 	# The gcc -dumpmachine bit is used to force -mmacosx-version-min/max
 	warning('Apple target detected, please supply the --m(macos|ios)-version-* and -isysroot flags through -Dc_flags or a native file')
 
-	if tgt_os == 'darwin'
-		# Detect if iOS, tvOS...
-		xcrun_exe = find_program('xcrun', required: true)
+	# Detect if iOS, tvOS...
+	xcrun_exe = find_program('xcrun', required: true)
 
-		# The only one actually used is the iPhone simulator-- see later
-		# is_ios = c.get_define('TARGET_OS_MAC', prefix: '#include <TargetConditionals.h>')
-		# is_tvos = c.get_define('TARGET_OS_TV', prefix: '#include <TargetConditionals.h>')
-		is_simulator = c.get_define('TARGET_OS_SIMULATOR', prefix: '#include <TargetConditionals.h>')
+	# The only one actually used is the iPhone simulator-- see later
+	# is_ios = c.get_define('TARGET_OS_IOS', prefix: '#include <TargetConditionals.h>')
+	# is_tvos = c.get_define('TARGET_OS_TV', prefix: '#include <TargetConditionals.h>')
+	is_simulator = c.get_define('TARGET_OS_SIMULATOR', prefix: '#include <TargetConditionals.h>')
 
-		# if is_ios.to_int() == 1
-		# 	tgt_os = 'ios'
-		# elif is_tvos.to_int() == 1
-		# 	tgt_os = 'tvos'
-		# el
-		if is_simulator.to_int() == 1
-			tgt_os = 'iphonesimulator'
-		endif
+	# if is_ios.to_int() == 1
+	# 	tgt_os = 'ios'
+	# elif is_tvos.to_int() == 1
+	# 	tgt_os = 'tvos'
+	if is_simulator.to_int() == 1
+		tgt_os = 'iphonesimulator'
+	else
+		tgt_os = 'darwin'
 	endif
 elif tgt_os == 'linux' or tgt_os.endswith('bsd')
 	tgt_os = 'linux'
@@ -1073,7 +1072,7 @@ elif tgt_isa.startswith('x86')
 	elif tgt_os == 'iphonesimulator'
 		asm_args += ['-f', 'macho@0@'.format(bits)]
 		sdk_version = run_command(xcrun_exe, '--sdk', tgt_os, '--show-sdk-version', check: true, capture: true)
-		if sdk_version.version_compare('> 8.0')
+		if sdk_version.stdout().strip().version_compare('> 8.0')
 			# yasm v1.3.0 doesn't know what -fembed-bitcode means, so turning it
 			# on is pointless (unless building a C-only lib). Warn the user, but
 			# do nothing here.
@@ -1377,7 +1376,7 @@ elif tgt_os == 'darwin'
 	# Meson already handles the cpp_std flag.
 	# iOS/ARM builds do not work with gtest. This does not match
 	# x86 targets.
-elif target_machine.system() == 'iphonesimulator'
+elif tgt_os == 'iphonesimulator'
 	enable_features = ['libyuv']
 	if cpp.has_argument('-std=gnu++11')
 		project_cpp_args += '-std=gnu++11'
@@ -1815,6 +1814,12 @@ foreach arch, srcs : codec_arch_srcs
 	)
 endforeach
 
+# Work around iOS simulator refusing to link_whole static libraries
+objs = []
+foreach i: codec_arch_libs
+	objs += i.extract_all_objects(recursive: true)
+endforeach
+
 if features.get('static', false) and features.get('shared', false)
 	libvpx = both_libraries(
 		'vpx',
@@ -1823,7 +1828,7 @@ if features.get('static', false) and features.get('shared', false)
 		link_args: project_c_link_args + link_args,
 		extra_files: codec_headers,
 		dependencies: extra_libs,
-		link_whole: codec_arch_libs,
+		objects: objs,
 		version: soversion,
 		vs_module_defs: vpx_def,
 		install: features.get('install_libs'),
@@ -1836,7 +1841,7 @@ else
 		link_args: project_c_link_args + link_args,
 		extra_files: codec_headers,
 		dependencies: extra_libs,
-		link_whole: codec_arch_libs,
+		objects: objs,
 		version: soversion,
 		vs_module_defs: vpx_def,
 		install: features.get('install_libs'),
-- 
2.44.0.windows.1


From 7d41e474c4ba3be47a262275935cbd9e582e1a28 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Mon, 7 Aug 2023 19:58:03 -0300
Subject: [PATCH] meson: Allow introspection on feature flags

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/11>

diff --git a/meson.build b/meson.build
index 3a72512cf..f177428f7 100644
--- a/meson.build
+++ b/meson.build
@@ -1443,7 +1443,6 @@ endif
 
 features.set('unistd_h', c.has_header('unistd.h'))
 if c.has_header('vpx/vpx_integer.h', include_directories: include_directories('.'))
-	features.set('vpx_vpx_integer_h', true)
 	features.set('vpx_ports', true)
 endif
 
@@ -1883,10 +1882,17 @@ install_headers(
 	subdir: 'vpx'
 )
 
+dep_vars = {}
+
+foreach have : CMDLINE_SELECT
+	dep_vars += { have: features.get(have, false).to_string() }
+endforeach
+
 libvpx_dep = declare_dependency(
 	link_with: libvpx,
 	dependencies: extra_libs,
 	include_directories: include_directories('.'),
+	variables: dep_vars,
 )
 
 meson.override_dependency('vpx', libvpx_dep)
-- 
2.44.0.windows.1


From 90d26fac0d895969a82cd873ad36e39737104c44 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Thu, 10 Aug 2023 22:59:26 -0300
Subject: [PATCH] ci: Update Android jobs to R22b

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/12>

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 11fc1536a..54145dc9f 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -267,7 +267,7 @@ iOS arm64 cross:
     - meson test -C mesonbuild
 
 .build android:
-  image: 'registry.freedesktop.org/gstreamer/cerbero/android:2022-09-22.0'
+  image: 'registry.freedesktop.org/gstreamer/cerbero/android:2023-05-31.0'
   stage: 'build'
   artifacts:
     name: "${CI_JOB_NAME}_${CI_COMMIT_SHA}"
@@ -297,7 +297,6 @@ iOS arm64 cross:
       [constants]
       toolchain = '$TOOLCHAIN'
       clang_arch = '$CLANG_ARCH'
-      arch = '$ARCH'
       android_host = '$ANDROID_HOST'
       android_api = '$ANDROID_API'
 
@@ -305,11 +304,11 @@ iOS arm64 cross:
       sys_root = '$ANDROID_NDK/sysroot'
 
       [binaries]
-      ar        = toolchain + '/bin/' + arch + '-linux-' + android_host + '-ar'
-      c         = toolchain + '/bin/' + clang_arch + '-linux-' + android_host + android_api + '-clang'
-      cpp       = toolchain + '/bin/' + clang_arch + '-linux-' + android_host + android_api + '-clang++'
-      ranlib    = toolchain + '/bin/' + arch + '-linux-' + android_host + '-ranlib'
-      strip     = toolchain + '/bin/' + arch + '-linux-' + android_host + '-strip'
+      ar        = toolchain + '/bin/llvm-ar'
+      c         = [toolchain + '/bin/clang', '-target', clang_arch + '-linux-' + android_host + android_api]
+      cpp       = [toolchain + '/bin/clang++', '-target', clang_arch + '-linux-' + android_host + android_api]
+      ranlib    = toolchain + '/bin/llvm-ranlib'
+      strip     = toolchain + '/bin/llvm-strip'
       nasm      = '$NASM'
       pkgconfig = 'false'
       EOF
-- 
2.44.0.windows.1


From ce75861fbe41fef96ffc6ef23011ae77fdf4759c Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Mon, 21 Aug 2023 15:54:17 -0300
Subject: [PATCH] meson: Fix docs installation when built as a subproject

This is yet another instance of Meson calling Ninja from the root
project's build directory, which mucks with the output of custom_target.

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/14>

diff --git a/meson.build b/meson.build
index f177428f7..33618f9c7 100644
--- a/meson.build
+++ b/meson.build
@@ -2017,6 +2017,7 @@ if features.get('install_docs', false)
 			'--strip', meson.current_source_dir(), meson.current_build_dir(),
 			'--example-path', example_path,
 			'--output', '@OUTPUT@',
+			meson.current_build_dir(),
 			'@INPUT@'],
 		output: 'Doxyfile',
 		input: codec_dox
diff --git a/meson/generate_doxyfile.py b/meson/generate_doxyfile.py
index edea48a6c..5ceb1b5b4 100644
--- a/meson/generate_doxyfile.py
+++ b/meson/generate_doxyfile.py
@@ -18,6 +18,7 @@ if __name__ == '__main__':
 	parser.add_argument('--strip', nargs='+', type=Path, help='Make paths inside this directory relative')
 	parser.add_argument('--example-path', nargs='+', type=Path, help='Directory that contains example code fragments')
 	parser.add_argument('--output', type=FileType('w', encoding='utf-8'), required=True, help='Write to this file')
+	parser.add_argument('root', type=Path, help='Root for the Doxygen output')
 	parser.add_argument('inputs', nargs='+', type=Path, help='Inputs for the Doxygen documentation')
 	args = parser.parse_args()
 
@@ -29,7 +30,7 @@ if __name__ == '__main__':
 		with file.open(encoding='utf-8') as input:
 			f.write(input.read())
 	f.write('# MESON override OUTPUT_DIR\n')
-	f.write('OUTPUT_DIRECTORY       = \n')
+	f.write(f'OUTPUT_DIRECTORY       = {args.root}\n')
 	if args.strip is not None:
 		paths_to_strip: str = ' '.join([f.as_posix() for f in args.strip])
 		f.write(f'STRIP_FROM_PATH += {paths_to_strip}\n')
-- 
2.44.0.windows.1


From 4d3e1ba334c9672f9df754672785f1127500a147 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Fri, 18 Aug 2023 13:31:55 -0300
Subject: [PATCH] meson: Fix pthreads detection failure not disabling
 multithreaded build

See gstreamer/gstreamer#2905

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/13>

diff --git a/meson.build b/meson.build
index 33618f9c7..8ae4f7dee 100644
--- a/meson.build
+++ b/meson.build
@@ -1144,7 +1144,8 @@ endif
 
 # Almost every platform uses pthreads.
 if features.get('multithread', false)
-	threads_dep = c.find_library('threads', required: false)
+	threads_dep = dependency('threads', required: false)
+	extra_libs += threads_dep
 	if c.compiles('''
 		#include <pthread.h>
 		#include <stddef.h>
@@ -1152,7 +1153,7 @@ if features.get('multithread', false)
 		name: 'supports pthreads',
 		dependencies: threads_dep
 	)
-		extra_libs += threads_dep
+		features.set('pthread_h', true)
 	else
 		features.set('pthread_h', false)
 	endif
-- 
2.44.0.windows.1


From c43209801cc0c780871b41ced55aad4819002b4d Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Wed, 13 Sep 2023 01:54:13 +0000
Subject: [PATCH] meson: Fix executable permissions on all helper scripts

The executable permission bit is checked by some interpreters, even when
running the script through the Python executable.

See gstreamer/cerbero#450

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/15>

diff --git a/meson/capture_build_options.py b/meson/capture_build_options.py
old mode 100644
new mode 100755
diff --git a/meson/check_test_data.py b/meson/check_test_data.py
old mode 100644
new mode 100755
diff --git a/meson/generate_component_dox.py b/meson/generate_component_dox.py
old mode 100644
new mode 100755
diff --git a/meson/generate_doxy.py b/meson/generate_doxy.py
old mode 100644
new mode 100755
diff --git a/meson/generate_doxyfile.py b/meson/generate_doxyfile.py
old mode 100644
new mode 100755
diff --git a/meson/parse_options.py b/meson/parse_options.py
old mode 100644
new mode 100755
diff --git a/meson/parse_sources.py b/meson/parse_sources.py
old mode 100644
new mode 100755
diff --git a/meson/stdinout_wrapper.py b/meson/stdinout_wrapper.py
old mode 100644
new mode 100755
diff --git a/meson/transform_config.py b/meson/transform_config.py
old mode 100644
new mode 100755
diff --git a/meson/transform_config_asm.py b/meson/transform_config_asm.py
old mode 100644
new mode 100755
-- 
2.44.0.windows.1


From dea607b5da600f8a24a17e147c015dc53611f68e Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Thu, 14 Sep 2023 12:20:14 -0300
Subject: [PATCH] meson: Test proper linkage of pthreads, not just compilation

Upstream configure script tests that not only pthreads is found, it
should also produce a valid executable.

See gstreamer/cerbero#450

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/16>

diff --git a/meson.build b/meson.build
index 8ae4f7dee..79ebb514c 100644
--- a/meson.build
+++ b/meson.build
@@ -1146,7 +1146,7 @@ endif
 if features.get('multithread', false)
 	threads_dep = dependency('threads', required: false)
 	extra_libs += threads_dep
-	if c.compiles('''
+	if c.links('''
 		#include <pthread.h>
 		#include <stddef.h>
 		int main(void) { return pthread_create(NULL, NULL, NULL, NULL); }''',
-- 
2.44.0.windows.1


From b2bd418b6f3bc28eedd8f94681cac5c1e4e5eb00 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Tim-Philipp=20M=C3=BCller?= <tim@centricular.com>
Date: Mon, 9 Oct 2023 18:43:36 +0100
Subject: [PATCH] meson: update to 1.13.1


diff --git a/meson.build b/meson.build
index 79ebb514c..09b9859f1 100644
--- a/meson.build
+++ b/meson.build
@@ -4,7 +4,7 @@
 project(
 	'libvpx',
 	'c', 'cpp',
-	version: '1.13.0',
+	version: '1.13.1',
 	default_options: [
 		# Enforce c89 for c files. Don't be too strict about it though. Allow
 		# gnu extensions like "//" for comments.
-- 
2.44.0.windows.1


From e6448852b9ae239beb767d31f369eea576557447 Mon Sep 17 00:00:00 2001
From: Seungmin Kim <66779-ehf@users.noreply.gitlab.freedesktop.org>
Date: Wed, 27 Mar 2024 13:47:31 +0000
Subject: [PATCH] Fix ads2gas.py to be used in Python 3.8

Aesthetic change

Fixes #3

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/19>

diff --git a/build/make/ads2gas.py b/build/make/ads2gas.py
index c8025a971..0574135dd 100755
--- a/build/make/ads2gas.py
+++ b/build/make/ads2gas.py
@@ -4,6 +4,7 @@
 # SPDX-License-Identifier: BSD-3-Clause
 
 from argparse import ArgumentParser
+from typing import List
 import re
 import sys
 import thumb
@@ -23,7 +24,7 @@ if __name__ == '__main__':
         print('\t.thumb')
 
     # Stack of procedure names.
-    proc_stack: list[str] = []
+    proc_stack: List[str] = []
 
     f = iter(sys.stdin.readlines())
     for line in f:
-- 
2.44.0.windows.1


From 79c9a635d61f2a200a5c79c268e95c54c8bd79f7 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Mon, 8 Apr 2024 22:20:37 -0300
Subject: [PATCH] meson: Fix wrong instruction set flags for MSVC builds


diff --git a/meson.build b/meson.build
index 09b9859f1..1df26ca88 100644
--- a/meson.build
+++ b/meson.build
@@ -1587,9 +1587,9 @@ if tgt_cc == 'msvs'
 		'sse3': [],
 		'ssse3': [],
 		'sse4_1': [],
-		'avx': c.get_supported_arguments('-march:avx'),
-		'avx2': c.get_supported_arguments('-march:avx2'),
-		'avx512': c.get_supported_arguments('-march:avx512'),
+		'avx': c.get_supported_arguments('/arch:AVX'),
+		'avx2': c.get_supported_arguments('/arch:AVX2'),
+		'avx512': c.get_supported_arguments('/arch:AVX512'),
 	}
 else
 	arch_flags = {
-- 
2.44.0.windows.1


From ed41095230adb8d9edf0054164a33c2cc8ce9461 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Mon, 8 Apr 2024 22:21:12 -0300
Subject: [PATCH] meson: Fix missing CPUID detection for x86* builds

This fixes a crash with illegal instruction on non-Intel or pre-AVX512
CPUs when attempting to encode or decode a stream.

diff --git a/meson.build b/meson.build
index 1df26ca88..765d032b8 100644
--- a/meson.build
+++ b/meson.build
@@ -936,11 +936,11 @@ elif tgt_isa.startswith('x86')
 	endif
 
 	feature = 'runtime_cpu_detect'
-	if features.get(tgt_isa, true) # soft_enabled
-		if not features.has(tgt_isa)
-			message('\tenabling @0@'.format(tgt_isa))
+	if features.get(feature, true) # soft_enabled
+		if not features.has(feature)
+			message('\tenabling @0@'.format(feature))
 		endif
-		features.set(tgt_isa, true)
+		features.set(feature, true)
 	endif
 
 	# Unline the original, we do can test cflags here :)
-- 
2.44.0.windows.1


From a334f583d65a4b416c8557b2242ca110994503a2 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Wed, 10 Jul 2024 12:36:17 -0300
Subject: [PATCH] meson: Prohibit shared libraries outside of Linux and Darwin
 platforms

Windows in particular needs special consideration because of `__declspec(dllimport)` being absent from the data exports.

diff --git a/meson.build b/meson.build
index 765d032b8..7366c61a7 100644
--- a/meson.build
+++ b/meson.build
@@ -1563,6 +1563,14 @@ vpx_config_c = configure_file(
 
 # libs.mk
 
+if features.get('shared', false) and not ['linux', 'darwin', 'ios', 'iphonesimulator'].contains(tgt_os)
+	if features.enabled('gnu', false)
+		warn('Shared libraries are only supported on ELF; assuming this is OK')
+	else
+		error('Shared libraries are only supported on ELF, OS/2, and Darwin for now')
+	endif
+endif
+
 rtcd_exe = find_program('build/make/rtcd.py', required: true)
 
 extra_libs += c.find_library('m', required: false)
@@ -1820,33 +1828,18 @@ foreach i: codec_arch_libs
 	objs += i.extract_all_objects(recursive: true)
 endforeach
 
-if features.get('static', false) and features.get('shared', false)
-	libvpx = both_libraries(
-		'vpx',
-		codec_srcs,
-		c_args: project_c_args,
-		link_args: project_c_link_args + link_args,
-		extra_files: codec_headers,
-		dependencies: extra_libs,
-		objects: objs,
-		version: soversion,
-		vs_module_defs: vpx_def,
-		install: features.get('install_libs'),
-	)
-else
-	libvpx = library(
-		'vpx',
-		codec_srcs,
-		c_args: project_c_args,
-		link_args: project_c_link_args + link_args,
-		extra_files: codec_headers,
-		dependencies: extra_libs,
-		objects: objs,
-		version: soversion,
-		vs_module_defs: vpx_def,
-		install: features.get('install_libs'),
-	)
-endif
+libvpx = library(
+	'vpx',
+	codec_srcs,
+	c_args: project_c_args,
+	link_args: project_c_link_args + link_args,
+	extra_files: codec_headers,
+	dependencies: extra_libs,
+	objects: objs,
+	version: soversion,
+	vs_module_defs: vpx_def,
+	install: features.get('install_libs'),
+)
 
 headers = files(
 	'vpx/vpx_codec.h',
-- 
2.44.0.windows.1


From 1fdc1f7de86ccf1b165fd10305c905745e326fe7 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Wed, 10 Jul 2024 12:42:38 -0300
Subject: [PATCH] meson: Fix typo in the tiny_ssim executable clause

Using combos as booleans is not valid, the features hash was intended here.

diff --git a/tools/meson.build b/tools/meson.build
index 47c9ee831..7e6f16360 100644
--- a/tools/meson.build
+++ b/tools/meson.build
@@ -28,7 +28,7 @@ tiny_ssim = executable(
 	link_args: project_c_link_args + link_args,
 	extra_files: tiny_ssim_headers,
 	dependencies: libvpx_dep,
-	install: get_option('install_bins'),
+	install: features.get('install_bins', false),
 )
 
 tools_subpages = {
-- 
2.44.0.windows.1


From eecbef0754c7b36bb55c6b0ec1aca0717bc69ea9 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Sat, 20 Jul 2024 21:07:28 +0000
Subject: [PATCH] ci: Switch Apple jobs to the Arm64 runner

Fixes #2

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/22>

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 54145dc9f..cc7c27de1 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -198,6 +198,9 @@ vs2019 arm64 cross:
 
 .build darwin:
   stage: 'build'
+  image: "registry.freedesktop.org/gstreamer/gstreamer/macos-arm64/14-sonoma:2023-10-25.0"
+  tags:
+    - gst-mac-arm
   artifacts:
     name: "${CI_JOB_NAME}_${CI_COMMIT_SHA}"
     expire_in: '5 days'
@@ -215,35 +218,35 @@ vs2019 arm64 cross:
     - pip3 install --upgrade pip
     # Make sure meson is up to date
     - pip3 install -U meson
-    # Need to install certificates for python
-    - pip3 install --upgrade certifi
-    # Another way to install certificates
-    - open /Applications/Python\ 3.8/Install\ Certificates.command
     # Get ninja
     - pip3 install -U ninja
   script:
-    # HACK to sneak Nasm and Perl under Meson's nose.
-    - export PATH="$(pwd)/subprojects/nasm-2.16.01:$PATH"
-    - CERT_PATH=$(python3 -m certifi) && export SSL_CERT_FILE=${CERT_PATH} && export REQUESTS_CA_BUNDLE=${CERT_PATH} && meson setup mesonbuild
+    - meson setup mesonbuild
     - meson compile -C mesonbuild
     - meson test -C mesonbuild
 
+macOS arm64:
+  extends: '.build darwin'
+
 macOS x86_64:
   extends: '.build darwin'
-  stage: 'build'
-  tags:
-    - gst-macos-13
+  script:
+    # HACK to sneak Nasm and Perl under Meson's nose.
+    - export PATH="$(pwd)/subprojects/nasm-2.16.01:$PATH"
+    - meson setup mesonbuild
+    - meson compile -C mesonbuild
+    - meson test -C mesonbuild
 
 iOS arm64 cross:
   extends: '.build darwin'
-  stage: 'build'
-  tags:
-    - gst-ios-16
+  # Same-architecture cross-builds are broken on 1.4.1
+  # 1.5.0 was meant to fix this, but instead broke detection wholesale
+  # Once 1.5.1 is out, try restoring `system = 'darwin'`
   script:
     - |
       cat > ios-cross-file.txt <<EOF
       [host_machine]
-      system = 'darwin'
+      system = 'ios'
       cpu_family = 'aarch64'
       cpu = 'aarch64'
       endian = 'little'
@@ -262,7 +265,7 @@ iOS arm64 cross:
       strip     = '$(xcrun --find --sdk iphoneos strip)'
       pkgconfig = 'false'
       EOF
-    - CERT_PATH=$(python3 -m certifi) && export SSL_CERT_FILE=${CERT_PATH} && export REQUESTS_CA_BUNDLE=${CERT_PATH} && meson setup mesonbuild --cross-file=ios-cross-file.txt
+    - meson setup mesonbuild --cross-file=ios-cross-file.txt
     - meson compile -C mesonbuild
     - meson test -C mesonbuild
 
-- 
2.44.0.windows.1


From 38847a0321bcb1d04ff09ccd410f0d6288b92c39 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Wed, 10 Jul 2024 18:53:54 -0300
Subject: [PATCH] meson: Update to 1.14.1

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/21>

diff --git a/build/make/rtcd.py b/build/make/rtcd.py
index 3d4121c57..cdff3dcc1 100755
--- a/build/make/rtcd.py
+++ b/build/make/rtcd.py
@@ -422,7 +422,7 @@ if __name__ == '__main__':
         ALL_ARCHS = filter(*qw('neon_asm neon'))
         arm()
     elif opts['arch'] == 'armv8' or opts['arch'] == 'arm64':
-        ALL_ARCHS = filter(*qw('neon'))
+        ALL_ARCHS = filter(*qw('neon neon_dotprod neon_i8mm sve'))
         REQUIRES = filter(*qw('neon'))
         require(*REQUIRES)
         arm()
diff --git a/examples/meson.build b/examples/meson.build
index 9b511686e..09e5fab2c 100644
--- a/examples/meson.build
+++ b/examples/meson.build
@@ -232,6 +232,8 @@ if features.get('decoders', false)
 	vpxdec = executable(
 		'vpxdec',
 		vpxdec_srcs,
+		c_args: project_c_args,
+		link_args: project_c_link_args,
 		extra_files: vpxdec_headers,
 		dependencies: vpxdec_deps,
 		install: features.get('install_bins', false),
diff --git a/meson.build b/meson.build
index 7366c61a7..198165e61 100644
--- a/meson.build
+++ b/meson.build
@@ -4,13 +4,11 @@
 project(
 	'libvpx',
 	'c', 'cpp',
-	version: '1.13.1',
+	version: '1.14.1',
 	default_options: [
-		# Enforce c89 for c files. Don't be too strict about it though. Allow
-		# gnu extensions like "//" for comments.
-		'c_std=gnu89',
-		# Uncomment when Meson can handle this one for MSVC.
-		# 'cpp_std=gnu++11',
+		# Enforce C99 for C files. Allow GNU extensions.
+		'c_std=c11', # Because MSVC
+		'cpp_std=c++11',
 		'warning_level=2',
 		'default_library=static',
 		'buildtype=debugoptimized',
@@ -85,6 +83,10 @@ features.set('spatial_resampling', true)
 features.set('multithread', true)
 features.set('os_support', true)
 features.set('temporal_denoising', true)
+
+if get_option('b_pie') and not get_option('b_staticpic')
+	error('PIC is required when building position independent executables')
+endif
 features.set('pic', get_option('b_staticpic'))
 
 CODECS = [
@@ -101,6 +103,7 @@ CODEC_FAMILIES = [
 
 ARCH_LIST = [
 	'arm',
+	'aarch64',
 	'mips',
 	'x86',
 	'x86_64',
@@ -108,6 +111,13 @@ ARCH_LIST = [
 	'loongarch',
 ]
 
+ARCH_EXT_LIST_AARCH64 = [
+	'neon',
+	'neon_dotprod',
+	'neon_i8mm',
+	'sve',
+]
+
 ARCH_EXT_LIST_X86 = [
 	'mmx',
 	'sse',
@@ -127,9 +137,8 @@ ARCH_EXT_LIST_LOONGSON = [
 ]
 
 ARCH_EXT_LIST = [
-	'neon',
-	'neon_asm',
-
+	'neon_asm'
+] + ARCH_EXT_LIST_AARCH64 + [
 	'mips32',
 	'dspr2',
 	'msa',
@@ -199,7 +208,6 @@ CONFIG_LIST = [
 	'multi_res_encoding',
 	'temporal_denoising',
 	'vp9_temporal_denoising',
-	'consistent_recode',
 	'coefficient_range_checking',
 	'vp9_highbitdepth',
 	'better_hw_compatibility',
@@ -265,7 +273,6 @@ CMDLINE_SELECT = [
 	'multi_res_encoding',
 	'temporal_denoising',
 	'vp9_temporal_denoising',
-	'consistent_recode',
 	'coefficient_range_checking',
 	'better_hw_compatibility',
 	'vp9_highbitdepth',
@@ -525,6 +532,11 @@ c = meson.get_compiler('c')
 cpp = meson.get_compiler('cpp')
 asm = meson.get_compiler('c') # asm == GCC
 
+# Since MSVC does not support C99, but the official configure expects it,
+# the Meson default takes C11. This sets the GNU extensions back online.
+add_project_arguments(c.get_supported_arguments('-std=gnu11'), language: 'c')
+add_project_arguments(cpp.get_supported_arguments('-std=gnu++11'), language: 'cpp')
+
 tgt_isa = host_machine.cpu_family()
 tgt_os = host_machine.system()
 tgt_cc = c.get_id()
@@ -612,7 +624,10 @@ endif
 features.set(tgt_cc, true)
 
 # Enable the architecture family
-if tgt_isa.startswith('arm')
+if tgt_isa == 'arm64'
+	features.set('arm', true)
+	features.set('aarch64', true)
+elif tgt_isa.startswith('arm')
 	features.set('arm', true)
 elif tgt_isa.startswith('mips')
 	features.set('mips', true)
@@ -637,7 +652,7 @@ if tgt_os == 'solaris'
 endif
 
 if tgt_isa.startswith('arm')
-	feature = 'neon'
+	feature = 'runtime_cpu_detect'
 	if features.get(feature, true)
 		if not features.has(feature)
 			message('\tenabling @0@'.format(feature))
@@ -646,6 +661,13 @@ if tgt_isa.startswith('arm')
 	endif
 
 	if tgt_isa == 'armv7'
+		feature = 'neon'
+		if features.get(feature, true)
+			if not features.has(feature)
+				message('\tenabling @0@'.format(feature))
+			endif
+			features.set(feature, true)
+		endif
 		# Only enable neon_asm when neon is also enabled.
 		if features.get('neon', false)
 			feature = 'neon_asm'
@@ -772,6 +794,93 @@ if tgt_isa.startswith('arm')
 	elif tgt_os == 'linux'
 		features.set('linux', true)
 	endif
+	if tgt_isa == 'arm64'
+		aarch64_arch_flag_neon = 'arch=armv8-a'
+		aarch64_arch_flag_neon_dotprod = 'arch=armv8.2-a+dotprod'
+		aarch64_arch_flag_neon_i8mm = 'arch=armv8.2-a+dotprod+i8mm'
+		aarch64_arch_flag_sve = 'arch=armv8.2-a+dotprod+i8mm+sve'
+
+		# Unline the original, we do can test cflags here :)
+		disable_exts = false
+		foreach feature : ARCH_EXT_LIST_AARCH64
+			if disable_exts
+				rtcd_options += ['--disable', feature]
+				if not features.get(feature, false) # ! enabled
+					if not features.has(feature) # disabled
+						message('\tdisabling @0@'.format(feature))
+					endif
+					features.set(feature, false)
+				endif
+			else
+				# Check the compiler supports the -march flag for the extension.
+				# This needs to happen after toolchain/OS inspection so we handle
+				# $CROSS etc correctly when checking for flags, else these will
+				# always fail.
+				flag = get_variable('aarch64_arch_flag_@0@'.format(feature))
+				if c.has_argument('-m@0@'.format(flag))
+					if features.get(feature, true)
+						if not features.has(feature)
+							message('\tenabling @0@'.format(feature))
+						endif
+						features.set(feature, true)
+					endif
+				else
+					rtcd_options += ['--disable', feature]
+					if not features.get(feature, false) # ! enabled
+						if not features.has(feature) # disabled
+							message('\tdisabling @0@'.format(feature))
+						endif
+						features.set(feature, false)
+					endif
+				endif
+				if not features.get(feature, false)
+					# Disable higher order extensions to simplify dependencies.
+					disable_exts = true
+					rtcd_options += ['--disable', feature]
+					if not features.get(feature, false) # ! enabled
+						if not features.has(feature) # disabled
+							message('\tdisabling @0@'.format(feature))
+						endif
+						features.set(feature, false)
+					endif
+				endif
+			endif
+		endforeach
+		if features.get('sve', false)
+			supports_armv8_etc = c.compiles('''
+				#ifndef __ARM_NEON_SVE_BRIDGE
+				#error 1
+				#endif
+				#include <arm_sve.h>
+				#include <arm_neon_sve_bridge.h>
+				''',
+				name: 'supports Armv8.2-a, dotprod, i8mm, and SVE',
+				args: '-march=armv8.2-a+dotprod+i8mm+sve'
+			)
+			if supports_armv8_etc
+				# Check whether the compiler can compile SVE functions that require
+				# backup/restore of SVE registers according to AAPCS. Clang for Windows
+				# used to fail this, see
+				# https://github.com/llvm/llvm-project/issues/80009.
+				supports_armv8_etc = c.compiles('''
+					#include <arm_sve.h>
+					void other(void);
+					svfloat32_t func(svfloat32_t a) {
+						other();
+						return a;
+					}
+					''',
+					name: 'has usable arm_sve.h',
+					args: '-march=armv8.2-a+dotprod+i8mm+sve'
+				)
+			endif
+			if not supports_armv8_etc
+				warning('disabling SVE: arm_neon_sve_bridge.h not supported by compiler')
+				features.set('sve', false)
+				rtcd_options += ['--disable', 'sve']
+			endif
+		endif
+	endif
 elif tgt_isa.startswith('mips')
 	tune_cflags = '-mtune=@0@'
 
@@ -1223,7 +1332,6 @@ endif
 
 if features.get('gcc', false)
 	gcc_flags = [
-		'-Wdeclaration-after-statement',
 		'-Wdisabled-optimization',
 		'-Wextra-semi',
 		'-Wextra-semi-stmt',
@@ -1237,8 +1345,9 @@ if features.get('gcc', false)
 		'-Wimplicit-function-declaration',
 		'-Wmissing-declarations',
 		'-Wmissing-prototypes',
+		'-Wshadow',
 		'-Wuninitialized',
-		'-Wunreachable-code-loop-increment',
+		'-Wunreachable-code-aggressive',
 		'-Wunused',
 	]
 
@@ -1270,12 +1379,14 @@ if features.get('gcc', false)
 		'-Wc++14-extensions',
 		'-Wc++17-extensions',
 		'-Wc++20-extensions',
+		'-Wnon-virtual-dtor',
 	)
-	# disable some warnings specific to libyuv.
+	# disable some warnings specific to libyuv / libwebm.
 	libyuv_cpp_args += cpp.get_supported_arguments(
 		'-Wno-missing-declarations',
 		'-Wno-missing-prototypes',
 		'-Wno-pass-failed',
+		'-Wno-shadow',
 		'-Wno-unused-parameter',
 	)
 endif
@@ -1361,7 +1472,6 @@ if tgt_cc == 'msvs'
 elif tgt_os == 'android'
 	enable_features = ['libyuv']
 	if cpp.has_argument('-std=gnu++11')
-		project_cpp_args += '-std=gnu++11'
 		enable_features += ['webm_io']
 	endif
 	foreach feature: enable_features
@@ -1380,7 +1490,6 @@ elif tgt_os == 'darwin'
 elif tgt_os == 'iphonesimulator'
 	enable_features = ['libyuv']
 	if cpp.has_argument('-std=gnu++11')
-		project_cpp_args += '-std=gnu++11'
 		enable_features += ['webm_io']
 	endif
 	foreach feature: enable_features
@@ -1397,7 +1506,6 @@ elif target_machine.system() == 'windows'
 	# would be disabled for the same reason.
 	enable_features = []
 	if cpp.has_argument('-std=gnu++11')
-		project_cpp_args += '-std=gnu++11'
 		enable_features += ['unit_tests', 'webm_io']
 	endif
 	if cpp.compiles('int z;')
@@ -1414,7 +1522,6 @@ elif target_machine.system() == 'windows'
 else
 	enable_features = []
 	if cpp.has_argument('-std=gnu++11')
-		project_cpp_args += '-std=gnu++11'
 		if features.get('pthread_h', false)
 			enable_features += ['unit_tests']
 		endif
@@ -1553,7 +1660,7 @@ else
 endif
 
 vpx_config_data = configuration_data()
-vpx_config_data.set_quoted('CONFIGURE_ARGS', configure_args)
+vpx_config_data.set_quoted('CONFIGURE_ARGS', configure_args.replace('\\', '\\\\'))
 
 vpx_config_c = configure_file(
 	input: 'meson/vpx_config.c',
@@ -1564,7 +1671,7 @@ vpx_config_c = configure_file(
 # libs.mk
 
 if features.get('shared', false) and not ['linux', 'darwin', 'ios', 'iphonesimulator'].contains(tgt_os)
-	if features.enabled('gnu', false)
+	if features.get('gcc', false) # Looks like a typo on upstream
 		warn('Shared libraries are only supported on ELF; assuming this is OK')
 	else
 		error('Shared libraries are only supported on ELF, OS/2, and Darwin for now')
@@ -1611,6 +1718,11 @@ else
 		'avx2': ['-mavx2'],
 		'avx512': ['-mavx512f', '-mavx512cd', '-mavx512bw', '-mavx512dq', '-mavx512vl'],
 
+		# AARCH64
+		'neon_dotprod': ['-march=armv8.2-a+dotprod'],
+		'neon_i8mm': ['-march=armv8.2-a+dotprod+i8mm'],
+		'sve': ['-march=armv8.2-a+dotprod+i8mm+sve'],
+
 		# POWER
 		'vsx' : ['-maltivec', '-mvsx'],
 
@@ -1809,7 +1921,7 @@ else
 	link_args += ['-Wl,--version-script,@0@'.format(meson.current_build_dir() / vpx_def_name)]
 endif
 
-soversion = '8.0.0'
+soversion = '9.0.1'
 
 foreach arch, srcs : codec_arch_srcs
 	codec_arch_libs += static_library(
diff --git a/meson/parse_sources.py b/meson/parse_sources.py
index 5693aaddd..3b38eb2a5 100755
--- a/meson/parse_sources.py
+++ b/meson/parse_sources.py
@@ -80,8 +80,10 @@ def make_to_meson(target: str, paths: list[str]):
 				else:
 					continue
 
-				if not source_type or not component or not label:
+				if not component:
 					raise RuntimeError('Unspecified input file data was found')
+				elif not source_type:
+					print(f'Skipping {ofiles}')
 
 				accumulate = ofiles.endswith('\\')
 				ofiles = ofiles.strip('\\')
@@ -99,7 +101,7 @@ def make_to_meson(target: str, paths: list[str]):
 					component_sources[label] = component_sources.setdefault(label, list()) + accum + ifiles
 					accum = []
 
-			if not label:
+			if not label and accum:
 				raise RuntimeError('Unspecified component type')
 
 			# Makefiles can end with '\' and this is just a porting script ;)
@@ -145,7 +147,7 @@ def make_to_meson(target: str, paths: list[str]):
 					print ('Warning: skipping %s' % source)
 					continue
 				f.write(f"\t'{source}',\n")
-			f.write('{file_closing}\n\n')
+			f.write(f'{file_closing}\n\n')
 
 			f.write(f'{component}_{source_type}optional_sources = {{\n')
 			for label in sorted (component_sources):
diff --git a/test/meson.build b/test/meson.build
index 26a55d980..0c7319619 100644
--- a/test/meson.build
+++ b/test/meson.build
@@ -7,10 +7,10 @@
 
 libvpx_test_sources = files(
 	'bench.cc',
+	'init_vpx_test.cc',
 	'test_libvpx.cc',
-	'../md5_utils.c', # MANUAL
-	'../y4minput.c', # MANUAL
 	'test_vectors.cc',
+	'vpx_image_test.cc',
 	'decode_test_driver.cc',
 	# 'decode_perf_test.cc', # MANUAL
 	# 'encode_perf_test.cc', # MANUAL
@@ -41,10 +41,6 @@ libvpx_test_optional_sources = {
 	),
 	'encoders' : files(
 		'altref_test.cc',
-		'aq_segment_test.cc',
-		'alt_ref_aq_segment_test.cc',
-		'vp8_datarate_test.cc',
-		'vp9_datarate_test.cc',
 		'encode_api_test.cc',
 		'error_resilience_test.cc',
 		'realtime_test.cc',
@@ -74,6 +70,7 @@ libvpx_test_optional_sources = {
 		'config_test.cc',
 		'cq_test.cc',
 		'keyframe_test.cc',
+		'vp8_datarate_test.cc',
 		# 'quantize_test.cc', # MANUAL
 		# 'set_roi.cc', # MANUAL
 		# 'variance_test.cc', # MANUAL
@@ -91,6 +88,8 @@ libvpx_test_optional_sources = {
 	'vp9_encoder' : files(
 		'active_map_refresh_test.cc',
 		'active_map_test.cc',
+		'alt_ref_aq_segment_test.cc',
+		'aq_segment_test.cc',
 		'borders_test.cc',
 		'cpu_speed_test.cc',
 		'frame_size_tests.cc',
@@ -104,6 +103,7 @@ libvpx_test_optional_sources = {
 		'svc_test.cc',
 		'svc_end_to_end_test.cc',
 		'timestamp_test.cc',
+		'vp9_datarate_test.cc',
 		'vp9_ext_ratectrl_test.cc',
 		# 'avg_test.cc', # MANUAL
 		# 'comp_avg_pred_test.cc', # MANUAL
@@ -143,6 +143,7 @@ simple_encode_test_optional_sources = {
 
 test_intra_pred_speed_sources = files(
 	# 'test_intra_pred_speed.cc', # MANUAL
+	'init_vpx_test.cc',
 )
 
 test_intra_pred_speed_optional_sources = {
@@ -173,6 +174,7 @@ libvpx_test_headers_sources = files(
 	'codec_factory.h',
 	'md5_helper.h',
 	'register_state_check.h',
+	'init_vpx_test.h',
 	'test_vectors.h',
 	'util.h',
 	'video_source.h',
@@ -210,6 +212,13 @@ libwebm_parser_headers_sources = files(
 libwebm_parser_headers_optional_sources = {
 }
 
+test_intra_pred_speed_headers_sources = files(
+	'init_vpx_test.h',
+)
+
+test_intra_pred_speed_headers_optional_sources = {
+}
+
 rc_interface_test_headers_sources = files(
 	# 'decode_test_driver.h', # MANUAL
 	# 'codec_factory.h', # MANUAL
@@ -1095,6 +1104,7 @@ libvpx_test_data_data_optional_sources = {
 		'screendata.y4m',
 		'niklas_640_480_30.yuv',
 		'bus_352x288_420_f20_b8.yuv',
+		'crowd_run_360p_10_150f.y4m',
 		'niklas_1280_720_30.yuv',
 		'desktop_640_360_30.yuv',
 		'kirland_640_480_30.yuv',
@@ -1107,6 +1117,9 @@ libvpx_test_data_data_optional_sources = {
 	],
 }
 
+#### --- END GENERATED --- ####
+
+
 if features.get('webm_io', false) # MANUAL
 	libvpx_test_optional_sources += {
 		'decoders' : libvpx_test_optional_sources['decoders'] + files(
@@ -1432,8 +1445,6 @@ if features.get('encode_perf_tests', false)
 	}
 endif
 
-#### --- END GENERATED --- ####
-
 optional_sources = get_variable('libvpx_test_optional_sources', {})
 foreach comp_name, comp_sources : optional_sources
 	if features.get(comp_name, false)
diff --git a/third_party/libyuv/meson.build b/third_party/libyuv/meson.build
index 78af1b775..f9d07f901 100644
--- a/third_party/libyuv/meson.build
+++ b/third_party/libyuv/meson.build
@@ -2,6 +2,7 @@
 # SPDX-License-Identifier: BSD-3-Clause
 
 libyuv_includes = files(
+	'include/libyuv/basic_types.h',
 	'include/libyuv/convert.h',
 	'include/libyuv/convert_argb.h',
 	'include/libyuv/convert_from.h',
diff --git a/vp8/common/rtcd_defs.py b/vp8/common/rtcd_defs.py
index 4edaea4cd..0af078974 100755
--- a/vp8/common/rtcd_defs.py
+++ b/vp8/common/rtcd_defs.py
@@ -130,12 +130,6 @@ specialize(*qw('vp8_copy_mem8x4 mmx neon dspr2 msa mmi'))
 #
 if vpx_config("CONFIG_POSTPROC") == "yes":
 
-    add_proto(*qw('void vp8_blend_mb_inner'), "unsigned char *y, unsigned char *u, unsigned char *v, int y_1, int u_1, int v_1, int alpha, int stride")
-
-    add_proto(*qw('void vp8_blend_mb_outer'), "unsigned char *y, unsigned char *u, unsigned char *v, int y_1, int u_1, int v_1, int alpha, int stride")
-
-    add_proto(*qw('void vp8_blend_b'), "unsigned char *y, unsigned char *u, unsigned char *v, int y_1, int u_1, int v_1, int alpha, int stride")
-
     add_proto(*qw('void vp8_filter_by_weight16x16'), "unsigned char *src, int src_stride, unsigned char *dst, int dst_stride, int src_weight")
     specialize(*qw('vp8_filter_by_weight16x16 sse2 msa'))
 
@@ -220,14 +214,14 @@ if vpx_config("CONFIG_VP8_ENCODER") == "yes":
     #
     add_proto(*qw('int vp8_refining_search_sad'), "struct macroblock *x, struct block *b, struct blockd *d, union int_mv *ref_mv, int error_per_bit, int search_range, struct variance_vtable *fn_ptr, int *mvcost[2], union int_mv *center_mv")
     specialize(*qw('vp8_refining_search_sad sse2 msa'))
-    vp8_refining_search_sad_sse2='vp8_refining_search_sadx4';
-    vp8_refining_search_sad_msa='vp8_refining_search_sadx4';
+    vp8_refining_search_sad_sse2='vp8_refining_search_sadx4'
+    vp8_refining_search_sad_msa='vp8_refining_search_sadx4'
 
     add_proto(*qw('int vp8_diamond_search_sad'), "struct macroblock *x, struct block *b, struct blockd *d, union int_mv *ref_mv, union int_mv *best_mv, int search_param, int sad_per_bit, int *num00, struct variance_vtable *fn_ptr, int *mvcost[2], union int_mv *center_mv")
     specialize(*qw('vp8_diamond_search_sad sse2 msa lsx'))
-    vp8_diamond_search_sad_sse2='vp8_diamond_search_sadx4';
-    vp8_diamond_search_sad_msa='vp8_diamond_search_sadx4';
-    vp8_diamond_search_sad_lsx='vp8_diamond_search_sadx4';
+    vp8_diamond_search_sad_sse2='vp8_diamond_search_sadx4'
+    vp8_diamond_search_sad_msa='vp8_diamond_search_sadx4'
+    vp8_diamond_search_sad_lsx='vp8_diamond_search_sadx4'
 
     #
     # Alt-ref Noise Reduction (ARNR)
diff --git a/vp8/meson.build b/vp8/meson.build
index 647460ae4..a9790e613 100644
--- a/vp8/meson.build
+++ b/vp8/meson.build
@@ -327,6 +327,9 @@ vp8_dx_headers_optional_sources = {
 	),
 }
 
+vp8_common_asm_sources = files(
+)
+
 vp8_common_asm_optional_sources = {
 	'mmx' : files(
 		'common/x86/dequantize_mmx.asm',
@@ -348,6 +351,9 @@ vp8_common_asm_optional_sources = {
 	),
 }
 
+vp8_cx_asm_sources = files(
+)
+
 if features.get('postproc', false) # MANUAL
 	vp8_common_asm_optional_sources += {
 		'sse2': vp8_common_asm_optional_sources['sse2'] + files(
diff --git a/vp9/common/vp9_rtcd_defs.py b/vp9/common/vp9_rtcd_defs.py
index 41fdd120b..ad65ae649 100755
--- a/vp9/common/vp9_rtcd_defs.py
+++ b/vp9/common/vp9_rtcd_defs.py
@@ -27,7 +27,9 @@ struct macroblockd;
 
 /* Encoder forward decls */
 struct macroblock;
-struct vp9_variance_vtable;
+struct macroblock_plane;
+struct vp9_sad_table;
+struct ScanOrder;
 struct search_site_config;
 struct mv;
 union int_mv;
@@ -121,24 +123,21 @@ if vpx_config("CONFIG_VP9_ENCODER") == "yes":
     add_proto(*qw('int64_t vp9_block_error'), "const tran_low_t *coeff, const tran_low_t *dqcoeff, intptr_t block_size, int64_t *ssz")
 
     add_proto(*qw('int64_t vp9_block_error_fp'), "const tran_low_t *coeff, const tran_low_t *dqcoeff, int block_size")
+    specialize(*qw('vp9_block_error_fp neon avx2 sse2'))
 
-    add_proto(*qw('void vp9_quantize_fp'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *round_ptr, const int16_t *quant_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+    add_proto(*qw('void vp9_quantize_fp'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const struct macroblock_plane *const mb_plane, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const struct ScanOrder *const scan_order")
     specialize(*qw('vp9_quantize_fp neon sse2 ssse3 avx2 vsx'))
 
-    add_proto(*qw('void vp9_quantize_fp_32x32'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *round_ptr, const int16_t *quant_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+    add_proto(*qw('void vp9_quantize_fp_32x32'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const struct macroblock_plane *const mb_plane, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const struct ScanOrder *const scan_order")
     specialize(*qw('vp9_quantize_fp_32x32 neon ssse3 avx2 vsx'))
 
     if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
-        specialize(*qw('vp9_block_error avx2 sse2'))
-
-        specialize(*qw('vp9_block_error_fp avx2 sse2'))
+        specialize(*qw('vp9_block_error neon avx2 sse2'))
 
         add_proto(*qw('int64_t vp9_highbd_block_error'), "const tran_low_t *coeff, const tran_low_t *dqcoeff, intptr_t block_size, int64_t *ssz, int bd")
-        specialize(*qw('vp9_highbd_block_error sse2'))
+        specialize(*qw('vp9_highbd_block_error neon sse2'))
     else:
-        specialize(*qw('vp9_block_error avx2 msa sse2'))
-
-        specialize(*qw('vp9_block_error_fp neon avx2 sse2'))
+        specialize(*qw('vp9_block_error neon avx2 msa sse2'))
 
     # fdct functions
 
@@ -166,15 +165,15 @@ if vpx_config("CONFIG_VP9_ENCODER") == "yes":
     #
     # Motion search
     #
-    add_proto(*qw('int vp9_diamond_search_sad'), "const struct macroblock *x, const struct search_site_config *cfg,  struct mv *ref_mv, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_variance_vtable *fn_ptr, const struct mv *center_mv")
-    specialize(*qw('vp9_diamond_search_sad avx neon'))
+    add_proto(*qw('int vp9_diamond_search_sad'), "const struct macroblock *x, const struct search_site_config *cfg,  struct mv *ref_mv, uint32_t start_mv_sad, struct mv *best_mv, int search_param, int sad_per_bit, int *num00, const struct vp9_sad_table *sad_fn_ptr, const struct mv *center_mv")
+    specialize(*qw('vp9_diamond_search_sad neon'))
 
     #
     # Apply temporal filter
     #
     if vpx_config("CONFIG_REALTIME_ONLY") != "yes":
         add_proto(*qw('void vp9_apply_temporal_filter'), "const uint8_t *y_src, int y_src_stride, const uint8_t *y_pre, int y_pre_stride, const uint8_t *u_src, const uint8_t *v_src, int uv_src_stride, const uint8_t *u_pre, const uint8_t *v_pre, int uv_pre_stride, unsigned int block_width, unsigned int block_height, int ss_x, int ss_y, int strength, const int *const blk_fw, int use_32x32, uint32_t *y_accumulator, uint16_t *y_count, uint32_t *u_accumulator, uint16_t *u_count, uint32_t *v_accumulator, uint16_t *v_count")
-        specialize(*qw('vp9_apply_temporal_filter sse4_1'))
+        specialize(*qw('vp9_apply_temporal_filter sse4_1 neon'))
 
         if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
             add_proto(*qw('void vp9_highbd_apply_temporal_filter'), "const uint16_t *y_src, int y_src_stride, const uint16_t *y_pre, int y_pre_stride, const uint16_t *u_src, const uint16_t *v_src, int uv_src_stride, const uint16_t *u_pre, const uint16_t *v_pre, int uv_pre_stride, unsigned int block_width, unsigned int block_height, int ss_x, int ss_y, int strength, const int *const blk_fw, int use_32x32, uint32_t *y_accum, uint16_t *y_count, uint32_t *u_accum, uint16_t *u_count, uint32_t *v_accum, uint16_t *v_count")
@@ -184,10 +183,10 @@ if vpx_config("CONFIG_VP9_ENCODER") == "yes":
     if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
         # ENCODEMB INVOKE
 
-        add_proto(*qw('void vp9_highbd_quantize_fp'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *round_ptr, const int16_t *quant_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+        add_proto(*qw('void vp9_highbd_quantize_fp'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const struct macroblock_plane *const mb_plane, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const struct ScanOrder *const scan_order")
         specialize(*qw('vp9_highbd_quantize_fp avx2 neon'))
 
-        add_proto(*qw('void vp9_highbd_quantize_fp_32x32'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *round_ptr, const int16_t *quant_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan" )
+        add_proto(*qw('void vp9_highbd_quantize_fp_32x32'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const struct macroblock_plane *const mb_plane, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const struct ScanOrder *const scan_order")
         specialize(*qw('vp9_highbd_quantize_fp_32x32 avx2 neon'))
 
         # fdct functions
@@ -195,8 +194,10 @@ if vpx_config("CONFIG_VP9_ENCODER") == "yes":
         specialize(*qw('vp9_highbd_fht4x4 neon'))
 
         add_proto(*qw('void vp9_highbd_fht8x8'), "const int16_t *input, tran_low_t *output, int stride, int tx_type")
+        specialize(*qw('vp9_highbd_fht8x8 neon'))
 
         add_proto(*qw('void vp9_highbd_fht16x16'), "const int16_t *input, tran_low_t *output, int stride, int tx_type")
+        specialize(*qw('vp9_highbd_fht16x16 neon'))
 
         add_proto(*qw('void vp9_highbd_fwht4x4'), "const int16_t *input, tran_low_t *output, int stride")
 
@@ -211,4 +212,3 @@ if vpx_config("CONFIG_VP9_ENCODER") == "yes":
     specialize(*qw('vp9_scale_and_extend_frame neon ssse3'))
 
 # end encoder functions
-
diff --git a/vp9/meson.build b/vp9/meson.build
index 7b7619575..e9314966c 100644
--- a/vp9/meson.build
+++ b/vp9/meson.build
@@ -67,42 +67,6 @@ vp9_common_optional_sources = {
 	),
 }
 
-if not features.get('vp9_highbitdepth', false) # MANUAL
-	vp9_common_optional_sources += {
-		'msa': vp9_common_optional_sources['msa'] + files(
-			'common/mips/msa/vp9_idct4x4_msa.c',
-			'common/mips/msa/vp9_idct8x8_msa.c',
-			'common/mips/msa/vp9_idct16x16_msa.c',
-		),
-		'dspr2': vp9_common_optional_sources['dspr2'] + files(
-			'common/mips/dspr2/vp9_itrans4_dspr2.c',
-			'common/mips/dspr2/vp9_itrans8_dspr2.c',
-			'common/mips/dspr2/vp9_itrans16_dspr2.c'
-		)
-	}
-else
-	vp9_common_optional_sources += {
-		'neon': vp9_common_optional_sources['neon'] + files(
-			'common/arm/neon/vp9_highbd_iht4x4_add_neon.c',
-			'common/arm/neon/vp9_highbd_iht8x8_add_neon.c',
-			'common/arm/neon/vp9_highbd_iht16x16_add_neon.c'
-		),
-		'sse4_1': vp9_common_optional_sources['sse4_1'] + files(
-			'common/x86/vp9_highbd_iht4x4_add_sse4.c',
-			'common/x86/vp9_highbd_iht8x8_add_sse4.c',
-			'common/x86/vp9_highbd_iht16x16_add_sse4.c'
-		)
-	}
-endif
-
-if features.get('vp9_postproc', false) # MANUAL
-	vp9_common_optional_sources += {
-		'msa': vp9_common_optional_sources['msa'] + files(
-			'common/mips/msa/vp9_mfqe_msa.c'
-		)
-	}
-endif
-
 vp9_cx_sources = files(
 	'vp9_cx_iface.c',
 	'encoder/vp9_bitstream.c',
@@ -142,13 +106,11 @@ vp9_cx_sources = files(
 	'encoder/vp9_noise_estimate.c',
 	'encoder/vp9_ext_ratectrl.c',
 	# 'encoder/vp9_temporal_filter.c', # MANUAL
+	'encoder/vp9_tpl_model.c',
 	# 'encoder/vp9_mbgraph.c', # MANUAL
 )
 
 vp9_cx_optional_sources = {
-	'avx' : files(
-		'encoder/x86/vp9_diamond_search_sad_avx.c'
-	),
 	'avx2' : files(
 		'encoder/x86/vp9_quantize_avx2.c',
 		'encoder/x86/vp9_error_avx2.c'
@@ -164,12 +126,15 @@ vp9_cx_optional_sources = {
 		# 'encoder/mips/msa/vp9_fdct16x16_msa.c' # MANUAL
 	),
 	'neon' : files(
+		# 'encoder/arm/neon/vp9_temporal_filter_neon.c', # MANUAL
 		'encoder/arm/neon/vp9_diamond_search_sad_neon.c',
+		# 'encoder/arm/neon/vp9_highbd_temporal_filter_neon.c', # MANUAL
 		'encoder/arm/neon/vp9_dct_neon.c',
 		# 'encoder/arm/neon/vp9_denoiser_neon.c', # MANUAL
 		# 'encoder/arm/neon/vp9_error_neon.c', # MANUAL
 		'encoder/arm/neon/vp9_frame_scale_neon.c',
-		'encoder/arm/neon/vp9_quantize_neon.c'
+		'encoder/arm/neon/vp9_quantize_neon.c',
+		# 'encoder/arm/neon/vp9_highbd_error_neon.c', # MANUAL
 	),
 	'non_greedy_mv' : files(
 		'encoder/vp9_non_greedy_mv.c'
@@ -260,6 +225,7 @@ vp9_cx_headers_sources = files(
 	'encoder/vp9_encodemv.h',
 	'encoder/vp9_extend.h',
 	'encoder/vp9_firstpass.h',
+	'encoder/vp9_firstpass_stats.h',
 	'encoder/vp9_job_queue.h',
 	'encoder/vp9_lookahead.h',
 	'encoder/vp9_mcomp.h',
@@ -288,6 +254,7 @@ vp9_cx_headers_sources = files(
 	'encoder/vp9_noise_estimate.h',
 	'encoder/vp9_ext_ratectrl.h',
 	'encoder/vp9_temporal_filter.h',
+	'encoder/vp9_tpl_model.h',
 	'encoder/vp9_mbgraph.h',
 )
 
@@ -299,27 +266,20 @@ vp9_cx_headers_optional_sources = {
 	'msa' : files(
 		# 'encoder/mips/msa/vp9_fdct_msa.h' # MANUAL
 	),
+	'neon' : files(
+		# 'encoder/vp9_temporal_filter_constants.h' # MANUAL
+	),
 	'non_greedy_mv' : files(
 		'encoder/vp9_non_greedy_mv.h'
 	),
 	'sse4_1' : files(
-		# 'encoder/x86/temporal_filter_constants.h' # MANUAL
+		# 'encoder/vp9_temporal_filter_constants.h' # MANUAL
 	),
 	'vp9_temporal_denoising' : files(
 		'encoder/vp9_denoiser.h'
 	),
 }
 
-vp9_cx_remove_headers_optional_sources = {
-	'realtime_only' : files(
-		'encoder/x86/temporal_filter_constants.h',
-		'encoder/vp9_alt_ref_aq.h',
-		'encoder/vp9_aq_variance.h',
-		'encoder/vp9_aq_360.h',
-		'encoder/vp9_aq_complexity.h'
-	),
-}
-
 vp9_dx_headers_sources = files(
 	'vp9_dx_iface.h',
 	'decoder/vp9_decodeframe.h',
@@ -333,12 +293,27 @@ vp9_dx_headers_sources = files(
 vp9_dx_headers_optional_sources = {
 }
 
+vp9_common_asm_sources = files(
+)
+
 vp9_common_asm_optional_sources = {
 	'sse2' : files(
 		# 'common/x86/vp9_mfqe_sse2.asm' # MANUAL
 	),
 }
 
+vp9_cx_asm_sources = files(
+		)
+
+vp9_cx_asm_optional_sources = {
+	'sse2' : files(
+		'encoder/x86/vp9_dct_sse2.asm',
+		'encoder/x86/vp9_error_sse2.asm'
+	),
+}
+
+#### --- END GENERATED --- ####
+
 if features.get('vp9_postproc', false) # MANUAL
 	vp9_common_asm_optional_sources += {
 		'sse2': vp9_common_asm_optional_sources['sse2'] + files(
@@ -347,12 +322,41 @@ if features.get('vp9_postproc', false) # MANUAL
 	}
 endif
 
-vp9_cx_asm_optional_sources = {
-	'sse2' : files(
-		'encoder/x86/vp9_dct_sse2.asm',
-		'encoder/x86/vp9_error_sse2.asm'
-	),
-}
+if not features.get('vp9_highbitdepth', false) # MANUAL
+	vp9_common_optional_sources += {
+		'msa': vp9_common_optional_sources['msa'] + files(
+			'common/mips/msa/vp9_idct4x4_msa.c',
+			'common/mips/msa/vp9_idct8x8_msa.c',
+			'common/mips/msa/vp9_idct16x16_msa.c',
+		),
+		'dspr2': vp9_common_optional_sources['dspr2'] + files(
+			'common/mips/dspr2/vp9_itrans4_dspr2.c',
+			'common/mips/dspr2/vp9_itrans8_dspr2.c',
+			'common/mips/dspr2/vp9_itrans16_dspr2.c'
+		)
+	}
+else
+	vp9_common_optional_sources += {
+		'neon': vp9_common_optional_sources['neon'] + files(
+			'common/arm/neon/vp9_highbd_iht4x4_add_neon.c',
+			'common/arm/neon/vp9_highbd_iht8x8_add_neon.c',
+			'common/arm/neon/vp9_highbd_iht16x16_add_neon.c'
+		),
+		'sse4_1': vp9_common_optional_sources['sse4_1'] + files(
+			'common/x86/vp9_highbd_iht4x4_add_sse4.c',
+			'common/x86/vp9_highbd_iht8x8_add_sse4.c',
+			'common/x86/vp9_highbd_iht16x16_add_sse4.c'
+		)
+	}
+endif
+
+if features.get('vp9_postproc', false) # MANUAL
+	vp9_common_optional_sources += {
+		'msa': vp9_common_optional_sources['msa'] + files(
+			'common/mips/msa/vp9_mfqe_msa.c'
+		)
+	}
+endif
 
 if features.get('vp9_temporal_denoising', false)
 	vp9_cx_optional_sources += {
@@ -370,6 +374,9 @@ if features.get('vp9_highbitdepth', false)
 		'sse2' : vp9_cx_optional_sources['sse2'] + files(
 			'encoder/x86/vp9_highbd_block_error_intrin_sse2.c',
 		),
+		'neon': vp9_cx_optional_sources['neon'] + files(
+			'encoder/arm/neon/vp9_highbd_error_neon.c',
+		),
 	}
 else
 	vp9_cx_optional_sources += {
@@ -412,11 +419,17 @@ if not features.get('realtime_only', false)
 		'sse4_1' : vp9_cx_optional_sources['sse4_1'] + files(
 			'encoder/x86/temporal_filter_sse4.c',
 		),
+		'neon' : vp9_cx_optional_sources['neon'] + files(
+			'encoder/arm/neon/vp9_temporal_filter_neon.c',
+		),
 	}
 
 	vp9_cx_headers_optional_sources += {
 		'sse4_1' : vp9_cx_headers_optional_sources['sse4_1'] + files(
-			'encoder/x86/temporal_filter_constants.h'
+			'encoder/vp9_temporal_filter_constants.h'
+		),
+		'neon' : vp9_cx_headers_optional_sources['neon'] + files(
+			'encoder/vp9_temporal_filter_constants.h',
 		),
 	}
 
@@ -425,12 +438,13 @@ if not features.get('realtime_only', false)
 			'sse4_1' : vp9_cx_optional_sources['sse4_1'] + files(
 				'encoder/x86/highbd_temporal_filter_sse4.c',
 			),
+			'neon' : vp9_cx_optional_sources['neon'] + files(
+				'encoder/arm/neon/vp9_highbd_temporal_filter_neon.c',
+			),
 		}
 	endif
 endif
 
-#### --- END GENERATED --- ####
-
 codec_srcs += vp9_common_sources
 optional_sources = get_variable('vp9_common_optional_sources', {})
 foreach comp_name, comp_sources : optional_sources
diff --git a/vpx/meson.build b/vpx/meson.build
index 08f178d14..854e49f75 100644
--- a/vpx/meson.build
+++ b/vpx/meson.build
@@ -10,14 +10,15 @@ api_sources = files(
 	'src/vpx_encoder.c',
 	'src/vpx_codec.c',
 	'src/vpx_image.c',
+	'src/vpx_tpl.c',
 )
 
 api_optional_sources = {
 }
 
 api_headers_sources = files(
-	'vpx_decoder.h',
-	'vpx_encoder.h',
+	# 'vpx_decoder.h', # MANUAL
+	# 'vpx_encoder.h', # MANUAL
 	'internal/vpx_codec_internal.h',
 	'internal/vpx_ratectrl_rtc.h',
 	'vpx_codec.h',
@@ -25,9 +26,17 @@ api_headers_sources = files(
 	'vpx_image.h',
 	'vpx_integer.h',
 	'vpx_ext_ratectrl.h',
+	'vpx_tpl.h',
 )
 
 api_headers_optional_sources = {
+	'decoders': files( # MANUAL
+		'vpx_tpl.h',
+		'vpx_decoder.h',
+	),
+	'encoders': files( # MANUAL
+		'vpx_encoder.h',
+	),
 	'vp8_decoder' : files(
 		'vp8.h',
 		'vp8dx.h'
@@ -45,6 +54,7 @@ api_doc_headers_sources = files(
 	'vpx_ext_ratectrl.h',
 	'vpx_frame_buffer.h',
 	'vpx_image.h',
+	'vpx_tpl.h',
 )
 
 api_doc_headers_optional_sources = {
diff --git a/vpx_dsp/meson.build b/vpx_dsp/meson.build
index d8c83297c..c25458a7c 100644
--- a/vpx_dsp/meson.build
+++ b/vpx_dsp/meson.build
@@ -212,6 +212,8 @@ dsp_optional_sources = {
 		# 'arm/intrapred_neon_asm.asm', # MANUAL
 		# 'arm/save_reg_neon.asm' # MANUAL
 	),
+	'neon_dotprod' : files(), # MANUAL
+	'neon_i8mm' : files(), # MANUAL
 	'sse2' : files(
 		# 'x86/highbd_intrapred_intrin_sse2.c', # MANUAL
 		# 'x86/post_proc_sse2.c', # MANUAL
@@ -385,6 +387,7 @@ if features.get('encoders', false) # MANUAL
 		'bitwriter.c',
 		'bitwriter_buffer.c',
 		'psnr.c',
+		'sse.c',
 	)
 
 	dsp_headers_sources += files(
@@ -399,6 +402,18 @@ if features.get('encoders', false) # MANUAL
 			'psnrhvs.c',
 			'fastssim.c'
 		),
+		'neon' : dsp_optional_sources['neon'] + files(
+			'arm/sse_neon.c',
+		),
+		'neon_dotprod' : dsp_optional_sources['neon_dotprod'] + files(
+			'arm/sse_neon_dotprod.c',
+		),
+		'sse4_1' : dsp_optional_sources['sse4_1'] + files(
+			'x86/sse_sse4.c',
+		),
+		'avx2' : dsp_optional_sources['avx2'] + files(
+			'x86/sse_avx2.c',
+		),
 	}
 
 	dsp_headers_optional_sources += {
@@ -684,6 +699,16 @@ if features.get('vp9', false) # MANUAL
 			# loop filters
 			'arm/loopfilter_neon.c',
 		)
+		dsp_optional_sources += {
+			'neon_dotprod' : dsp_optional_sources['neon_dotprod'] + files(
+				'arm/vpx_convolve8_neon_dotprod.c',
+				'arm/vpx_convolve_neon_dotprod.c',
+			),
+			'neon_i8mm' : dsp_optional_sources['neon_i8mm'] + files(
+				'arm/vpx_convolve8_neon_i8mm.c',
+				'arm/vpx_convolve_neon_i8mm.c',
+			)
+		}
 	endif
 endif
 
@@ -718,6 +743,9 @@ if features.get('vp9_encoder', false)
 		'sse2' : dsp_optional_sources['sse2'] + files(
 			'x86/fwd_txfm_sse2.c',
 		),
+		'avx2': dsp_optional_sources['avx2'] + files(
+			'x86/inv_txfm_avx2.c',
+		),
 		'neon': dsp_optional_sources['neon'] + files(
 			'arm/fdct4x4_neon.c',
 			'arm/fdct8x8_neon.c',
@@ -744,7 +772,13 @@ if features.get('vp9_encoder', false)
 		}
 	endif
 
-	if not features.get('vp9_highbitdepth', false)
+	if features.get('vp9_highbitdepth', false)
+		dsp_optional_sources += {
+			'neon' : dsp_optional_sources['neon'] + files(
+				'arm/highbd_avg_neon.c'
+			),
+		}
+	else
 		dsp_optional_sources += {
 			'avx2' : dsp_optional_sources['avx2'] + files(
 				'x86/fwd_txfm_avx2.c'
@@ -979,6 +1013,8 @@ if features.get('vp9_encoder', false) # MANUAL
 			),
 			'neon' : dsp_optional_sources['neon'] + files(
 				'arm/highbd_quantize_neon.c',
+				'arm/highbd_hadamard_neon.c',
+				'arm/highbd_avg_neon.c',
 			),
 		}
 	endif
@@ -1007,6 +1043,10 @@ if features.get('encoders', false) # MANUAL
 			'arm/sad_neon.c',
 			'arm/subtract_neon.c',
 		),
+		'neon_dotprod' : dsp_optional_sources['neon_dotprod'] + files(
+			'arm/sad4d_neon_dotprod.c',
+			'arm/sad_neon_dotprod.c',
+		),
 		'sse2' : dsp_optional_sources['sse2'] + files(
 			'x86/sum_squares_sse2.c',
 		),
@@ -1059,7 +1099,9 @@ if features.get('encoders', false) # MANUAL
 				'x86/highbd_sad_avx2.c',
 			),
 			'neon' : dsp_optional_sources['neon'] + files(
+				'arm/highbd_sad4d_neon.c',
 				'arm/highbd_sad_neon.c',
+				'arm/highbd_subpel_variance_neon.c',
 			)
 		}
 	endif
@@ -1081,6 +1123,9 @@ if features.get('encoders', false) or features.get('postproc', false) or feature
 			'arm/subpel_variance_neon.c',
 			'arm/variance_neon.c',
 		),
+		'neon_dotprod' : dsp_optional_sources['neon_dotprod'] + files(
+			'arm/variance_neon_dotprod.c',
+		),
 		'msa' : dsp_optional_sources['msa'] + files(
 			'mips/variance_msa.c',
 			'mips/sub_pixel_variance_msa.c',
@@ -1098,6 +1143,7 @@ if features.get('encoders', false) or features.get('postproc', false) or feature
 			'x86/variance_sse2.c', # Contains SSE2 and SSSE3
 		),
 		'avx2' : dsp_optional_sources['avx2'] + files(
+			'x86/avg_pred_avx2.c',
 			'x86/variance_avx2.c',
 		),
 		'vsx' : dsp_optional_sources['vsx'] + files(
@@ -1140,6 +1186,8 @@ if features.get('encoders', false) or features.get('postproc', false) or feature
 				'x86/highbd_variance_sse2.c',
 			),
 			'neon' : dsp_optional_sources['neon'] + files(
+				'arm/highbd_avg_pred_neon.c',
+				'arm/highbd_sse_neon.c',
 				'arm/highbd_variance_neon.c',
 			)
 		}
diff --git a/vpx_dsp/vpx_dsp_rtcd_defs.py b/vpx_dsp/vpx_dsp_rtcd_defs.py
index 03974bebd..17ddfde35 100755
--- a/vpx_dsp/vpx_dsp_rtcd_defs.py
+++ b/vpx_dsp/vpx_dsp_rtcd_defs.py
@@ -21,6 +21,10 @@ def vpx_dsp_forward_decls():
 #include "vpx/vpx_integer.h"
 #include "vpx_dsp/vpx_dsp_common.h"
 #include "vpx_dsp/vpx_filter.h"
+#if CONFIG_VP9_ENCODER
+ struct macroblock_plane;
+ struct ScanOrder;
+#endif
 
 ''')
 forward_decls(*qw('vpx_dsp_forward_decls'))
@@ -40,7 +44,7 @@ if opts["arch"] == "x86_64":
 #
 
 add_proto(*qw('void vpx_d207_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
-specialize(*qw('vpx_d207_predictor_4x4 sse2'))
+specialize(*qw('vpx_d207_predictor_4x4 neon sse2'))
 
 add_proto(*qw('void vpx_d45_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_d45_predictor_4x4 neon sse2'))
@@ -48,7 +52,7 @@ specialize(*qw('vpx_d45_predictor_4x4 neon sse2'))
 add_proto(*qw('void vpx_d45e_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 
 add_proto(*qw('void vpx_d63_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
-specialize(*qw('vpx_d63_predictor_4x4 ssse3'))
+specialize(*qw('vpx_d63_predictor_4x4 neon ssse3'))
 
 add_proto(*qw('void vpx_d63e_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 
@@ -59,12 +63,13 @@ specialize(*qw('vpx_h_predictor_4x4 neon dspr2 msa sse2'))
 add_proto(*qw('void vpx_he_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 
 add_proto(*qw('void vpx_d117_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d117_predictor_4x4 neon'))
 
 add_proto(*qw('void vpx_d135_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_d135_predictor_4x4 neon'))
 
 add_proto(*qw('void vpx_d153_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
-specialize(*qw('vpx_d153_predictor_4x4 ssse3'))
+specialize(*qw('vpx_d153_predictor_4x4 neon ssse3'))
 
 add_proto(*qw('void vpx_v_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_v_predictor_4x4 neon msa sse2'))
@@ -88,7 +93,7 @@ add_proto(*qw('void vpx_dc_128_predictor_4x4'), "uint8_t *dst, ptrdiff_t stride,
 specialize(*qw('vpx_dc_128_predictor_4x4 msa neon sse2'))
 
 add_proto(*qw('void vpx_d207_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
-specialize(*qw('vpx_d207_predictor_8x8 ssse3'))
+specialize(*qw('vpx_d207_predictor_8x8 neon ssse3'))
 
 add_proto(*qw('void vpx_d45_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 # TODO(crbug.com/webm/1522): Re-enable vsx implementation.
@@ -96,19 +101,20 @@ specialize(*qw('vpx_d45_predictor_8x8 neon sse2'))
 
 add_proto(*qw('void vpx_d63_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 # TODO(crbug.com/webm/1522): Re-enable vsx implementation.
-specialize(*qw('vpx_d63_predictor_8x8 ssse3'))
+specialize(*qw('vpx_d63_predictor_8x8 neon ssse3'))
 
 add_proto(*qw('void vpx_h_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 # TODO(crbug.com/webm/1522): Re-enable vsx implementation.
 specialize(*qw('vpx_h_predictor_8x8 neon dspr2 msa sse2'))
 
 add_proto(*qw('void vpx_d117_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d117_predictor_8x8 neon'))
 
 add_proto(*qw('void vpx_d135_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_d135_predictor_8x8 neon'))
 
 add_proto(*qw('void vpx_d153_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
-specialize(*qw('vpx_d153_predictor_8x8 ssse3'))
+specialize(*qw('vpx_d153_predictor_8x8 neon ssse3'))
 
 add_proto(*qw('void vpx_v_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_v_predictor_8x8 neon msa sse2'))
@@ -131,24 +137,25 @@ add_proto(*qw('void vpx_dc_128_predictor_8x8'), "uint8_t *dst, ptrdiff_t stride,
 specialize(*qw('vpx_dc_128_predictor_8x8 neon msa sse2'))
 
 add_proto(*qw('void vpx_d207_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
-specialize(*qw('vpx_d207_predictor_16x16 ssse3'))
+specialize(*qw('vpx_d207_predictor_16x16 neon ssse3'))
 
 add_proto(*qw('void vpx_d45_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_d45_predictor_16x16 neon ssse3 vsx'))
 
 add_proto(*qw('void vpx_d63_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
-specialize(*qw('vpx_d63_predictor_16x16 ssse3 vsx'))
+specialize(*qw('vpx_d63_predictor_16x16 neon ssse3 vsx'))
 
 add_proto(*qw('void vpx_h_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_h_predictor_16x16 neon dspr2 msa sse2 vsx'))
 
 add_proto(*qw('void vpx_d117_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d117_predictor_16x16 neon'))
 
 add_proto(*qw('void vpx_d135_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_d135_predictor_16x16 neon'))
 
 add_proto(*qw('void vpx_d153_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
-specialize(*qw('vpx_d153_predictor_16x16 ssse3'))
+specialize(*qw('vpx_d153_predictor_16x16 neon ssse3'))
 
 add_proto(*qw('void vpx_v_predictor_16x16'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_v_predictor_16x16 neon msa sse2 vsx'))
@@ -169,24 +176,25 @@ add_proto(*qw('void vpx_dc_128_predictor_16x16'), "uint8_t *dst, ptrdiff_t strid
 specialize(*qw('vpx_dc_128_predictor_16x16 neon msa sse2 vsx'))
 
 add_proto(*qw('void vpx_d207_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
-specialize(*qw('vpx_d207_predictor_32x32 ssse3'))
+specialize(*qw('vpx_d207_predictor_32x32 neon ssse3'))
 
 add_proto(*qw('void vpx_d45_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_d45_predictor_32x32 neon ssse3 vsx'))
 
 add_proto(*qw('void vpx_d63_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
-specialize(*qw('vpx_d63_predictor_32x32 ssse3 vsx'))
+specialize(*qw('vpx_d63_predictor_32x32 neon ssse3 vsx'))
 
 add_proto(*qw('void vpx_h_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_h_predictor_32x32 neon msa sse2 vsx'))
 
 add_proto(*qw('void vpx_d117_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
+specialize(*qw('vpx_d117_predictor_32x32 neon'))
 
 add_proto(*qw('void vpx_d135_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_d135_predictor_32x32 neon'))
 
 add_proto(*qw('void vpx_d153_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
-specialize(*qw('vpx_d153_predictor_32x32 ssse3'))
+specialize(*qw('vpx_d153_predictor_32x32 neon ssse3'))
 
 add_proto(*qw('void vpx_v_predictor_32x32'), "uint8_t *dst, ptrdiff_t stride, const uint8_t *above, const uint8_t *left")
 specialize(*qw('vpx_v_predictor_32x32 neon msa sse2 vsx'))
@@ -209,25 +217,25 @@ specialize(*qw('vpx_dc_128_predictor_32x32 msa neon sse2 vsx'))
 # High bitdepth functions
 if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
     add_proto(*qw('void vpx_highbd_d207_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d207_predictor_4x4 sse2'))
+    specialize(*qw('vpx_highbd_d207_predictor_4x4 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_d45_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_d45_predictor_4x4 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d63_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d63_predictor_4x4 sse2'))
+    specialize(*qw('vpx_highbd_d63_predictor_4x4 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_h_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_h_predictor_4x4 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_d117_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d117_predictor_4x4 sse2'))
+    specialize(*qw('vpx_highbd_d117_predictor_4x4 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_d135_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_d135_predictor_4x4 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_d153_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d153_predictor_4x4 sse2'))
+    specialize(*qw('vpx_highbd_d153_predictor_4x4 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_v_predictor_4x4'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_v_predictor_4x4 neon sse2'))
@@ -248,25 +256,25 @@ if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
     specialize(*qw('vpx_highbd_dc_128_predictor_4x4 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_d207_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d207_predictor_8x8 ssse3'))
+    specialize(*qw('vpx_highbd_d207_predictor_8x8 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d45_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_d45_predictor_8x8 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d63_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d63_predictor_8x8 ssse3'))
+    specialize(*qw('vpx_highbd_d63_predictor_8x8 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_h_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_h_predictor_8x8 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_d117_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d117_predictor_8x8 ssse3'))
+    specialize(*qw('vpx_highbd_d117_predictor_8x8 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d135_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_d135_predictor_8x8 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d153_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d153_predictor_8x8 ssse3'))
+    specialize(*qw('vpx_highbd_d153_predictor_8x8 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_v_predictor_8x8'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_v_predictor_8x8 neon sse2'))
@@ -287,25 +295,25 @@ if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
     specialize(*qw('vpx_highbd_dc_128_predictor_8x8 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_d207_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d207_predictor_16x16 ssse3'))
+    specialize(*qw('vpx_highbd_d207_predictor_16x16 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d45_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_d45_predictor_16x16 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d63_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d63_predictor_16x16 ssse3'))
+    specialize(*qw('vpx_highbd_d63_predictor_16x16 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_h_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_h_predictor_16x16 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_d117_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d117_predictor_16x16 ssse3'))
+    specialize(*qw('vpx_highbd_d117_predictor_16x16 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d135_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_d135_predictor_16x16 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d153_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d153_predictor_16x16 ssse3'))
+    specialize(*qw('vpx_highbd_d153_predictor_16x16 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_v_predictor_16x16'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_v_predictor_16x16 neon sse2'))
@@ -326,25 +334,25 @@ if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
     specialize(*qw('vpx_highbd_dc_128_predictor_16x16 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_d207_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d207_predictor_32x32 ssse3'))
+    specialize(*qw('vpx_highbd_d207_predictor_32x32 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d45_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_d45_predictor_32x32 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d63_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d63_predictor_32x32 ssse3'))
+    specialize(*qw('vpx_highbd_d63_predictor_32x32 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_h_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_h_predictor_32x32 neon sse2'))
 
     add_proto(*qw('void vpx_highbd_d117_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d117_predictor_32x32 ssse3'))
+    specialize(*qw('vpx_highbd_d117_predictor_32x32 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d135_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_d135_predictor_32x32 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_d153_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
-    specialize(*qw('vpx_highbd_d153_predictor_32x32 ssse3'))
+    specialize(*qw('vpx_highbd_d153_predictor_32x32 neon ssse3'))
 
     add_proto(*qw('void vpx_highbd_v_predictor_32x32'), "uint16_t *dst, ptrdiff_t stride, const uint16_t *above, const uint16_t *left, int bd")
     specialize(*qw('vpx_highbd_v_predictor_32x32 neon sse2'))
@@ -376,22 +384,22 @@ if vpx_config("CONFIG_VP9") == "yes":
     specialize(*qw('vpx_convolve_avg neon dspr2 msa sse2 vsx mmi lsx'))
 
     add_proto(*qw('void vpx_convolve8'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
-    specialize(*qw('vpx_convolve8 sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+    specialize(*qw('vpx_convolve8 sse2 ssse3 avx2 neon neon_dotprod neon_i8mm dspr2 msa vsx mmi lsx'))
 
     add_proto(*qw('void vpx_convolve8_horiz'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
-    specialize(*qw('vpx_convolve8_horiz sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+    specialize(*qw('vpx_convolve8_horiz sse2 ssse3 avx2 neon neon_dotprod neon_i8mm dspr2 msa vsx mmi lsx'))
 
     add_proto(*qw('void vpx_convolve8_vert'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
-    specialize(*qw('vpx_convolve8_vert sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+    specialize(*qw('vpx_convolve8_vert sse2 ssse3 avx2 neon neon_dotprod neon_i8mm dspr2 msa vsx mmi lsx'))
 
     add_proto(*qw('void vpx_convolve8_avg'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
-    specialize(*qw('vpx_convolve8_avg sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+    specialize(*qw('vpx_convolve8_avg sse2 ssse3 avx2 neon neon_dotprod neon_i8mm dspr2 msa vsx mmi lsx'))
 
     add_proto(*qw('void vpx_convolve8_avg_horiz'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
-    specialize(*qw('vpx_convolve8_avg_horiz sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+    specialize(*qw('vpx_convolve8_avg_horiz sse2 ssse3 avx2 neon neon_dotprod neon_i8mm dspr2 msa vsx mmi lsx'))
 
     add_proto(*qw('void vpx_convolve8_avg_vert'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
-    specialize(*qw('vpx_convolve8_avg_vert sse2 ssse3 avx2 neon dspr2 msa vsx mmi lsx'))
+    specialize(*qw('vpx_convolve8_avg_vert sse2 ssse3 avx2 neon neon_dotprod neon_i8mm dspr2 msa vsx mmi lsx'))
 
     add_proto(*qw('void vpx_scaled_2d'), "const uint8_t *src, ptrdiff_t src_stride, uint8_t *dst, ptrdiff_t dst_stride, const InterpKernel *filter, int x0_q4, int x_step_q4, int y0_q4, int y_step_q4, int w, int h")
     specialize(*qw('vpx_scaled_2d ssse3 neon msa'))
@@ -591,7 +599,7 @@ if vpx_config("CONFIG_VP9_ENCODER") == "yes":
         specialize(*qw('vpx_fdct8x8_1 sse2 neon msa'))
 
         add_proto(*qw('void vpx_fdct16x16'), "const int16_t *input, tran_low_t *output, int stride")
-        specialize(*qw('vpx_fdct16x16 neon sse2 msa lsx'))
+        specialize(*qw('vpx_fdct16x16 neon sse2 avx2 msa lsx'))
 
         add_proto(*qw('void vpx_fdct16x16_1'), "const int16_t *input, tran_low_t *output, int stride")
         specialize(*qw('vpx_fdct16x16_1 sse2 neon msa'))
@@ -635,12 +643,12 @@ if vpx_config("CONFIG_VP9") == "yes":
         specialize(*qw('vpx_idct8x8_64_add neon sse2 vsx'))
         specialize(*qw('vpx_idct8x8_12_add neon sse2 ssse3'))
         specialize(*qw('vpx_idct8x8_1_add neon sse2'))
-        specialize(*qw('vpx_idct16x16_256_add neon sse2 vsx'))
+        specialize(*qw('vpx_idct16x16_256_add neon sse2 avx2 vsx'))
         specialize(*qw('vpx_idct16x16_38_add neon sse2'))
         specialize(*qw('vpx_idct16x16_10_add neon sse2'))
         specialize(*qw('vpx_idct16x16_1_add neon sse2'))
-        specialize(*qw('vpx_idct32x32_1024_add neon sse2 vsx'))
-        specialize(*qw('vpx_idct32x32_135_add neon sse2 ssse3'))
+        specialize(*qw('vpx_idct32x32_1024_add neon sse2 avx2 vsx'))
+        specialize(*qw('vpx_idct32x32_135_add neon sse2 ssse3 avx2'))
         specialize(*qw('vpx_idct32x32_34_add neon sse2 ssse3'))
         specialize(*qw('vpx_idct32x32_1_add neon sse2'))
         specialize(*qw('vpx_iwht4x4_16_add sse2 vsx'))
@@ -716,17 +724,17 @@ if vpx_config("CONFIG_VP9") == "yes":
 # Quantization
 #
 if vpx_config("CONFIG_VP9_ENCODER") == "yes":
-    add_proto(*qw('void vpx_quantize_b'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+    add_proto(*qw('void vpx_quantize_b'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const struct macroblock_plane *const mb_plane, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const struct ScanOrder *const scan_order")
     specialize(*qw('vpx_quantize_b neon sse2 ssse3 avx avx2 vsx lsx'))
 
-    add_proto(*qw('void vpx_quantize_b_32x32'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+    add_proto(*qw('void vpx_quantize_b_32x32'), "const tran_low_t *coeff_ptr, const struct macroblock_plane *const mb_plane, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const struct ScanOrder *const scan_order")
     specialize(*qw('vpx_quantize_b_32x32 neon ssse3 avx avx2 vsx lsx'))
 
     if vpx_config("CONFIG_VP9_HIGHBITDEPTH") == "yes":
-        add_proto(*qw('void vpx_highbd_quantize_b'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+        add_proto(*qw('void vpx_highbd_quantize_b'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const struct macroblock_plane *const mb_plane, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const struct ScanOrder *const scan_order")
         specialize(*qw('vpx_highbd_quantize_b neon sse2 avx2'))
 
-        add_proto(*qw('void vpx_highbd_quantize_b_32x32'), "const tran_low_t *coeff_ptr, intptr_t n_coeffs, const int16_t *zbin_ptr, const int16_t *round_ptr, const int16_t *quant_ptr, const int16_t *quant_shift_ptr, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const int16_t *scan, const int16_t *iscan")
+        add_proto(*qw('void vpx_highbd_quantize_b_32x32'), "const tran_low_t *coeff_ptr, const struct macroblock_plane *const mb_plane, tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr, const int16_t *dequant_ptr, uint16_t *eob_ptr, const struct ScanOrder *const scan_order")
         specialize(*qw('vpx_highbd_quantize_b_32x32 neon sse2 avx2'))
         # CONFIG_VP9_HIGHBITDEPTH
     # CONFIG_VP9_ENCODER
@@ -738,32 +746,35 @@ if vpx_config("CONFIG_ENCODERS") == "yes":
     add_proto(*qw('void vpx_subtract_block'), "int rows, int cols, int16_t *diff_ptr, ptrdiff_t diff_stride, const uint8_t *src_ptr, ptrdiff_t src_stride, const uint8_t *pred_ptr, ptrdiff_t pred_stride")
     specialize(*qw('vpx_subtract_block neon msa mmi sse2 avx2 vsx lsx'))
 
+    add_proto(*qw('int64_t'), "vpx_sse", "const uint8_t *src, int src_stride, const uint8_t *ref, int ref_stride, int width, int height")
+    specialize(*qw('vpx_sse sse4_1 avx2 neon neon_dotprod'))
+
     #
     # Single block SAD
     #
     add_proto(*qw('unsigned int vpx_sad64x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
-    specialize(*qw('vpx_sad64x64 neon avx2 msa sse2 vsx mmi lsx'))
+    specialize(*qw('vpx_sad64x64 neon neon_dotprod avx2 msa sse2 vsx mmi lsx'))
 
     add_proto(*qw('unsigned int vpx_sad64x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
-    specialize(*qw('vpx_sad64x32 neon avx2 msa sse2 vsx mmi'))
+    specialize(*qw('vpx_sad64x32 neon neon_dotprod avx2 msa sse2 vsx mmi'))
 
     add_proto(*qw('unsigned int vpx_sad32x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
-    specialize(*qw('vpx_sad32x64 neon avx2 msa sse2 vsx mmi'))
+    specialize(*qw('vpx_sad32x64 neon neon_dotprod avx2 msa sse2 vsx mmi'))
 
     add_proto(*qw('unsigned int vpx_sad32x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
-    specialize(*qw('vpx_sad32x32 neon avx2 msa sse2 vsx mmi lsx'))
+    specialize(*qw('vpx_sad32x32 neon neon_dotprod avx2 msa sse2 vsx mmi lsx'))
 
     add_proto(*qw('unsigned int vpx_sad32x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
-    specialize(*qw('vpx_sad32x16 neon avx2 msa sse2 vsx mmi'))
+    specialize(*qw('vpx_sad32x16 neon neon_dotprod avx2 msa sse2 vsx mmi'))
 
     add_proto(*qw('unsigned int vpx_sad16x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
-    specialize(*qw('vpx_sad16x32 neon msa sse2 vsx mmi'))
+    specialize(*qw('vpx_sad16x32 neon neon_dotprod msa sse2 vsx mmi'))
 
     add_proto(*qw('unsigned int vpx_sad16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
-    specialize(*qw('vpx_sad16x16 neon msa sse2 vsx mmi lsx'))
+    specialize(*qw('vpx_sad16x16 neon neon_dotprod msa sse2 vsx mmi lsx'))
 
     add_proto(*qw('unsigned int vpx_sad16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
-    specialize(*qw('vpx_sad16x8 neon msa sse2 vsx mmi'))
+    specialize(*qw('vpx_sad16x8 neon neon_dotprod msa sse2 vsx mmi'))
 
     add_proto(*qw('unsigned int vpx_sad8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
     specialize(*qw('vpx_sad8x16 neon msa sse2 vsx mmi'))
@@ -780,6 +791,45 @@ if vpx_config("CONFIG_ENCODERS") == "yes":
     add_proto(*qw('unsigned int vpx_sad4x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
     specialize(*qw('vpx_sad4x4 neon msa sse2 mmi'))
 
+    add_proto(*qw('unsigned int vpx_sad_skip_64x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_64x64 neon neon_dotprod avx2 sse2'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_64x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_64x32 neon neon_dotprod avx2 sse2'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_32x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_32x64 neon neon_dotprod avx2 sse2'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_32x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_32x32 neon neon_dotprod avx2 sse2'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_32x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_32x16 neon neon_dotprod avx2 sse2'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_16x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_16x32 neon neon_dotprod sse2'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_16x16 neon neon_dotprod sse2'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_16x8 neon neon_dotprod sse2'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_8x16 neon sse2'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_8x8 neon sse2'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_8x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_8x4 neon'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_4x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_4x8 neon sse2'))
+
+    add_proto(*qw('unsigned int vpx_sad_skip_4x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+    specialize(*qw('vpx_sad_skip_4x4 neon'))
+
     #
     # Avg
     #
@@ -804,19 +854,19 @@ if vpx_config("CONFIG_ENCODERS") == "yes":
             specialize(*qw('vpx_hadamard_32x32 sse2 avx2 neon'))
 
             add_proto(*qw('void vpx_highbd_hadamard_8x8'), "const int16_t *src_diff, ptrdiff_t src_stride, tran_low_t *coeff")
-            specialize(*qw('vpx_highbd_hadamard_8x8 avx2'))
+            specialize(*qw('vpx_highbd_hadamard_8x8 avx2 neon'))
 
             add_proto(*qw('void vpx_highbd_hadamard_16x16'), "const int16_t *src_diff, ptrdiff_t src_stride, tran_low_t *coeff")
-            specialize(*qw('vpx_highbd_hadamard_16x16 avx2'))
+            specialize(*qw('vpx_highbd_hadamard_16x16 avx2 neon'))
 
             add_proto(*qw('void vpx_highbd_hadamard_32x32'), "const int16_t *src_diff, ptrdiff_t src_stride, tran_low_t *coeff")
-            specialize(*qw('vpx_highbd_hadamard_32x32 avx2'))
+            specialize(*qw('vpx_highbd_hadamard_32x32 avx2 neon'))
 
             add_proto(*qw('int vpx_satd'), "const tran_low_t *coeff, int length")
             specialize(*qw('vpx_satd avx2 sse2 neon'))
 
             add_proto(*qw('int vpx_highbd_satd'), "const tran_low_t *coeff, int length")
-            specialize(*qw('vpx_highbd_satd avx2'))
+            specialize(*qw('vpx_highbd_satd avx2 neon'))
         else:
             add_proto(*qw('void vpx_hadamard_8x8'), "const int16_t *src_diff, ptrdiff_t src_stride, int16_t *coeff")
             specialize(*qw('vpx_hadamard_8x8 sse2 neon msa vsx lsx'), f"{ssse3_x86_64}")
@@ -832,38 +882,37 @@ if vpx_config("CONFIG_ENCODERS") == "yes":
 
 
         add_proto(*qw('void vpx_int_pro_row'), "int16_t hbuf[16], const uint8_t *ref, const int ref_stride, const int height")
-        specialize(*qw('vpx_int_pro_row sse2 neon msa'))
-
+        specialize(*qw('vpx_int_pro_row neon sse2 msa'))
         add_proto(*qw('int16_t vpx_int_pro_col'), "const uint8_t *ref, const int width")
-        specialize(*qw('vpx_int_pro_col sse2 neon msa'))
+        specialize(*qw('vpx_int_pro_col neon sse2 msa'))
 
         add_proto(*qw('int vpx_vector_var'), "const int16_t *ref, const int16_t *src, const int bwl")
         specialize(*qw('vpx_vector_var neon sse2 msa'))
         # CONFIG_VP9_ENCODER
 
     add_proto(*qw('unsigned int vpx_sad64x64_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
-    specialize(*qw('vpx_sad64x64_avg neon avx2 msa sse2 vsx mmi lsx'))
+    specialize(*qw('vpx_sad64x64_avg neon neon_dotprod avx2 msa sse2 vsx mmi lsx'))
 
     add_proto(*qw('unsigned int vpx_sad64x32_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
-    specialize(*qw('vpx_sad64x32_avg neon avx2 msa sse2 vsx mmi'))
+    specialize(*qw('vpx_sad64x32_avg neon neon_dotprod avx2 msa sse2 vsx mmi'))
 
     add_proto(*qw('unsigned int vpx_sad32x64_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
-    specialize(*qw('vpx_sad32x64_avg neon avx2 msa sse2 vsx mmi'))
+    specialize(*qw('vpx_sad32x64_avg neon neon_dotprod avx2 msa sse2 vsx mmi'))
 
     add_proto(*qw('unsigned int vpx_sad32x32_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
-    specialize(*qw('vpx_sad32x32_avg neon avx2 msa sse2 vsx mmi lsx'))
+    specialize(*qw('vpx_sad32x32_avg neon neon_dotprod avx2 msa sse2 vsx mmi lsx'))
 
     add_proto(*qw('unsigned int vpx_sad32x16_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
-    specialize(*qw('vpx_sad32x16_avg neon avx2 msa sse2 vsx mmi'))
+    specialize(*qw('vpx_sad32x16_avg neon neon_dotprod avx2 msa sse2 vsx mmi'))
 
     add_proto(*qw('unsigned int vpx_sad16x32_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
-    specialize(*qw('vpx_sad16x32_avg neon msa sse2 vsx mmi'))
+    specialize(*qw('vpx_sad16x32_avg neon neon_dotprod msa sse2 vsx mmi'))
 
     add_proto(*qw('unsigned int vpx_sad16x16_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
-    specialize(*qw('vpx_sad16x16_avg neon msa sse2 vsx mmi'))
+    specialize(*qw('vpx_sad16x16_avg neon neon_dotprod msa sse2 vsx mmi'))
 
     add_proto(*qw('unsigned int vpx_sad16x8_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
-    specialize(*qw('vpx_sad16x8_avg neon msa sse2 vsx mmi'))
+    specialize(*qw('vpx_sad16x8_avg neon neon_dotprod msa sse2 vsx mmi'))
 
     add_proto(*qw('unsigned int vpx_sad8x16_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
     specialize(*qw('vpx_sad8x16_avg neon msa sse2 mmi'))
@@ -883,45 +932,84 @@ if vpx_config("CONFIG_ENCODERS") == "yes":
     #
     # Multi-block SAD, comparing a reference to N independent blocks
     #
-    add_proto(*qw('void vpx_sad64x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
-    specialize(*qw('vpx_sad64x64x4d avx512 avx2 neon msa sse2 vsx mmi lsx'))
+    add_proto(*qw('void vpx_sad64x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad64x64x4d avx512 avx2 neon neon_dotprod msa sse2 vsx mmi lsx'))
 
-    add_proto(*qw('void vpx_sad64x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
-    specialize(*qw('vpx_sad64x32x4d neon msa sse2 vsx mmi lsx'))
+    add_proto(*qw('void vpx_sad64x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad64x32x4d neon neon_dotprod msa sse2 vsx mmi lsx'))
 
-    add_proto(*qw('void vpx_sad32x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
-    specialize(*qw('vpx_sad32x64x4d neon msa sse2 vsx mmi lsx'))
+    add_proto(*qw('void vpx_sad32x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad32x64x4d neon neon_dotprod msa sse2 vsx mmi lsx'))
 
-    add_proto(*qw('void vpx_sad32x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
-    specialize(*qw('vpx_sad32x32x4d avx2 neon msa sse2 vsx mmi lsx'))
+    add_proto(*qw('void vpx_sad32x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad32x32x4d avx2 neon neon_dotprod msa sse2 vsx mmi lsx'))
 
-    add_proto(*qw('void vpx_sad32x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
-    specialize(*qw('vpx_sad32x16x4d neon msa sse2 vsx mmi'))
+    add_proto(*qw('void vpx_sad32x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad32x16x4d neon neon_dotprod msa sse2 vsx mmi'))
 
-    add_proto(*qw('void vpx_sad16x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
-    specialize(*qw('vpx_sad16x32x4d neon msa sse2 vsx mmi'))
+    add_proto(*qw('void vpx_sad16x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad16x32x4d neon neon_dotprod msa sse2 vsx mmi'))
 
-    add_proto(*qw('void vpx_sad16x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
-    specialize(*qw('vpx_sad16x16x4d neon msa sse2 vsx mmi lsx'))
+    add_proto(*qw('void vpx_sad16x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad16x16x4d neon neon_dotprod msa sse2 vsx mmi lsx'))
 
-    add_proto(*qw('void vpx_sad16x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
-    specialize(*qw('vpx_sad16x8x4d neon msa sse2 vsx mmi'))
+    add_proto(*qw('void vpx_sad16x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad16x8x4d neon neon_dotprod msa sse2 vsx mmi'))
 
-    add_proto(*qw('void vpx_sad8x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    add_proto(*qw('void vpx_sad8x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
     specialize(*qw('vpx_sad8x16x4d neon msa sse2 mmi'))
 
-    add_proto(*qw('void vpx_sad8x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    add_proto(*qw('void vpx_sad8x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
     specialize(*qw('vpx_sad8x8x4d neon msa sse2 mmi lsx'))
 
-    add_proto(*qw('void vpx_sad8x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    add_proto(*qw('void vpx_sad8x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
     specialize(*qw('vpx_sad8x4x4d neon msa sse2 mmi'))
 
-    add_proto(*qw('void vpx_sad4x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    add_proto(*qw('void vpx_sad4x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
     specialize(*qw('vpx_sad4x8x4d neon msa sse2 mmi'))
 
-    add_proto(*qw('void vpx_sad4x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t * const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    add_proto(*qw('void vpx_sad4x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
     specialize(*qw('vpx_sad4x4x4d neon msa sse2 mmi'))
 
+    add_proto(*qw('void vpx_sad_skip_64x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_64x64x4d neon neon_dotprod avx2 sse2'))
+
+    add_proto(*qw('void vpx_sad_skip_64x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_64x32x4d neon neon_dotprod avx2 sse2'))
+
+    add_proto(*qw('void vpx_sad_skip_32x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_32x64x4d neon neon_dotprod avx2 sse2'))
+
+    add_proto(*qw('void vpx_sad_skip_32x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_32x32x4d neon neon_dotprod avx2 sse2'))
+
+    add_proto(*qw('void vpx_sad_skip_32x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_32x16x4d neon neon_dotprod avx2 sse2'))
+
+    add_proto(*qw('void vpx_sad_skip_16x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_16x32x4d neon neon_dotprod sse2'))
+
+    add_proto(*qw('void vpx_sad_skip_16x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_16x16x4d neon neon_dotprod sse2'))
+
+    add_proto(*qw('void vpx_sad_skip_16x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_16x8x4d neon neon_dotprod sse2'))
+
+    add_proto(*qw('void vpx_sad_skip_8x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_8x16x4d neon sse2'))
+
+    add_proto(*qw('void vpx_sad_skip_8x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_8x8x4d neon sse2'))
+
+    add_proto(*qw('void vpx_sad_skip_8x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_8x4x4d neon'))
+
+    add_proto(*qw('void vpx_sad_skip_4x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_4x8x4d neon sse2'))
+
+    add_proto(*qw('void vpx_sad_skip_4x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+    specialize(*qw('vpx_sad_skip_4x4x4d neon'))
+
     add_proto(*qw('uint64_t vpx_sum_squares_2d_i16'), "const int16_t *src, int stride, int size")
     specialize(*qw('vpx_sum_squares_2d_i16 neon sse2 msa'))
 
@@ -942,6 +1030,9 @@ if vpx_config("CONFIG_ENCODERS") == "yes":
         add_proto(*qw('void vpx_highbd_subtract_block'), "int rows, int cols, int16_t *diff_ptr, ptrdiff_t diff_stride, const uint8_t *src8_ptr, ptrdiff_t src_stride, const uint8_t *pred8_ptr, ptrdiff_t pred_stride, int bd")
         specialize(*qw('vpx_highbd_subtract_block neon avx2'))
 
+        add_proto(*qw('int64_t'), "vpx_highbd_sse", "const uint8_t *a8, int a_stride, const uint8_t *b8,int b_stride, int width, int height")
+        specialize(*qw('vpx_highbd_sse sse4_1 avx2 neon'))
+
         #
         # Single block SAD
         #
@@ -984,16 +1075,56 @@ if vpx_config("CONFIG_ENCODERS") == "yes":
         add_proto(*qw('unsigned int vpx_highbd_sad4x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
         specialize(*qw('vpx_highbd_sad4x4 neon'))
 
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_64x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_64x64 neon sse2 avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_64x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_64x32 neon sse2 avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_32x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_32x64 neon sse2 avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_32x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_32x32 neon sse2 avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_32x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_32x16 neon sse2 avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_16x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_16x32 neon sse2 avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_16x16 neon sse2 avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_16x8 neon sse2 avx2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_8x16 neon sse2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_8x8 neon sse2'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_8x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_8x4 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_4x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_4x8 neon'))
+
+        add_proto(*qw('unsigned int vpx_highbd_sad_skip_4x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride")
+        specialize(*qw('vpx_highbd_sad_skip_4x4 neon'))
+
         #
         # Avg
         #
         add_proto(*qw('unsigned int vpx_highbd_avg_8x8'), "const uint8_t *s8, int p")
-        specialize(*qw('vpx_highbd_avg_8x8 sse2'))
+        specialize(*qw('vpx_highbd_avg_8x8 sse2 neon'))
 
         add_proto(*qw('unsigned int vpx_highbd_avg_4x4'), "const uint8_t *s8, int p")
-        specialize(*qw('vpx_highbd_avg_4x4 sse2'))
+        specialize(*qw('vpx_highbd_avg_4x4 sse2 neon'))
 
         add_proto(*qw('void vpx_highbd_minmax_8x8'), "const uint8_t *s8, int p, const uint8_t *d8, int dp, int *min, int *max")
+        specialize(*qw('vpx_highbd_minmax_8x8 neon'))
 
         add_proto(*qw('unsigned int vpx_highbd_sad64x64_avg'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, const uint8_t *second_pred")
         specialize(*qw('vpx_highbd_sad64x64_avg sse2 neon avx2'))
@@ -1037,45 +1168,84 @@ if vpx_config("CONFIG_ENCODERS") == "yes":
         #
         # Multi-block SAD, comparing a reference to N independent blocks
         #
-        add_proto(*qw('void vpx_highbd_sad64x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad64x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad64x64x4d sse2 neon avx2'))
 
-        add_proto(*qw('void vpx_highbd_sad64x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad64x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad64x32x4d sse2 neon avx2'))
 
-        add_proto(*qw('void vpx_highbd_sad32x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad32x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad32x64x4d sse2 neon avx2'))
 
-        add_proto(*qw('void vpx_highbd_sad32x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad32x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad32x32x4d sse2 neon avx2'))
 
-        add_proto(*qw('void vpx_highbd_sad32x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad32x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad32x16x4d sse2 neon avx2'))
 
-        add_proto(*qw('void vpx_highbd_sad16x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad16x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad16x32x4d sse2 neon avx2'))
 
-        add_proto(*qw('void vpx_highbd_sad16x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad16x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad16x16x4d sse2 neon avx2'))
 
-        add_proto(*qw('void vpx_highbd_sad16x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad16x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad16x8x4d sse2 neon avx2'))
 
-        add_proto(*qw('void vpx_highbd_sad8x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad8x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad8x16x4d sse2 neon'))
 
-        add_proto(*qw('void vpx_highbd_sad8x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad8x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad8x8x4d sse2 neon'))
 
-        add_proto(*qw('void vpx_highbd_sad8x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad8x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad8x4x4d sse2 neon'))
 
-        add_proto(*qw('void vpx_highbd_sad4x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad4x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad4x8x4d sse2 neon'))
 
-        add_proto(*qw('void vpx_highbd_sad4x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t* const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        add_proto(*qw('void vpx_highbd_sad4x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
         specialize(*qw('vpx_highbd_sad4x4x4d sse2 neon'))
 
+        add_proto(*qw('void vpx_highbd_sad_skip_64x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_64x64x4d neon sse2 avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_64x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_64x32x4d neon sse2 avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_32x64x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_32x64x4d neon sse2 avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_32x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_32x32x4d neon sse2 avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_32x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_32x16x4d neon sse2 avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_16x32x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_16x32x4d neon sse2 avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_16x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_16x16x4d neon sse2 avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_16x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_16x8x4d neon sse2 avx2'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_8x16x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_8x16x4d neon sse2'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_8x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_8x8x4d neon sse2'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_8x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_8x4x4d neon'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_4x8x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_4x8x4d neon sse2'))
+
+        add_proto(*qw('void vpx_highbd_sad_skip_4x4x4d'), "const uint8_t *src_ptr, int src_stride, const uint8_t *const ref_array[4], int ref_stride, uint32_t sad_array[4]")
+        specialize(*qw('vpx_highbd_sad_skip_4x4x4d neon'))
+
         #
         # Structured Similarity (SSIM)
         #
@@ -1091,73 +1261,73 @@ if vpx_config("CONFIG_ENCODERS") == "yes" or vpx_config("CONFIG_POSTPROC") == "y
     # Variance
     #
     add_proto(*qw('unsigned int vpx_variance64x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance64x64 sse2 avx2 neon msa mmi vsx lsx'))
+    specialize(*qw('vpx_variance64x64 sse2 avx2 neon neon_dotprod msa mmi vsx lsx'))
 
     add_proto(*qw('unsigned int vpx_variance64x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance64x32 sse2 avx2 neon msa mmi vsx'))
+    specialize(*qw('vpx_variance64x32 sse2 avx2 neon neon_dotprod msa mmi vsx'))
 
     add_proto(*qw('unsigned int vpx_variance32x64'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance32x64 sse2 avx2 neon msa mmi vsx'))
+    specialize(*qw('vpx_variance32x64 sse2 avx2 neon neon_dotprod msa mmi vsx'))
 
     add_proto(*qw('unsigned int vpx_variance32x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance32x32 sse2 avx2 neon msa mmi vsx lsx'))
+    specialize(*qw('vpx_variance32x32 sse2 avx2 neon neon_dotprod msa mmi vsx lsx'))
 
     add_proto(*qw('unsigned int vpx_variance32x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance32x16 sse2 avx2 neon msa mmi vsx'))
+    specialize(*qw('vpx_variance32x16 sse2 avx2 neon neon_dotprod msa mmi vsx'))
 
     add_proto(*qw('unsigned int vpx_variance16x32'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance16x32 sse2 avx2 neon msa mmi vsx'))
+    specialize(*qw('vpx_variance16x32 sse2 avx2 neon neon_dotprod msa mmi vsx'))
 
     add_proto(*qw('unsigned int vpx_variance16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance16x16 sse2 avx2 neon msa mmi vsx lsx'))
+    specialize(*qw('vpx_variance16x16 sse2 avx2 neon neon_dotprod msa mmi vsx lsx'))
 
     add_proto(*qw('unsigned int vpx_variance16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance16x8 sse2 avx2 neon msa mmi vsx'))
+    specialize(*qw('vpx_variance16x8 sse2 avx2 neon neon_dotprod msa mmi vsx'))
 
     add_proto(*qw('unsigned int vpx_variance8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance8x16 sse2 neon msa mmi vsx'))
+    specialize(*qw('vpx_variance8x16 sse2 avx2 neon neon_dotprod msa mmi vsx'))
 
     add_proto(*qw('unsigned int vpx_variance8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance8x8 sse2 neon msa mmi vsx lsx'))
+    specialize(*qw('vpx_variance8x8 sse2 avx2 neon neon_dotprod msa mmi vsx lsx'))
 
     add_proto(*qw('unsigned int vpx_variance8x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance8x4 sse2 neon msa mmi vsx'))
+    specialize(*qw('vpx_variance8x4 sse2 avx2 neon neon_dotprod msa mmi vsx'))
 
     add_proto(*qw('unsigned int vpx_variance4x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance4x8 sse2 neon msa mmi vsx'))
+    specialize(*qw('vpx_variance4x8 sse2 neon neon_dotprod msa mmi vsx'))
 
     add_proto(*qw('unsigned int vpx_variance4x4'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_variance4x4 sse2 neon msa mmi vsx'))
+    specialize(*qw('vpx_variance4x4 sse2 neon neon_dotprod msa mmi vsx'))
 
     #
     # Specialty Variance
     #
     add_proto(*qw('void vpx_get16x16var'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum")
-    specialize(*qw('vpx_get16x16var sse2 avx2 neon msa vsx lsx'))
+    specialize(*qw('vpx_get16x16var sse2 avx2 neon neon_dotprod msa vsx lsx'))
 
     add_proto(*qw('void vpx_get8x8var'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse, int *sum")
-    specialize(*qw('vpx_get8x8var sse2 neon msa vsx'))
+    specialize(*qw('vpx_get8x8var sse2 neon neon_dotprod msa vsx'))
 
     add_proto(*qw('unsigned int vpx_mse16x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_mse16x16 sse2 avx2 neon msa mmi vsx lsx'))
+    specialize(*qw('vpx_mse16x16 sse2 avx2 neon neon_dotprod msa mmi vsx lsx'))
 
     add_proto(*qw('unsigned int vpx_mse16x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_mse16x8 sse2 avx2 msa mmi vsx'))
+    specialize(*qw('vpx_mse16x8 sse2 avx2 neon neon_dotprod msa mmi vsx'))
 
     add_proto(*qw('unsigned int vpx_mse8x16'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_mse8x16 sse2 msa mmi vsx'))
+    specialize(*qw('vpx_mse8x16 sse2 neon neon_dotprod msa mmi vsx'))
 
     add_proto(*qw('unsigned int vpx_mse8x8'), "const uint8_t *src_ptr, int src_stride, const uint8_t *ref_ptr, int ref_stride, unsigned int *sse")
-    specialize(*qw('vpx_mse8x8 sse2 msa mmi vsx'))
+    specialize(*qw('vpx_mse8x8 sse2 neon neon_dotprod msa mmi vsx'))
 
     add_proto(*qw('unsigned int vpx_get_mb_ss'), "const int16_t *")
     specialize(*qw('vpx_get_mb_ss sse2 msa vsx'))
 
     add_proto(*qw('unsigned int vpx_get4x4sse_cs'), "const unsigned char *src_ptr, int src_stride, const unsigned char *ref_ptr, int ref_stride")
-    specialize(*qw('vpx_get4x4sse_cs neon msa vsx'))
+    specialize(*qw('vpx_get4x4sse_cs neon neon_dotprod msa vsx'))
 
     add_proto(*qw('void vpx_comp_avg_pred'), "uint8_t *comp_pred, const uint8_t *pred, int width, int height, const uint8_t *ref, int ref_stride")
-    specialize(*qw('vpx_comp_avg_pred neon sse2 vsx lsx'))
+    specialize(*qw('vpx_comp_avg_pred neon sse2 avx2 vsx lsx'))
 
     #
     # Subpixel Variance
diff --git a/vpx_ports/meson.build b/vpx_ports/meson.build
index 961ed54bd..c8079af98 100644
--- a/vpx_ports/meson.build
+++ b/vpx_ports/meson.build
@@ -12,9 +12,6 @@ ports_optional_sources = {
 	'mmx' : files(
 		# 'emms_mmx.c' # MANUAL
 	),
-	'arm' : files(
-		'arm_cpudetect.c',
-	),
 	'ppc' : files(
 		'ppc_cpudetect.c',
 	),
@@ -24,6 +21,7 @@ ports_optional_sources = {
 	'loongarch' : files(
 		'loongarch_cpudetect.c',
 	),
+	'arm': files(), # MANUAL
 }
 
 ports_headers_sources = files(
@@ -41,6 +39,7 @@ ports_headers_sources = files(
 ports_headers_optional_sources = {
 	'arm' : files(
 		'arm.h',
+		'arm_cpudetect.h'
 	),
 	'ppc' : files(
 		'ppc.h',
@@ -66,6 +65,8 @@ ports_asm_optional_sources = {
 	),
 }
 
+#### --- END GENERATED --- ####
+
 ports_headers_sources += files( # MANUAL
 	'emmintrin_compat.h',
 	'mem_ops.h',
@@ -73,6 +74,18 @@ ports_headers_sources += files( # MANUAL
 	'vpx_once.h',
 )
 
+if features.get('aarch64', false) # MANUAL
+	ports_sources += files(
+		'aarch64_cpudetect.c'
+	)
+else
+	ports_optional_sources += {
+		'arm' : ports_optional_sources['arm'] + files(
+			'aarch32_cpudetect.c'
+		),
+	}
+endif
+
 if features.get('x86', false) # MANUAL
 	ports_optional_sources += {
 		'mmx' : ports_optional_sources['mmx'] + files(
@@ -115,8 +128,6 @@ ports_headers_optional_sources += { # MANUAL
 	)
 }
 
-#### --- END GENERATED --- ####
-
 codec_srcs += ports_sources
 optional_sources = get_variable('ports_optional_sources', {})
 foreach comp_name, comp_sources : optional_sources
diff --git a/vpx_util/meson.build b/vpx_util/meson.build
index e39384421..fa6d42e5e 100644
--- a/vpx_util/meson.build
+++ b/vpx_util/meson.build
@@ -30,6 +30,9 @@ util_headers_optional_sources = {
 	),
 }
 
+#### --- END GENERATED --- ####
+
+
 if features.get('bitstream_debug', false) or features.get('mismatch_debug', false)
 	util_sources += files(
 		'vpx_debug_util.c'
@@ -40,8 +43,6 @@ if features.get('bitstream_debug', false) or features.get('mismatch_debug', fals
 	)
 endif
 
-#### --- END GENERATED --- ####
-
 optional_sources = get_variable('util_optional_sources', {})
 foreach comp_name, comp_sources : optional_sources
 	if features.get(comp_name, false)
-- 
2.44.0.windows.1


From e9e378d725ae4d0fadcc5e8ac72105b3e1edbd5c Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Wed, 10 Jul 2024 19:50:24 -0300
Subject: [PATCH] meson: Properly ban shared libraries with the MSVC ABI

I hadn't noticed that the codeblock already existed, it was just in a
different place.

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/21>

diff --git a/meson.build b/meson.build
index 198165e61..fee067173 100644
--- a/meson.build
+++ b/meson.build
@@ -1542,12 +1542,14 @@ endif
 
 ### process_detect ###
 
-# Shared builds are supported everywhere thanks to
-# the Meson generation of the module definition files.
-# if features.get('shared', false) and not ['linux', 'solaris', 'darwin', 'iphonesimulator'].contains(tgt_os) and not features.get('gnu', false)
-# 	# Again, no OS/2 because Meson itself doens't support it
-# 	error('Shared library build is only supported on ELF and Darwin for now')
-# endif
+# MSVC requires declspec on data symbols when importing from a shared library.
+if features.get('shared', false) and not ['linux', 'solaris', 'darwin', 'ios', 'iphonesimulator'].contains(tgt_os) 
+	if features.get('gcc', false) # Looks like a typo on upstream
+		warning('Shared library build is only supported on ELF; assuming this is OK')
+	else
+ 		error('Shared library build is only supported on ELF and Darwin for now')
+	endif
+endif
 
 features.set('unistd_h', c.has_header('unistd.h'))
 if c.has_header('vpx/vpx_integer.h', include_directories: include_directories('.'))
@@ -1670,14 +1672,6 @@ vpx_config_c = configure_file(
 
 # libs.mk
 
-if features.get('shared', false) and not ['linux', 'darwin', 'ios', 'iphonesimulator'].contains(tgt_os)
-	if features.get('gcc', false) # Looks like a typo on upstream
-		warn('Shared libraries are only supported on ELF; assuming this is OK')
-	else
-		error('Shared libraries are only supported on ELF, OS/2, and Darwin for now')
-	endif
-endif
-
 rtcd_exe = find_program('build/make/rtcd.py', required: true)
 
 extra_libs += c.find_library('m', required: false)
-- 
2.44.0.windows.1


From 26d95c89ad8da6f958e909783c3c353d7ee4ca86 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Thu, 11 Jul 2024 01:10:29 +0000
Subject: [PATCH] meson: Fix wrong Xcode testing for armv7

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/21>

diff --git a/meson.build b/meson.build
index fee067173..df50b53d4 100644
--- a/meson.build
+++ b/meson.build
@@ -765,7 +765,7 @@ if tgt_isa.startswith('arm')
 					check: true
 				).stdout().strip().split('\n').get(0, '').split()
 
-				if features.get('neon', false) and xcode_version.get(1, '').version_compare('>=6.3')
+				if features.get('neon', false) and not xcode_version.get(1, '').version_compare('>=6.3')
 					feature = 'neon'
 					if not features.get(feature, false)
 						if not features.has(feature)
-- 
2.44.0.windows.1


From 2918ddf8a880cf0d9768b1c8464d288c2fcb87c0 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Sat, 20 Jul 2024 20:56:31 +0000
Subject: [PATCH] meson: Fix discrepancy in option formatting between the RTCD
 Perl and Python generators

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/21>

diff --git a/meson.build b/meson.build
index df50b53d4..0ad31918a 100644
--- a/meson.build
+++ b/meson.build
@@ -1816,7 +1816,20 @@ else
 	asm_compiler = disabler()
 endif
 
-rtcd_h_template = ['--arch=@0@'.format(tgt_isa), '--config=@INPUT0@'] + rtcd_options
+rtcd_h_template = ['--arch=@0@'.format(tgt_isa), '--config=@INPUT0@']
+
+original_rtcd_options = []
+merge_rtcd_opt = ''
+foreach opt: rtcd_options
+	if merge_rtcd_opt != ''
+		original_rtcd_options += ['@0@-@1@'.format(merge_rtcd_opt, opt)]
+		merge_rtcd_opt = ''
+	elif opt == '--disable'
+		merge_rtcd_opt = opt
+	else
+		original_rtcd_options += opt
+	endif
+endforeach
 
 doxy_template = find_program('meson/generate_doxy.py', required: true)
 
@@ -1849,7 +1862,7 @@ foreach symbol, input_file : codec_rtcds
 	rtcd_py = files(input_file)
 
 	rtcd_h = configure_file(
-		command: [rtcd_exe] + rtcd_h_template + ['--sym=@0@'.format(symbol), '@INPUT1@'],
+		command: [rtcd_exe] + rtcd_h_template + rtcd_options + ['--sym=@0@'.format(symbol), '@INPUT1@'],
 		input: [config_mk] + rtcd_py,
 		output: rtcd_filename,
 		capture: true,
@@ -1864,7 +1877,7 @@ foreach symbol, input_file : codec_rtcds
 		)
 
 		original_rtcd_h = configure_file(
-			command: [original_rtcd_exe] + rtcd_h_template + ['--sym=@0@'.format(symbol), '@INPUT1@'],
+			command: [original_rtcd_exe] + rtcd_h_template + original_rtcd_options + ['--sym=@0@'.format(symbol), '@INPUT1@'],
 			input: [config_mk] + original_rtcd_pl,
 			output: 'original@0@'.format(rtcd_filename),
 			capture: true,
-- 
2.44.0.windows.1


From 31fdd5dd78347b2468d8a3c4a946f21d230cf19b Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Tue, 6 Aug 2024 17:00:29 -0300
Subject: [PATCH] vp9: Fix Apple silicon build

ld: Undefined symbols:
  _vp9_block_error_fp_neon, referenced from:
      _block_yrd in vp9_encoder_vp9_pickmode.c.o
  _vp9_block_error_neon, referenced from:
      _rd_pick_intra_sub_8x8_y_mode in vp9_encoder_vp9_rdopt.c.o
      _rd_pick_intra_sub_8x8_y_mode in vp9_encoder_vp9_rdopt.c.o
      _rd_pick_best_sub8x8_mode in vp9_encoder_vp9_rdopt.c.o
      _dist_block in vp9_encoder_vp9_rdopt.c.o
      _vp9_setup_tpl_stats in vp9_encoder_vp9_tpl_model.c.o

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/21>

diff --git a/vp9/meson.build b/vp9/meson.build
index e9314966c..c1c63f044 100644
--- a/vp9/meson.build
+++ b/vp9/meson.build
@@ -131,7 +131,7 @@ vp9_cx_optional_sources = {
 		# 'encoder/arm/neon/vp9_highbd_temporal_filter_neon.c', # MANUAL
 		'encoder/arm/neon/vp9_dct_neon.c',
 		# 'encoder/arm/neon/vp9_denoiser_neon.c', # MANUAL
-		# 'encoder/arm/neon/vp9_error_neon.c', # MANUAL
+		'encoder/arm/neon/vp9_error_neon.c',
 		'encoder/arm/neon/vp9_frame_scale_neon.c',
 		'encoder/arm/neon/vp9_quantize_neon.c',
 		# 'encoder/arm/neon/vp9_highbd_error_neon.c', # MANUAL
@@ -380,9 +380,6 @@ if features.get('vp9_highbitdepth', false)
 	}
 else
 	vp9_cx_optional_sources += {
-		'neon' : vp9_cx_optional_sources['neon'] + files(
-			'encoder/arm/neon/vp9_error_neon.c',
-		),
 		'msa' : vp9_cx_optional_sources['msa'] + files(
 			'encoder/mips/msa/vp9_fdct4x4_msa.c',
 			'encoder/mips/msa/vp9_fdct8x8_msa.c',
-- 
2.44.0.windows.1


From 6f80ad7c656f3b0373afaf5fac8698c794b084f2 Mon Sep 17 00:00:00 2001
From: "L. E. Segovia" <amy@centricular.com>
Date: Mon, 2 Sep 2024 12:51:27 -0300
Subject: [PATCH] meson: Fix missing install of vpx_tpl.h header

See gstreamer/gstreamer#3765

Part-of: <https://gitlab.freedesktop.org/gstreamer/meson-ports/libvpx/-/merge_requests/23>

diff --git a/meson.build b/meson.build
index 0ad31918a..e34ab284b 100644
--- a/meson.build
+++ b/meson.build
@@ -1970,7 +1970,7 @@ if features.get('vp8_encoder', false) or features.get('vp9_encoder', false)
 	headers += files(
 		'vpx/vp8.h',
 		'vpx/vp8cx.h',
-  		'vpx/vpx_ext_ratectrl.h',
+		'vpx/vpx_ext_ratectrl.h',
 	)
 endif
 if features.get('vp8_decoder', false) or features.get('vp9_decoder', false)
@@ -1987,6 +1987,7 @@ endif
 if features.get('encoders', false)
 	headers += files(
 		'vpx/vpx_encoder.h',
+		'vpx/vpx_tpl.h',
 	)
 endif
 
@@ -2146,3 +2147,4 @@ if features.get('install_docs', false)
 		install_dir: get_option('datadir') / meson.project_name(),
 	)
 endif
+
diff --git a/vpx/meson.build b/vpx/meson.build
index 854e49f75..23600e597 100644
--- a/vpx/meson.build
+++ b/vpx/meson.build
@@ -26,7 +26,6 @@ api_headers_sources = files(
 	'vpx_image.h',
 	'vpx_integer.h',
 	'vpx_ext_ratectrl.h',
-	'vpx_tpl.h',
 )
 
 api_headers_optional_sources = {
@@ -94,7 +93,7 @@ foreach comp_name, comp_sources : optional_sources
 			comp_name: codec_arch_headers.get(comp_name, []) + comp_sources
 		}
 	else
-		api_headers_sources += comp_sources
+		codec_headers += comp_sources
 	endif
 endforeach
 
-- 
2.44.0.windows.1

