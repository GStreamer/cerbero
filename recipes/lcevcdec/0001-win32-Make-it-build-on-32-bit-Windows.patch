From 2a8d42ed9abff0567a803ca98a776226f6bc968f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Olivier=20Cr=C3=AAte?= <olivier.crete@collabora.com>
Date: Wed, 6 Aug 2025 15:19:52 -0400
Subject: [PATCH 1/4] win32: Make it build on 32-bit Windows

---
 src/common/src/threads_win32.c | 107 +++++++++++++++++++++++++++++++++
 1 file changed, 107 insertions(+)

diff --git a/src/common/src/threads_win32.c b/src/common/src/threads_win32.c
index c92f064..19cdfd5 100644
--- a/src/common/src/threads_win32.c
+++ b/src/common/src/threads_win32.c
@@ -21,6 +21,7 @@
 #include <stdlib.h>
 
 #ifdef __MINGW32__
+#ifdef __SIZEOF_INT128__
 static uint64_t _div128(uint64_t hi, uint64_t lo, uint64_t divisor, int64_t* remainder)
 {
     if (divisor == 0) {
@@ -39,6 +40,112 @@ static int64_t mulh(int64_t a, int64_t b)
     __int128 result = (__int128)a * (__int128)b;
     return (int64_t)(result >> 64);
 }
+#else
+
+uint64_t _div128(uint64_t dividend_high, uint64_t dividend_low, 
+                 uint64_t divisor, int64_t* remainder) {
+    
+    // Handle division by zero
+    if (divisor == 0) {
+        if (remainder) *remainder = 0;
+        return UINT64_MAX; // Return max value to indicate error
+    }
+    
+    // Handle case where dividend < divisor
+    if (dividend_high == 0 && dividend_low < divisor) {
+        if (remainder) *remainder = dividend_low;
+        return 0;
+    }
+    
+    // Handle case where divisor is 1
+    if (divisor == 1) {
+        if (remainder) *remainder = 0;
+        return dividend_low; // Note: assumes quotient fits in 64 bits
+    }
+    
+    // Use long division algorithm for 128-bit / 64-bit division
+    uint64_t quotient = 0;
+    uint64_t current_remainder_high = dividend_high;
+    uint64_t current_remainder_low = dividend_low;
+    
+    // Find the highest set bit in the dividend
+    int shift = 0;
+    if (dividend_high != 0) {
+        shift = 63 - __builtin_clzll(dividend_high) + 64;
+    } else if (dividend_low != 0) {
+        shift = 63 - __builtin_clzll(dividend_low);
+    } else {
+        // Dividend is zero
+        if (remainder) *remainder = 0;
+        return 0;
+    }
+    
+    // Perform long division bit by bit
+    for (int i = shift; i >= 0; i--) {
+        // Shift current remainder left by 1
+        uint64_t temp_high = current_remainder_high;
+        current_remainder_high = (current_remainder_high << 1) | 
+                                (current_remainder_low >> 63);
+        current_remainder_low = current_remainder_low << 1;
+        
+        // Check if we can subtract the divisor
+        if (current_remainder_high > divisor || 
+            (current_remainder_high == divisor && current_remainder_low >= 0)) {
+            
+            // Subtract divisor from current remainder
+            if (current_remainder_low < divisor) {
+                current_remainder_high--;
+            }
+            current_remainder_low -= divisor;
+            current_remainder_high -= (current_remainder_high >= divisor) ? divisor : 0;
+            
+            // Set the corresponding bit in quotient
+            if (i < 64) {
+                quotient |= (1ULL << i);
+            }
+        }
+    }
+    
+    if (remainder) {
+        *remainder = (int64_t)current_remainder_low;
+    }
+    
+    return quotient;
+}
+
+uint64_t mulh(uint64_t a, uint64_t b) {
+    // Handle zero cases
+    if (a == 0 || b == 0) {
+        return 0;
+    }
+    
+    // Split each 64-bit number into two 32-bit parts
+    uint64_t a_low = a & 0xFFFFFFFFULL;
+    uint64_t a_high = a >> 32;
+    uint64_t b_low = b & 0xFFFFFFFFULL;
+    uint64_t b_high = b >> 32;
+    
+    // Compute partial products
+    uint64_t low_low = a_low * b_low;
+    uint64_t low_high = a_low * b_high;
+    uint64_t high_low = a_high * b_low;
+    uint64_t high_high = a_high * b_high;
+    
+    // Combine partial products
+    // The full 128-bit result would be:
+    // high_high << 64 + (low_high + high_low) << 32 + low_low
+    
+    uint64_t middle = low_high + high_low;
+    uint64_t middle_carry = (middle < low_high) ? 1 : 0; // Check for overflow
+    
+    uint64_t low_part_carry = (low_low >> 32) + (middle & 0xFFFFFFFFULL);
+    uint64_t final_carry = (low_part_carry >> 32);
+    
+    uint64_t result = high_high + (middle >> 32) + middle_carry + final_carry;
+    
+    return result;
+}
+#endif
 #endif
 
 int32_t threadNumCores(void)
-- 
2.51.1

