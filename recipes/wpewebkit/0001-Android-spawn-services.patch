From 21ee7968803e759bc503c4199ddca062acef3e8f Mon Sep 17 00:00:00 2001
From: Fernando Jimenez <fjimenez@igalia.com>
Date: Mon, 15 Feb 2021 12:18:26 +0100
Subject: [PATCH] Android: spawn WPEWebProcess and WPENetworkProcess services

---
 .../Launcher/glib/ProcessLauncherGLib.cpp     | 131 +++---------------
 1 file changed, 23 insertions(+), 108 deletions(-)

diff --git a/Source/WebKit/UIProcess/Launcher/glib/ProcessLauncherGLib.cpp b/Source/WebKit/UIProcess/Launcher/glib/ProcessLauncherGLib.cpp
index f8008c0d..a8a2f512 100644
--- a/Source/WebKit/UIProcess/Launcher/glib/ProcessLauncherGLib.cpp
+++ b/Source/WebKit/UIProcess/Launcher/glib/ProcessLauncherGLib.cpp
@@ -42,6 +42,9 @@
 #include <wtf/text/CString.h>
 #include <wtf/text/WTFString.h>
 
+#include <dlfcn.h>
+#include <jni.h>
+
 namespace WebKit {
 
 static void childSetupFunction(gpointer userData)
@@ -109,113 +112,29 @@ void ProcessLauncher::launchProcess()
 {
     IPC::Connection::SocketPair socketPair = IPC::Connection::createPlatformConnection(IPC::Connection::ConnectionOptions::SetCloexecOnServer);
 
-    String executablePath;
-    CString realExecutablePath;
-#if ENABLE(NETSCAPE_PLUGIN_API)
-    String pluginPath;
-    CString realPluginPath;
-#endif
-    switch (m_launchOptions.processType) {
-    case ProcessLauncher::ProcessType::Web:
-        executablePath = executablePathOfWebProcess();
-        break;
-#if ENABLE(NETSCAPE_PLUGIN_API)
-    case ProcessLauncher::ProcessType::Plugin:
-        executablePath = executablePathOfPluginProcess();
-        pluginPath = m_launchOptions.extraInitializationData.get("plugin-path");
-        realPluginPath = FileSystem::fileSystemRepresentation(pluginPath);
-        break;
-#endif
-    case ProcessLauncher::ProcessType::Network:
-        executablePath = executablePathOfNetworkProcess();
-        break;
-#if ENABLE(GPU_PROCESS)
-    case ProcessLauncher::ProcessType::GPU:
-        executablePath = executablePathOfGPUProcess();
-        break;
-#endif
-    default:
-        ASSERT_NOT_REACHED();
-        return;
-    }
-
-    realExecutablePath = FileSystem::fileSystemRepresentation(executablePath);
-    GUniquePtr<gchar> processIdentifier(g_strdup_printf("%" PRIu64, m_launchOptions.processIdentifier.toUInt64()));
-    GUniquePtr<gchar> webkitSocket(g_strdup_printf("%d", socketPair.client));
-    unsigned nargs = 5; // size of the argv array for g_spawn_async()
-
-#if ENABLE(DEVELOPER_MODE)
-    Vector<CString> prefixArgs;
-    if (!m_launchOptions.processCmdPrefix.isNull()) {
-        for (auto& arg : m_launchOptions.processCmdPrefix.split(' '))
-            prefixArgs.append(arg.utf8());
-        nargs += prefixArgs.size();
-    }
-
-    bool configureJSCForTesting = false;
-    if (m_launchOptions.processType == ProcessLauncher::ProcessType::Web && m_client && m_client->shouldConfigureJSCForTesting()) {
-        configureJSCForTesting = true;
-        nargs++;
-    }
-#endif
-
-    char** argv = g_newa(char*, nargs);
-    unsigned i = 0;
-#if ENABLE(DEVELOPER_MODE)
-    // If there's a prefix command, put it before the rest of the args.
-    for (auto& arg : prefixArgs)
-        argv[i++] = const_cast<char*>(arg.data());
-#endif
-    argv[i++] = const_cast<char*>(realExecutablePath.data());
-    argv[i++] = processIdentifier.get();
-    argv[i++] = webkitSocket.get();
-#if ENABLE(DEVELOPER_MODE)
-    if (configureJSCForTesting)
-        argv[i++] = const_cast<char*>("--configure-jsc-for-testing");
-#endif
-#if ENABLE(NETSCAPE_PLUGIN_API)
-    argv[i++] = const_cast<char*>(realPluginPath.data());
-#else
-    argv[i++] = nullptr;
-#endif
-    argv[i++] = nullptr;
-
-    GRefPtr<GSubprocessLauncher> launcher = adoptGRef(g_subprocess_launcher_new(G_SUBPROCESS_FLAGS_INHERIT_FDS));
-    g_subprocess_launcher_set_child_setup(launcher.get(), childSetupFunction, GINT_TO_POINTER(socketPair.server), nullptr);
-    g_subprocess_launcher_take_fd(launcher.get(), socketPair.client, socketPair.client);
+    // Android prohibits the forking syscall on non-rooted devices, so we need to
+    // provide separate services equivalent to WPEWebProcess and WPENetworkProcess
+    // that are spawned from the Java part.
+    WTFLogAlways("ProcessLauncher::launchProcess() processType %d\n",
+                 m_launchOptions.processType);
 
-    GUniqueOutPtr<GError> error;
-    GRefPtr<GSubprocess> process;
+    JNIEnv* jniEnv = *reinterpret_cast<JNIEnv**>(dlsym(RTLD_DEFAULT, "s_WPEUIProcessGlue_env"));
+    jobject jniObj = *reinterpret_cast<jobject*>(dlsym(RTLD_DEFAULT, "s_WPEUIProcessGlue_object"));
+    {
+        jclass jClass = jniEnv->GetObjectClass(jniObj);
+        WTFLogAlways("  jClass for com/wpe/wpe/WPEUIProcessGlue %p", jClass);
+        jmethodID jMethodID = jniEnv->GetMethodID(jClass, "launchProcess", "(I[I)V");
+        WTFLogAlways("  jMethodID for launchProcess %p", jMethodID);
 
-#if OS(LINUX)
-    const char* sandboxEnv = g_getenv("WEBKIT_FORCE_SANDBOX");
-    bool sandboxEnabled = m_launchOptions.extraInitializationData.get("enable-sandbox") == "true";
+        jintArray fdArray = jniEnv->NewIntArray(2);
+        int fdArrayValues[2] = { socketPair.client, -1 };
+        jniEnv->SetIntArrayRegion(fdArray, 0, 2, fdArrayValues);
 
-    if (sandboxEnv)
-        sandboxEnabled = !strcmp(sandboxEnv, "1");
-
-    if (sandboxEnabled && isFlatpakSpawnUsable())
-        process = flatpakSpawn(launcher.get(), m_launchOptions, argv, socketPair.client, &error.outPtr());
-#if ENABLE(BUBBLEWRAP_SANDBOX)
-    // You cannot use bubblewrap within Flatpak or Docker so lets ensure it never happens.
-    // Snap can allow it but has its own limitations that require workarounds.
-    else if (sandboxEnabled && !isInsideFlatpak() && !isInsideSnap() && !isInsideDocker())
-        process = bubblewrapSpawn(launcher.get(), m_launchOptions, argv, &error.outPtr());
-#endif // ENABLE(BUBBLEWRAP_SANDBOX)
-    else
-#endif // OS(LINUX)
-        process = adoptGRef(g_subprocess_launcher_spawnv(launcher.get(), argv, &error.outPtr()));
+        jniEnv->CallVoidMethod(jniObj, jMethodID, static_cast<int>(m_launchOptions.processType), fdArray);
 
-    if (!process.get())
-        g_error("Unable to fork a new child process: %s", error->message);
-
-    const char* processIdStr = g_subprocess_get_identifier(process.get());
-    m_processIdentifier = g_ascii_strtoll(processIdStr, nullptr, 0);
-    RELEASE_ASSERT(m_processIdentifier);
-
-    // Don't expose the parent socket to potential future children.
-    if (!setCloseOnExec(socketPair.client))
-        RELEASE_ASSERT_NOT_REACHED();
+        jniEnv->DeleteLocalRef(fdArray);
+        jniEnv->DeleteLocalRef(jClass);
+    }
 
     // We've finished launching the process, message back to the main run loop.
     RunLoop::main().dispatch([protectedThis = makeRef(*this), this, serverSocket = socketPair.server] {
@@ -230,11 +149,7 @@ void ProcessLauncher::terminateProcess()
         return;
     }
 
-    if (!m_processIdentifier)
-        return;
-
-    kill(m_processIdentifier, SIGKILL);
-    m_processIdentifier = 0;
+    // TODO: Call into the Android layer to terminate the equivalent service.
 }
 
 void ProcessLauncher::platformInvalidate()
-- 
2.25.1

